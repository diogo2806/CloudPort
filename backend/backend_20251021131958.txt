----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\.gitignore ----- 
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\pom.xml ----- 
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.5.4</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.cloudport</groupId>
	<artifactId>servico-autenticacao</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>servico-autenticacao</name>
	<description>Serviço responsável pela autenticação e autorização de usuários na aplicação CloudPort.</description>
	<properties>
		<java.version>11</java.version>
	</properties>
        <dependencies>
                <dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.modelmapper.extensions</groupId>
			<artifactId>modelmapper-spring</artifactId>
			<version>3.1.1</version>
		</dependency>
		<dependency>
			<groupId>org.modelmapper</groupId>
			<artifactId>modelmapper</artifactId>
			<version>3.1.0</version>
		</dependency>
		<dependency>
			<groupId>io.springfox</groupId>
			<artifactId>springfox-boot-starter</artifactId>
			<version>3.0.0</version>
		</dependency>
		<dependency>
			<groupId>io.springfox</groupId>
			<artifactId>springfox-spring-webmvc</artifactId>
			<version>3.0.0</version>
		</dependency>

                <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-data-jpa</artifactId>
                </dependency>
		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-api</artifactId>
			<version>5.7.0</version>
			<scope>test</scope>
		</dependency>
                <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-test</artifactId>
                        <scope>test</scope>
                </dependency>
                <dependency>
                        <groupId>org.springframework.security</groupId>
                        <artifactId>spring-security-test</artifactId>
                        <scope>test</scope>
                </dependency>
                <dependency>
                        <groupId>com.h2database</groupId>
                        <artifactId>h2</artifactId>
                        <scope>test</scope>
                </dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
                        <version>42.5.5</version>
		</dependency>
                <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-log4j2</artifactId>
                </dependency>
                <dependency>
                        <groupId>io.jsonwebtoken</groupId>
                        <artifactId>jjwt-api</artifactId>
                        <version>0.11.5</version>
                </dependency>
                <dependency>
                        <groupId>io.jsonwebtoken</groupId>
                        <artifactId>jjwt-impl</artifactId>
                        <version>0.11.5</version>
                        <scope>runtime</scope>
                </dependency>
                <dependency>
                        <groupId>io.jsonwebtoken</groupId>
                        <artifactId>jjwt-jackson</artifactId>
                        <version>0.11.5</version>
                        <scope>runtime</scope>
                </dependency>
                <dependency>
                        <groupId>org.hibernate.validator</groupId>
                        <artifactId>hibernate-validator</artifactId>
                        <version>6.2.0.Final</version>
                </dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\.mvn\wrapper\maven-wrapper.properties ----- 
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.3/apache-maven-3.9.3-bin.zip
wrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\ServicoAutenticacaoApplication.java ----- 
package br.com.cloudport.servicoautenticacao;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServicoAutenticacaoApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServicoAutenticacaoApplication.class, args);
	}

}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\administracao\dto\UsuarioInfoDTO.java ----- 
package br.com.cloudport.servicoautenticacao.app.administracao.dto;

import br.com.cloudport.servicoautenticacao.model.Papel;
import br.com.cloudport.servicoautenticacao.model.Usuario;
import br.com.cloudport.servicoautenticacao.model.UsuarioPapel;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.util.StringUtils;

public class UsuarioInfoDTO {

    private final UUID id;
    private final String login;
    private final String nome;
    private final Set<String> papeis;
    private final String perfil;
    private final String transportadoraDocumento;
    private final String transportadoraNome;

    public UsuarioInfoDTO(UUID id,
                          String login,
                          String nome,
                          Set<String> papeis,
                          String perfil,
                          String transportadoraDocumento,
                          String transportadoraNome) {
        this.id = id;
        this.login = login;
        this.nome = nome;
        this.papeis = papeis;
        this.perfil = perfil;
        this.transportadoraDocumento = transportadoraDocumento;
        this.transportadoraNome = transportadoraNome;
    }

    public static UsuarioInfoDTO fromUsuario(Usuario usuario) {
        Set<String> papeis = usuario.getPapeis().stream()
                .map(UsuarioPapel::getPapel)
                .map(Papel::getNome)
                .filter(StringUtils::hasText)
                .map(nomePapel -> nomePapel.startsWith("ROLE_") ? nomePapel : "ROLE_" + nomePapel.toUpperCase())
                .collect(Collectors.toCollection(LinkedHashSet::new));
        String perfil = papeis.stream().findFirst().orElse("");
        String nome = StringUtils.hasText(usuario.getNome()) ? usuario.getNome() : usuario.getLogin();
        return new UsuarioInfoDTO(
                usuario.getId(),
                usuario.getLogin(),
                nome,
                papeis,
                perfil,
                usuario.getTransportadoraDocumento(),
                usuario.getTransportadoraNome()
        );
    }

    public UUID getId() {
        return id;
    }

    public String getLogin() {
        return login;
    }

    public String getNome() {
        return nome;
    }

    public Set<String> getPapeis() {
        return papeis;
    }

    public String getPerfil() {
        return perfil;
    }

    public String getTransportadoraDocumento() {
        return transportadoraDocumento;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\configuracoes\dto\AuthenticationDTO.java ----- 
package br.com.cloudport.servicoautenticacao.app.configuracoes.dto;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.fasterxml.jackson.annotation.JsonProperty;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;

public class AuthenticationDTO {
    @NotBlank(message = "O login é obrigatório.")
    @Size(min = 3, max = 100, message = "O login deve ter entre 3 e 100 caracteres.")
    @Pattern(regexp = "^[\\p{L}\\p{N}@._-]+$", message = "O login contém caracteres inválidos.")
    private String login;

    @NotBlank(message = "A senha é obrigatória.")
    @Size(min = 6, max = 255, message = "A senha deve ter pelo menos 6 caracteres.")
    @JsonProperty("senha")
    @JsonAlias({"password"})
    @Pattern(regexp = "^(?!.*[<>]).*$", message = "A senha não pode conter os caracteres < ou >.")
    private String senha;

    public AuthenticationDTO() {}

    public AuthenticationDTO(String login, String senha) {
        this.login = login;
        this.senha = senha;
    }

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public String getSenha() {
        return senha;
    }

    public void setSenha(String senha) {
        this.senha = senha;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\configuracoes\dto\LoginResponseDTO.java ----- 
package br.com.cloudport.servicoautenticacao.app.configuracoes.dto;


import java.util.Set;
import java.util.UUID;

public class LoginResponseDTO {
    private final UUID id;
    private final String login;
    private final String nome;
    private final String perfil;
    private final String token;
    private final Set<String> roles;
    private final String transportadoraDocumento;
    private final String transportadoraNome;

    public LoginResponseDTO(UUID id,
                            String login,
                            String nome,
                            String perfil,
                            String token,
                            Set<String> roles,
                            String transportadoraDocumento,
                            String transportadoraNome) {
        this.id = id;
        this.login = login;
        this.nome = nome;
        this.perfil = perfil;
        this.token = token;
        this.roles = roles;
        this.transportadoraDocumento = transportadoraDocumento;
        this.transportadoraNome = transportadoraNome;
    }

    public UUID getId() {
        return id;
    }

    public String getLogin() {
        return login;
    }

    public String getNome() {
        return nome;
    }

    public String getPerfil() {
        return perfil;
    }

    public String getToken() {
        return token;
    }

    public Set<String> getRoles() {
        return roles;
    }

    public String getTransportadoraDocumento() {
        return transportadoraDocumento;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }
}

 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\configuracoes\dto\RegisterDTO.java ----- 
package br.com.cloudport.servicoautenticacao.app.configuracoes.dto;


import java.util.Set;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.Size;

public class RegisterDTO {
    @NotBlank(message = "O login é obrigatório.")
    @Size(min = 3, max = 100, message = "O login deve ter entre 3 e 100 caracteres.")
    private String login;

    @NotBlank(message = "A senha é obrigatória.")
    @Size(min = 6, max = 255, message = "A senha deve ter pelo menos 6 caracteres.")
    private String password;

    @NotEmpty(message = "Informe ao menos uma role.")
    private Set<@NotBlank(message = "A role não pode ser vazia.") String> roles;

    @Size(max = 255, message = "O nome deve ter no máximo 255 caracteres.")
    private String nome;

    @Size(max = 30, message = "O documento da transportadora deve ter no máximo 30 caracteres.")
    private String transportadoraDocumento;

    @Size(max = 255, message = "O nome da transportadora deve ter no máximo 255 caracteres.")
    private String transportadoraNome;

    public RegisterDTO() {}

    public RegisterDTO(String login, String password, Set<String> roles) {
        this.login = login;
        this.password = password;
        this.roles = roles;
    }

    public RegisterDTO(String login, String password, Set<String> roles, String nome,
                       String transportadoraDocumento, String transportadoraNome) {
        this(login, password, roles);
        this.nome = nome;
        this.transportadoraDocumento = transportadoraDocumento;
        this.transportadoraNome = transportadoraNome;
    }

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Set<String> getRoles() {
        return roles;
    }

    public void setRoles(Set<String> roles) {
        this.roles = roles;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getTransportadoraDocumento() {
        return transportadoraDocumento;
    }

    public void setTransportadoraDocumento(String transportadoraDocumento) {
        this.transportadoraDocumento = transportadoraDocumento;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }

    public void setTransportadoraNome(String transportadoraNome) {
        this.transportadoraNome = transportadoraNome;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\configuracoes\validacao\SanitizadorEntrada.java ----- 
package br.com.cloudport.servicoautenticacao.app.configuracoes.validacao;

import java.text.Normalizer;
import java.util.regex.Pattern;

public final class SanitizadorEntrada {
    private static final Pattern PADRAO_LOGIN_PERMITIDO = Pattern.compile("^[\\p{L}\\p{N}@._-]{3,100}$");

    private SanitizadorEntrada() {
    }

    public static String sanitizarLogin(String login) {
        if (login == null) {
            throw new IllegalArgumentException("Login informado é inválido.");
        }
        String normalizado = Normalizer.normalize(login, Normalizer.Form.NFKC).trim();
        if (!PADRAO_LOGIN_PERMITIDO.matcher(normalizado).matches()) {
            throw new IllegalArgumentException("Login informado contém caracteres inválidos.");
        }
        return normalizado;
    }

    public static String sanitizarSenha(String senha) {
        if (senha == null) {
            throw new IllegalArgumentException("Senha informada é inválida.");
        }
        String normalizada = Normalizer.normalize(senha, Normalizer.Form.NFKC);
        if (normalizada.contains("<") || normalizada.contains(">")) {
            throw new IllegalArgumentException("Senha não pode conter os caracteres < ou >.");
        }
        boolean possuiControle = normalizada.chars()
                .anyMatch(caractere -> Character.isISOControl(caractere) && !Character.isWhitespace(caractere));
        if (possuiControle) {
            throw new IllegalArgumentException("Senha contém caracteres de controle não permitidos.");
        }
        return normalizada;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\privacidade\ConfiguracaoPrivacidade.java ----- 
package br.com.cloudport.servicoautenticacao.app.privacidade;

import java.util.UUID;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "configuracoes_privacidade")
public class ConfiguracaoPrivacidade {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @Column(name = "descricao", nullable = false, length = 255)
    private String descricao;

    @Column(name = "ativo", nullable = false)
    private boolean ativo;

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public boolean isAtivo() {
        return ativo;
    }

    public void setAtivo(boolean ativo) {
        this.ativo = ativo;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\privacidade\ConfiguracaoPrivacidadeRepositorio.java ----- 
package br.com.cloudport.servicoautenticacao.app.privacidade;

import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ConfiguracaoPrivacidadeRepositorio extends JpaRepository<ConfiguracaoPrivacidade, UUID> {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\privacidade\PrivacidadeConsultaServico.java ----- 
package br.com.cloudport.servicoautenticacao.app.privacidade;

import br.com.cloudport.servicoautenticacao.app.privacidade.dto.OpcaoPrivacidadeRespostaDTO;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;

@Service
public class PrivacidadeConsultaServico {

    private final ConfiguracaoPrivacidadeRepositorio configuracaoPrivacidadeRepositorio;
    private final SanitizadorConteudoPrivacidade sanitizadorConteudoPrivacidade;

    public PrivacidadeConsultaServico(
            ConfiguracaoPrivacidadeRepositorio configuracaoPrivacidadeRepositorio,
            SanitizadorConteudoPrivacidade sanitizadorConteudoPrivacidade
    ) {
        this.configuracaoPrivacidadeRepositorio = configuracaoPrivacidadeRepositorio;
        this.sanitizadorConteudoPrivacidade = sanitizadorConteudoPrivacidade;
    }

    public List<OpcaoPrivacidadeRespostaDTO> listarOpcoes() {
        return configuracaoPrivacidadeRepositorio.findAll()
                .stream()
                .map(opcao -> OpcaoPrivacidadeRespostaDTO.fromModelo(
                        opcao,
                        sanitizadorConteudoPrivacidade.sanitizarDescricao(opcao.getDescricao())
                ))
                .collect(Collectors.toList());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\privacidade\PrivacidadeController.java ----- 
package br.com.cloudport.servicoautenticacao.app.privacidade;

import br.com.cloudport.servicoautenticacao.app.privacidade.dto.OpcaoPrivacidadeRespostaDTO;
import java.util.List;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/configuracoes/privacidade")
public class PrivacidadeController {

    private final PrivacidadeConsultaServico privacidadeConsultaServico;

    public PrivacidadeController(PrivacidadeConsultaServico privacidadeConsultaServico) {
        this.privacidadeConsultaServico = privacidadeConsultaServico;
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE')")
    public ResponseEntity<List<OpcaoPrivacidadeRespostaDTO>> listarOpcoes() {
        return ResponseEntity.ok(privacidadeConsultaServico.listarOpcoes());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\privacidade\SanitizadorConteudoPrivacidade.java ----- 
package br.com.cloudport.servicoautenticacao.app.privacidade;

import org.springframework.stereotype.Component;

@Component
public class SanitizadorConteudoPrivacidade {

    public String sanitizarDescricao(String descricao) {
        if (descricao == null) {
            return "";
        }
        String semScripts = descricao.replaceAll("(?i)<script.*?>.*?</script>", "");
        String semTags = semScripts.replaceAll("<[^>]+>", "");
        return semTags
                .replace("\"", "")
                .replace("'", "")
                .replace("`", "")
                .trim();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\privacidade\dto\OpcaoPrivacidadeRespostaDTO.java ----- 
package br.com.cloudport.servicoautenticacao.app.privacidade.dto;

import br.com.cloudport.servicoautenticacao.app.privacidade.ConfiguracaoPrivacidade;
import java.util.UUID;

public class OpcaoPrivacidadeRespostaDTO {

    private UUID id;
    private String descricao;
    private boolean ativo;

    public OpcaoPrivacidadeRespostaDTO() {
    }

    public OpcaoPrivacidadeRespostaDTO(UUID id, String descricao, boolean ativo) {
        this.id = id;
        this.descricao = descricao;
        this.ativo = ativo;
    }

    public static OpcaoPrivacidadeRespostaDTO fromModelo(ConfiguracaoPrivacidade configuracao, String descricaoSanitizada) {
        return new OpcaoPrivacidadeRespostaDTO(
                configuracao.getId(),
                descricaoSanitizada,
                configuracao.isAtivo()
        );
    }

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public boolean isAtivo() {
        return ativo;
    }

    public void setAtivo(boolean ativo) {
        this.ativo = ativo;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\role\PapelControlador.java ----- 
package br.com.cloudport.servicoautenticacao.app.role;

import br.com.cloudport.servicoautenticacao.app.role.dto.PapelDTO;
import java.util.List;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/roles")
public class PapelControlador {

    private final PapelServico papelServico;

    public PapelControlador(PapelServico papelServico) {
        this.papelServico = papelServico;
    }

    @PostMapping
    public ResponseEntity<PapelDTO> criarPapel(@RequestBody PapelDTO papelDTO) {
        PapelDTO papelSalvo = papelServico.salvarPapel(papelDTO);
        return ResponseEntity.ok(papelSalvo);
    }

    @GetMapping("/{nome}")
    public ResponseEntity<PapelDTO> buscarPapel(@PathVariable String nome) {
        PapelDTO papel = papelServico.buscarPorNome(nome);
        return ResponseEntity.ok(papel);
    }

    @GetMapping
    public ResponseEntity<List<PapelDTO>> listarPapeis() {
        List<PapelDTO> papeis = papelServico.listarTodos();
        return ResponseEntity.ok(papeis);
    }

    @PutMapping("/{id}")
    public ResponseEntity<PapelDTO> atualizarPapel(@PathVariable Long id, @RequestBody PapelDTO papelDTO) {
        PapelDTO papelAtualizado = papelServico.atualizar(id, papelDTO);
        return ResponseEntity.ok(papelAtualizado);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> removerPapel(@PathVariable Long id) {
        papelServico.remover(id);
        return ResponseEntity.noContent().build();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\role\PapelServico.java ----- 
package br.com.cloudport.servicoautenticacao.app.role;

import br.com.cloudport.servicoautenticacao.app.role.dto.PapelDTO;
import br.com.cloudport.servicoautenticacao.exception.PapelNaoEncontradoException;
import br.com.cloudport.servicoautenticacao.model.Papel;
import br.com.cloudport.servicoautenticacao.repositories.PapelRepositorio;
import br.com.cloudport.servicoautenticacao.repositories.UsuarioPapelRepositorio;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class PapelServico {

    private final PapelRepositorio papelRepositorio;
    private final UsuarioPapelRepositorio usuarioPapelRepositorio;

    public PapelServico(PapelRepositorio papelRepositorio, UsuarioPapelRepositorio usuarioPapelRepositorio) {
        this.papelRepositorio = papelRepositorio;
        this.usuarioPapelRepositorio = usuarioPapelRepositorio;
    }

    @Transactional
    public PapelDTO salvarPapel(PapelDTO papelDTO) {
        if(papelDTO.getNome() == null || papelDTO.getNome().trim().isEmpty()){
            throw new IllegalArgumentException("Nome do papel não pode ser vazio");
        }

        papelRepositorio.findByNome(papelDTO.getNome()).ifPresent(papel -> {
            throw new IllegalArgumentException("Papel com o nome " + papelDTO.getNome() + " já existe");
        });

        Papel papel = new Papel(papelDTO.getNome());
        Papel papelSalvo = papelRepositorio.save(papel);
        return new PapelDTO(papelSalvo.getId(), papelSalvo.getNome());
    }

    @Transactional
    public PapelDTO buscarPorNome(String nome) {
        Papel papel = papelRepositorio.findByNome(nome)
                .orElseThrow(() -> new PapelNaoEncontradoException("Papel " + nome + " não encontrado"));
        return new PapelDTO(papel.getId(), papel.getNome());
    }

    public List<PapelDTO> listarTodos() {
        List<Papel> papeis = papelRepositorio.findAll();
        return papeis.stream()
                .map(papel -> new PapelDTO(papel.getId(), papel.getNome()))
                .sorted(Comparator.comparing(PapelDTO::getId))
                .collect(Collectors.toList());
    }

    @Transactional
    public PapelDTO atualizar(Long id, PapelDTO papelDTO) {
        Papel papel = papelRepositorio.findById(id)
                .orElseThrow(() -> new PapelNaoEncontradoException("Papel com id " + id + " não encontrado"));
        papel.setNome(papelDTO.getNome());
        Papel papelAtualizado = papelRepositorio.save(papel);
        return new PapelDTO(papelAtualizado.getId(), papelAtualizado.getNome());
    }

    @Transactional
    public void remover(Long id) {
        if (usuarioPapelRepositorio.existsByPapelId(id)) {
            throw new IllegalStateException("Papel com id " + id + " não pode ser removido porque está em uso.");
        }

        if (!papelRepositorio.existsById(id)) {
            throw new PapelNaoEncontradoException("Papel com id " + id + " não encontrado.");
        }

        papelRepositorio.deleteById(id);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\role\dto\PapelDTO.java ----- 
package br.com.cloudport.servicoautenticacao.app.role.dto;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class PapelDTO {
    private Long id;
    private String nome;
    private String status;

    public PapelDTO(Long id, String nome) {
        this.id = id;
        this.nome = nome;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\usuarioslista\UsuarioRepositorio.java ----- 
package br.com.cloudport.servicoautenticacao.app.usuarioslista;

import br.com.cloudport.servicoautenticacao.model.Usuario;
import java.util.Optional;
import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UsuarioRepositorio extends JpaRepository<Usuario, UUID> {
    Optional<Usuario> findByLogin(String login);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\usuarioslista\UsuariosListaController.java ----- 
package br.com.cloudport.servicoautenticacao.app.usuarioslista;

import br.com.cloudport.servicoautenticacao.app.usuarioslista.dto.UsuarioResumoDTO;
import java.util.List;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/usuarios")
public class UsuariosListaController {

    private final UsuariosListaServico usuariosListaServico;

    public UsuariosListaController(UsuariosListaServico usuariosListaServico) {
        this.usuariosListaServico = usuariosListaServico;
    }

    @GetMapping
    @PreAuthorize("hasRole('ADMIN_PORTO')")
    public ResponseEntity<List<UsuarioResumoDTO>> listarUsuarios() {
        return ResponseEntity.ok(usuariosListaServico.listarUsuariosResumo());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\usuarioslista\UsuariosListaServico.java ----- 
package br.com.cloudport.servicoautenticacao.app.usuarioslista;

import br.com.cloudport.servicoautenticacao.app.usuarioslista.dto.UsuarioResumoDTO;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;

@Service
public class UsuariosListaServico {

    private final UsuarioRepositorio usuarioRepositorio;

    public UsuariosListaServico(UsuarioRepositorio usuarioRepositorio) {
        this.usuarioRepositorio = usuarioRepositorio;
    }

    public List<UsuarioResumoDTO> listarUsuariosResumo() {
        return usuarioRepositorio.findAll()
                .stream()
                .map(UsuarioResumoDTO::fromUsuario)
                .sorted((usuarioA, usuarioB) -> usuarioA.getNome().compareToIgnoreCase(usuarioB.getNome()))
                .collect(Collectors.toList());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\app\usuarioslista\dto\UsuarioResumoDTO.java ----- 
package br.com.cloudport.servicoautenticacao.app.usuarioslista.dto;

import br.com.cloudport.servicoautenticacao.model.Usuario;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.UUID;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class UsuarioResumoDTO {
    private final UUID id;
    private final String nome;
    private final String email;
    private final String status;

    public UsuarioResumoDTO(UUID id, String nome, String email, String status) {
        this.id = id;
        this.nome = nome;
        this.email = email;
        this.status = status;
    }

    public UUID getId() {
        return id;
    }

    public String getNome() {
        return nome;
    }

    public String getEmail() {
        return email;
    }

    public String getStatus() {
        return status;
    }

    public static UsuarioResumoDTO fromUsuario(Usuario usuario) {
        String nome = usuario.getNome() != null && !usuario.getNome().isBlank() ? usuario.getNome() : usuario.getLogin();
        String email = usuario.getLogin();
        String status = usuario.isEnabled() ? "Ativo" : "Inativo";
        return new UsuarioResumoDTO(usuario.getId(), nome, email, status);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\config\Configuracao.java ----- 
package br.com.cloudport.servicoautenticacao.config;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class Configuracao {

  @Bean
    public ModelMapper obterModelMapper() {
        return new ModelMapper();
    }
} 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\config\SecurityConfigurations.java ----- 

package br.com.cloudport.servicoautenticacao.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfigurations {

    @Autowired
    SecurityFilter securityFilter;

    @Value("${app.security.cors.allowed-origins:http://localhost:3000}")
    private String allowedCorsOrigins;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .cors().configurationSource(corsConfigurationSource()).and()
                .csrf().disable()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
                .authorizeRequests()
                    .antMatchers("/auth/**").permitAll()
                    .antMatchers(HttpMethod.POST, "/auth").permitAll()
                    .antMatchers(HttpMethod.POST, "/auth/login").permitAll()
                    .antMatchers(HttpMethod.POST, "/auth/register").permitAll()
                    .antMatchers(HttpMethod.POST, "/product").hasRole("ADMIN_PORTO")
                    .anyRequest().authenticated()
                .and()
                .addFilterBefore(securityFilter, UsernamePasswordAuthenticationFilter.class);

        return httpSecurity.build();
    }

    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        List<String> origins = Arrays.stream(allowedCorsOrigins.split(","))
                .map(String::trim)
                .filter(origin -> !origin.isEmpty())
                .collect(Collectors.toList());
        // SECURITY: restringe origens, métodos e cabeçalhos expostos via CORS
        configuration.setAllowedOrigins(origins);
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "Accept"));
        configuration.setExposedHeaders(List.of("Authorization"));
        configuration.setMaxAge(Duration.ofHours(1));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\config\SecurityFilter.java ----- 
package br.com.cloudport.servicoautenticacao.config;

import br.com.cloudport.servicoautenticacao.app.usuarioslista.UsuarioRepositorio;
import br.com.cloudport.servicoautenticacao.model.Usuario;
import java.io.IOException;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

@Component
public class SecurityFilter extends OncePerRequestFilter {
    private final TokenService tokenService;
    private final UsuarioRepositorio usuarioRepositorio;

    public SecurityFilter(TokenService tokenService, UsuarioRepositorio usuarioRepositorio) {
        this.tokenService = tokenService;
        this.usuarioRepositorio = usuarioRepositorio;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        var token = this.recoverToken(request);
        if(!StringUtils.hasText(token)){
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Token ausente");
            return;
        }

        var login = tokenService.validateToken(token);
        if (login.isEmpty()) {
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Token inválido");
            return;
        }

        var loginValue = login.get();
        Usuario usuario = usuarioRepositorio.findByLogin(loginValue)
                .orElseThrow(() -> new UsernameNotFoundException("Usuário não encontrado para o login: " + loginValue));

        var authentication = new UsernamePasswordAuthenticationToken(usuario, null, usuario.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authentication);

        filterChain.doFilter(request, response);
    }

    private String recoverToken(HttpServletRequest request){
        var authHeader = request.getHeader("Authorization");
        if(!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
            return null;
        }
        var token = authHeader.substring(7).trim();
        return StringUtils.hasText(token) ? token : null;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\config\SwaggerConfig.java ----- 


package br.com.cloudport.servicoautenticacao.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class SwaggerConfig {                                    
    @Bean
    public Docket api() { 
        return new Docket(DocumentationType.SWAGGER_2)  
          .select()                                  
          .apis(RequestHandlerSelectors.any())              
          .paths(PathSelectors.any())                          
          .build();                                           
    }
}


 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\config\TokenService.java ----- 
package br.com.cloudport.servicoautenticacao.config;

import br.com.cloudport.servicoautenticacao.model.Papel;
import br.com.cloudport.servicoautenticacao.model.Usuario;
import br.com.cloudport.servicoautenticacao.model.UsuarioPapel;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.crypto.SecretKey;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

@Service
public class TokenService {
    @Value("${api.security.token.secret}")
    private String secret;

    public String generateToken(Usuario usuario){
        try{
            SecretKey algorithm = signingKey();
            Set<String> papeis = Optional.ofNullable(usuario.getPapeis()).orElseGet(Collections::emptySet).stream()
                    .map(UsuarioPapel::getPapel)
                    .map(Papel::getNome)
                    .filter(StringUtils::hasText)
                    .map(nomePapel -> nomePapel.startsWith("ROLE_") ? nomePapel : "ROLE_" + nomePapel.toUpperCase())
                    .collect(Collectors.toSet());

            String perfil = papeis.stream().findFirst().orElse(null);

            var claims = new HashMap<String, Object>();
            if (usuario.getId() != null) {
                claims.put("userId", usuario.getId().toString());
            }
            if (StringUtils.hasText(usuario.getNome())) {
                claims.put("nome", usuario.getNome());
            }
            if (StringUtils.hasText(perfil)) {
                claims.put("perfil", perfil);
            }
            if (!CollectionUtils.isEmpty(papeis)) {
                claims.put("roles", papeis);
            }
            if (StringUtils.hasText(usuario.getTransportadoraDocumento())) {
                claims.put("transportadoraDocumento", usuario.getTransportadoraDocumento());
            }
            if (StringUtils.hasText(usuario.getTransportadoraNome())) {
                claims.put("transportadoraNome", usuario.getTransportadoraNome());
            }

            return Jwts.builder()
                    .setIssuer("auth-api")
                    .setSubject(usuario.getLogin())
                    .setExpiration(Date.from(genExpirationDate()))
                    .addClaims(claims)
                    .signWith(algorithm, SignatureAlgorithm.HS256)
                    .compact();
        } catch (JwtException exception) {
            throw new RuntimeException("Error while generating token", exception);
        }
    }

    public Optional<String> validateToken(String token){
        try {
            SecretKey algorithm = signingKey();
            Claims claims = Jwts.parserBuilder()
                    .requireIssuer("auth-api")
                    .setSigningKey(algorithm)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
            return Optional.ofNullable(claims.getSubject());
        } catch (JwtException | IllegalArgumentException exception){
            return Optional.empty();
        }
    }

    private Instant genExpirationDate(){
        return LocalDateTime.now().plusHours(2).toInstant(ZoneOffset.of("-03:00"));
    }

    private SecretKey signingKey() {
        if (!StringUtils.hasText(secret)) {
            throw new IllegalStateException("Token secret must be configured");
        }
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            throw new IllegalStateException("Token secret must be at least 256 bits (32 bytes)");
        }
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\config\UserInitializer.java ----- 
package br.com.cloudport.servicoautenticacao.config;

import br.com.cloudport.servicoautenticacao.app.usuarioslista.UsuarioRepositorio;
import br.com.cloudport.servicoautenticacao.model.Papel;
import br.com.cloudport.servicoautenticacao.model.Usuario;
import br.com.cloudport.servicoautenticacao.model.UsuarioPapel;
import br.com.cloudport.servicoautenticacao.repositories.PapelRepositorio;
import java.util.HashSet;
import java.util.Set;
import org.springframework.boot.CommandLineRunner;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;

@Component
public class UserInitializer implements CommandLineRunner {

    private final UsuarioRepositorio usuarioRepositorio;
    private final PapelRepositorio papelRepositorio;

    public UserInitializer(UsuarioRepositorio usuarioRepositorio, PapelRepositorio papelRepositorio) {
        this.usuarioRepositorio = usuarioRepositorio;
        this.papelRepositorio = papelRepositorio;
    }

    @Override
    public void run(String... args) {
        String loginAdministrador = "gitpod";
        String senhaAdministrador = new BCryptPasswordEncoder().encode("gitpod");

        Papel papelAdministrador = garantirPapel("ROLE_ADMIN_PORTO");
        garantirPapel("ROLE_PLANEJADOR");
        garantirPapel("ROLE_OPERADOR_GATE");
        garantirPapel("ROLE_TRANSPORTADORA");

        if (usuarioRepositorio.findByLogin(loginAdministrador).isEmpty()) {
            Usuario administrador = new Usuario(loginAdministrador, senhaAdministrador, "Administrador CloudPort",
                    null, null, new HashSet<>());

            Set<UsuarioPapel> papeis = administrador.getPapeis();
            UsuarioPapel papelUsuarioAdministrador = new UsuarioPapel(administrador, papelAdministrador);
            papeis.add(papelUsuarioAdministrador);

            usuarioRepositorio.save(administrador);
        }
    }

    private Papel garantirPapel(String identificadorPapel) {
        return papelRepositorio.findByNome(identificadorPapel)
                .orElseGet(() -> {
                    Papel papel = new Papel(identificadorPapel);
                    return papelRepositorio.save(papel);
                });
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\controllers\AuthenticationController.java ----- 
package br.com.cloudport.servicoautenticacao.controllers;

import br.com.cloudport.servicoautenticacao.app.configuracoes.dto.AuthenticationDTO;
import br.com.cloudport.servicoautenticacao.app.configuracoes.dto.LoginResponseDTO;
import br.com.cloudport.servicoautenticacao.app.configuracoes.dto.RegisterDTO;
import br.com.cloudport.servicoautenticacao.app.configuracoes.validacao.SanitizadorEntrada;
import br.com.cloudport.servicoautenticacao.app.administracao.dto.UsuarioInfoDTO;
import br.com.cloudport.servicoautenticacao.app.usuarioslista.UsuarioRepositorio;
import br.com.cloudport.servicoautenticacao.config.TokenService;
import br.com.cloudport.servicoautenticacao.model.Papel;
import br.com.cloudport.servicoautenticacao.model.Usuario;
import br.com.cloudport.servicoautenticacao.model.UsuarioPapel;
import br.com.cloudport.servicoautenticacao.repositories.PapelRepositorio;
import br.com.cloudport.servicoautenticacao.repositories.UsuarioPapelRepositorio;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.stream.Collectors;
import javax.validation.Valid;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

@RestController
@RequestMapping("/auth")
public class AuthenticationController {
    private final AuthenticationManager authenticationManager;
    private final UsuarioRepositorio usuarioRepositorio;
    private final PapelRepositorio papelRepositorio;
    private final TokenService tokenService;
    private final UsuarioPapelRepositorio usuarioPapelRepositorio;

    @Value("${api.security.self-registration.allowed-roles:USER}")
    private String papeisPermitidosAutoCadastro;

    public AuthenticationController(AuthenticationManager authenticationManager,
                                     UsuarioRepositorio usuarioRepositorio,
                                     PapelRepositorio papelRepositorio,
                                     TokenService tokenService,
                                     UsuarioPapelRepositorio usuarioPapelRepositorio) {
        this.authenticationManager = authenticationManager;
        this.usuarioRepositorio = usuarioRepositorio;
        this.papelRepositorio = papelRepositorio;
        this.tokenService = tokenService;
        this.usuarioPapelRepositorio = usuarioPapelRepositorio;
    }

    @PostMapping("/login")
    public ResponseEntity<LoginResponseDTO> login(@RequestBody @Valid AuthenticationDTO dados){
        String loginSanitizado;
        String senhaSanitizada;
        try {
            loginSanitizado = SanitizadorEntrada.sanitizarLogin(dados.getLogin());
            senhaSanitizada = SanitizadorEntrada.sanitizarSenha(dados.getSenha());
        } catch (IllegalArgumentException ex) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, ex.getMessage());
        }

        var usernamePassword = new UsernamePasswordAuthenticationToken(loginSanitizado, senhaSanitizada);
        var autenticacao = this.authenticationManager.authenticate(usernamePassword);

        Usuario usuario = (Usuario) autenticacao.getPrincipal();
        var token = tokenService.generateToken(usuario);

        Set<String> papeis = java.util.Optional.ofNullable(usuario.getPapeis()).orElse(java.util.Collections.emptySet()).stream()
                                 .map(UsuarioPapel::getPapel)
                                 .map(Papel::getNome)
                                 .filter(StringUtils::hasText)
                                 .map(nomePapel -> nomePapel.startsWith("ROLE_") ? nomePapel : "ROLE_" + nomePapel.toUpperCase())
                                 .collect(Collectors.toCollection(LinkedHashSet::new));

        String perfil = papeis.stream().findFirst().orElse("");
        String nome = StringUtils.hasText(usuario.getNome()) ? usuario.getNome() : usuario.getLogin();

        return ResponseEntity.ok(new LoginResponseDTO(
                usuario.getId(),
                usuario.getLogin(),
                nome,
                perfil,
                token,
                papeis,
                usuario.getTransportadoraDocumento(),
                usuario.getTransportadoraNome()
        ));
    }

    @PostMapping("/register")
    public ResponseEntity<Void> registrar(@RequestBody @Valid RegisterDTO dados){
        String loginSanitizado;
        String senhaSanitizada;
        try {
            loginSanitizado = SanitizadorEntrada.sanitizarLogin(dados.getLogin());
            senhaSanitizada = SanitizadorEntrada.sanitizarSenha(dados.getPassword());
        } catch (IllegalArgumentException ex) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, ex.getMessage());
        }

        if (this.usuarioRepositorio.findByLogin(loginSanitizado).isPresent()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Login informado já está em uso.");
        }

        String senhaCriptografada = new BCryptPasswordEncoder().encode(senhaSanitizada);

        Set<String> papeisPermitidosNormalizados = Arrays.stream(papeisPermitidosAutoCadastro.split(","))
                .map(String::trim)
                .filter(papel -> !papel.isEmpty())
                .collect(Collectors.collectingAndThen(Collectors.toSet(), conjunto -> conjunto.isEmpty() ? Collections.singleton("USER") : conjunto));

        Set<String> papeisSolicitados = dados.getRoles().stream()
                .map(String::trim)
                .filter(papel -> !papel.isEmpty())
                .collect(Collectors.toSet());

        if (!papeisPermitidosNormalizados.containsAll(papeisSolicitados)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Papéis informados não são permitidos para auto-registro.");
        }

        Set<UsuarioPapel> papeis = papeisSolicitados.stream()
                              .map(nomePapel -> {
                                  Papel papel = papelRepositorio.findByNome(nomePapel)
                                          .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Papel '" + nomePapel + "' não encontrado."));
                                  return new UsuarioPapel(null, papel);
                              })
                              .collect(Collectors.toSet());

        if (papeis.isEmpty()) {
            papeis = papeisPermitidosNormalizados.stream()
                    .map(nomePapel -> papelRepositorio.findByNome(nomePapel)
                            .map(papel -> new UsuarioPapel(null, papel))
                            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Papel '" + nomePapel + "' não encontrado.")))
                    .collect(Collectors.toSet());
        }

        Usuario novoUsuario = new Usuario(loginSanitizado, senhaCriptografada, dados.getNome(),
                dados.getTransportadoraDocumento(), dados.getTransportadoraNome(), papeis);

        papeis.forEach(papel -> papel.setUsuario(novoUsuario));

        this.usuarioRepositorio.save(novoUsuario);
        this.usuarioPapelRepositorio.saveAll(papeis);

        return ResponseEntity.ok().build();
    }

    @GetMapping("/usuarios/{login}")
    @PreAuthorize("hasRole('ADMIN_PORTO')")
    public ResponseEntity<UsuarioInfoDTO> buscarUsuario(@PathVariable String login) {
        Usuario usuario = usuarioRepositorio.findByLogin(login)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Usuário não encontrado"));
        return ResponseEntity.ok(UsuarioInfoDTO.fromUsuario(usuario));
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\exception\GlobalExceptionHandler.java ----- 
package br.com.cloudport.servicoautenticacao.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.LinkedHashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Object> handleIllegalStateException(IllegalStateException ex) {
        logger.warn("IllegalStateException encontrada no GlobalExceptionHandler: ", ex);
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.CONFLICT);
    }

    @ExceptionHandler(PapelNaoEncontradoException.class)
    public ResponseEntity<Object> handlePapelNaoEncontradoException(PapelNaoEncontradoException ex) {
        logger.warn("PapelNaoEncontradoException encontrada no GlobalExceptionHandler: ", ex);
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Object> handleIllegalArgumentException(IllegalArgumentException ex) {
        logger.warn("IllegalArgumentException encontrada no GlobalExceptionHandler: ", ex);
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Object> handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) {
        logger.warn("Erro de validação encontrado no GlobalExceptionHandler: ", ex);

        Map<String, Object> body = new LinkedHashMap<>();
        body.put("mensagem", "Erro de validação dos dados enviados.");

        Map<String, String> fieldErrors = new LinkedHashMap<>();
        for (FieldError error : ex.getBindingResult().getFieldErrors()) {
            fieldErrors.put(error.getField(), error.getDefaultMessage());
        }

        body.put("erros", fieldErrors);

        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<Object> handleDataIntegrityViolationException(DataIntegrityViolationException ex) {
        logger.warn("DataIntegrityViolationException encontrada no GlobalExceptionHandler: ", ex);
        return new ResponseEntity<>("Erro de integridade dos dados", HttpStatus.CONFLICT);
    }

    // outros manipuladores de exceções...
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\exception\PapelNaoEncontradoException.java ----- 
package br.com.cloudport.servicoautenticacao.exception;

public class PapelNaoEncontradoException extends RuntimeException {

    public PapelNaoEncontradoException(String message) {
        super(message);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\model\Papel.java ----- 
package br.com.cloudport.servicoautenticacao.model;

import java.util.HashSet;
import java.util.Set;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "roles")
@Getter
@Setter
@NoArgsConstructor
public class Papel {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name")
    private String nome;

    @OneToMany(mappedBy = "papel")
    private Set<UsuarioPapel> usuarioPapeis = new HashSet<>();

    public Papel(String nome) {
        this.nome = nome;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\model\StatusUsuarioEnum.java ----- 
package br.com.cloudport.servicoautenticacao.model;

public enum StatusUsuarioEnum {
    ATIVO,
    INATIVO
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\model\TipoPapelUsuarioEnum.java ----- 
package br.com.cloudport.servicoautenticacao.model;

public enum TipoPapelUsuarioEnum {
    ADMINISTRADOR_PORTO("ROLE_ADMIN_PORTO"),
    PLANEJADOR("ROLE_PLANEJADOR"),
    OPERADOR_GATE("ROLE_OPERADOR_GATE"),
    TRANSPORTADORA("ROLE_TRANSPORTADORA");

    private final String identificador;

    TipoPapelUsuarioEnum(String identificador) {
        this.identificador = identificador;
    }

    public String getIdentificador() {
        return identificador;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\model\Usuario.java ----- 
package br.com.cloudport.servicoautenticacao.model;

import java.util.Collection;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

@Table(name = "users")
@Entity(name = "users")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
public class Usuario implements UserDetails {

    @Id
    private UUID id;

    @Column
    private String login;

    @Column(name = "password")
    private String senha;

    @Column(name = "nome")
    private String nome;

    @Column(name = "transportadora_documento")
    private String transportadoraDocumento;

    @Column(name = "transportadora_nome")
    private String transportadoraNome;

    @OneToMany(mappedBy = "usuario", fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    private Set<UsuarioPapel> papeis = new HashSet<>();

    public Usuario(String login, String senha, Set<UsuarioPapel> papeis) {
        this.id = UUID.randomUUID();
        this.login = login;
        this.senha = senha;
        this.papeis = papeis != null ? papeis : new HashSet<>();
    }

    public Usuario(String login, String senha, String nome, String transportadoraDocumento,
                    String transportadoraNome, Set<UsuarioPapel> papeis) {
        this(login, senha, papeis);
        this.nome = nome;
        this.transportadoraDocumento = transportadoraDocumento;
        this.transportadoraNome = transportadoraNome;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return this.papeis.stream()
                .map(UsuarioPapel::getPapel)
                .filter(Objects::nonNull)
                .map(Papel::getNome)
                .filter(Objects::nonNull)
                .map(nomePapel -> nomePapel.startsWith("ROLE_") ? nomePapel : "ROLE_" + nomePapel.toUpperCase())
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }

    @Override
    public String getUsername() {
        return login;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public String getPassword() {
        return senha;
    }

    public void setSenha(String senha) {
        this.senha = senha;
    }

    public Set<UsuarioPapel> getPapeis() {
        return papeis;
    }

    public void setPapeis(Set<UsuarioPapel> papeis) {
        this.papeis = papeis;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\model\UsuarioPapel.java ----- 
package br.com.cloudport.servicoautenticacao.model;

import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "user_roles")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UsuarioPapel {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private Usuario usuario;

    @ManyToOne
    @JoinColumn(name = "role_id")
    private Papel papel;

    @Enumerated(EnumType.STRING)
    private StatusUsuarioEnum status;

    public UsuarioPapel(Papel papel) {
        this.papel = papel;
        this.usuario = null;
    }

    public UsuarioPapel(Usuario usuario, Papel papel) {
        this.usuario = usuario;
        this.papel = papel;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\repositories\PapelRepositorio.java ----- 
package br.com.cloudport.servicoautenticacao.repositories;

import br.com.cloudport.servicoautenticacao.model.Papel;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PapelRepositorio extends JpaRepository<Papel, Long> {
    Optional<Papel> findByNome(String nome);
    List<Papel> findAllByOrderByIdAsc();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\repositories\UsuarioPapelRepositorio.java ----- 
package br.com.cloudport.servicoautenticacao.repositories;

import br.com.cloudport.servicoautenticacao.model.UsuarioPapel;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UsuarioPapelRepositorio extends JpaRepository<UsuarioPapel, Long> {
    boolean existsByPapelId(Long papelId);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\java\br\com\cloudport\servicoautenticacao\services\AuthorizationService.java ----- 
package br.com.cloudport.servicoautenticacao.services;

import br.com.cloudport.servicoautenticacao.app.usuarioslista.UsuarioRepositorio;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class AuthorizationService implements UserDetailsService {

    private final UsuarioRepositorio usuarioRepositorio;

    public AuthorizationService(UsuarioRepositorio usuarioRepositorio) {
        this.usuarioRepositorio = usuarioRepositorio;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return usuarioRepositorio.findByLogin(username)
                .orElseThrow(() -> new UsernameNotFoundException("Usuário não encontrado com o login: " + username));
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\resources\application.properties ----- 
# RabbitMQ Configuration
spring.rabbitmq.host=${SPRING_RABBITMQ_HOST:localhost}
spring.rabbitmq.port=${SPRING_RABBITMQ_PORT:5672}
spring.rabbitmq.username=${SPRING_RABBITMQ_USERNAME}
spring.rabbitmq.password=${SPRING_RABBITMQ_PASSWORD}

# PostgreSQL Configuration
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/servico_autenticacao}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# Hibernate Configuration
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto = update

# Spring Security Configuration
spring.security.user.name=${SPRING_SECURITY_USER_NAME}
spring.security.user.password=${SPRING_SECURITY_USER_PASSWORD}
jwt.secret=${JWT_SECRET}

api.security.token.secret=${JWT_SECRET}
api.security.self-registration.allowed-roles=${API_SECURITY_SELF_REGISTRATION_ALLOWED_ROLES:USER}
app.security.cors.allowed-origins=${APP_SECURITY_CORS_ALLOWED_ORIGINS:http://localhost:3000}

spring.jpa.open-in-view=false
spring.mvc.cors.allowed-origins=${SPRING_MVC_CORS_ALLOWED_ORIGINS:http://localhost:3000}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\resources\db\migration\V1__create-product-table.sql ----- 
CREATE TABLE product (
    id TEXT PRIMARY KEY UNIQUE NOT NULL,
    name TEXT NOT NULL,
    price INTEGER NOT NULL
); 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\resources\db\migration\V2__create-table-users.sql ----- 
CREATE TABLE users (
    id TEXT PRIMARY KEY UNIQUE NOT NULL,
    login TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    role TEXT NOT NULL
); 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\resources\db\migration\V3__create-roles-user_roles-tables.sql ----- 
CREATE TABLE IF NOT EXISTS roles (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS user_roles (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL,
    role_id BIGINT NOT NULL,
    status_enum VARCHAR(255),
    CONSTRAINT fk_user_roles_user FOREIGN KEY (user_id) REFERENCES users (id),
    CONSTRAINT fk_user_roles_role FOREIGN KEY (role_id) REFERENCES roles (id)
);

ALTER TABLE users DROP COLUMN IF EXISTS role;
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\main\resources\db\migration\V4__create_tabela_configuracoes_privacidade.sql ----- 
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE IF NOT EXISTS configuracoes_privacidade (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    descricao VARCHAR(255) NOT NULL,
    ativo BOOLEAN NOT NULL DEFAULT FALSE,
    CONSTRAINT uk_configuracoes_privacidade_descricao UNIQUE (descricao)
);

INSERT INTO configuracoes_privacidade (descricao, ativo)
VALUES
    ('Permitir compartilhamento de dados com parceiros', FALSE),
    ('Mostrar minha atividade para outros usuários', FALSE),
    ('Receber relatórios de auditoria mensais', TRUE)
ON CONFLICT (descricao) DO NOTHING;
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\java\br\com\cloudport\servicoautenticacao\ServicoAutenticacaoApplicationTests.java ----- 
package br.com.cloudport.servicoautenticacao;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import static org.junit.jupiter.api.Assertions.*;

import br.com.cloudport.servicoautenticacao.config.TokenService;
import br.com.cloudport.servicoautenticacao.model.User;

import java.util.HashSet;

@SpringBootTest
class ServicoAutenticacaoApplicationTests {

    @Autowired
    private TokenService tokenService;

    @Test
    void contextLoads() {
    }

    @Test
    void generateAndValidateToken() {
        User user = new User("test", "pass", new HashSet<>());
        String token = tokenService.generateToken(user);
        assertNotNull(token);
        assertEquals(user.getLogin(), tokenService.validateToken(token));
    }

    @Test
    void invalidTokenReturnsEmpty() {
        String invalidToken = "invalid";
        assertEquals("", tokenService.validateToken(invalidToken));
    }

}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\java\br\com\cloudport\servicoautenticacao\app\privacidade\PrivacidadeConsultaServicoTest.java ----- 
package br.com.cloudport.servicoautenticacao.app.privacidade;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;

import br.com.cloudport.servicoautenticacao.app.privacidade.dto.OpcaoPrivacidadeRespostaDTO;
import java.util.List;
import java.util.UUID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

class PrivacidadeConsultaServicoTest {

    @Mock
    private ConfiguracaoPrivacidadeRepositorio configuracaoPrivacidadeRepositorio;

    @Mock
    private SanitizadorConteudoPrivacidade sanitizadorConteudoPrivacidade;

    @InjectMocks
    private PrivacidadeConsultaServico privacidadeConsultaServico;

    @BeforeEach
    void configurar() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void deveSanitizarDescricoesAntesDeRetornarOpcoes() {
        ConfiguracaoPrivacidade configuracao = new ConfiguracaoPrivacidade();
        configuracao.setId(UUID.randomUUID());
        configuracao.setDescricao("<script>alert('xss')</script><b>Texto Seguro</b>");
        configuracao.setAtivo(true);

        when(configuracaoPrivacidadeRepositorio.findAll()).thenReturn(List.of(configuracao));
        when(sanitizadorConteudoPrivacidade.sanitizarDescricao(configuracao.getDescricao())).thenReturn("Texto Seguro");

        List<OpcaoPrivacidadeRespostaDTO> resposta = privacidadeConsultaServico.listarOpcoes();

        assertThat(resposta)
                .hasSize(1)
                .allSatisfy(opcao -> {
                    assertThat(opcao.getDescricao()).isEqualTo("Texto Seguro");
                    assertThat(opcao.isAtivo()).isTrue();
                });
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\java\br\com\cloudport\servicoautenticacao\app\role\PapelServicoTest.java ----- 
package br.com.cloudport.servicoautenticacao.app.role;

import br.com.cloudport.servicoautenticacao.app.role.dto.PapelDTO;
import br.com.cloudport.servicoautenticacao.model.Papel;
import br.com.cloudport.servicoautenticacao.repositories.PapelRepositorio;
import br.com.cloudport.servicoautenticacao.repositories.UsuarioPapelRepositorio;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class PapelServicoTest {

    @Mock
    private PapelRepositorio papelRepositorio;

    @Mock
    private UsuarioPapelRepositorio usuarioPapelRepositorio;

    @InjectMocks
    private PapelServico papelServico;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void salvarPapel_sucesso() {
        PapelDTO dto = new PapelDTO();
        dto.setNome("ADMIN");

        when(papelRepositorio.findByNome("ADMIN")).thenReturn(Optional.empty());
        when(papelRepositorio.save(any(Papel.class))).thenAnswer(invocation -> {
            Papel papel = invocation.getArgument(0);
            papel.setId(1L);
            return papel;
        });

        PapelDTO resultado = papelServico.salvarPapel(dto);

        assertNotNull(resultado.getId());
        assertEquals("ADMIN", resultado.getNome());
        verify(papelRepositorio).save(any(Papel.class));
    }

    @Test
    void salvarPapel_nomeDuplicado_lancaExcecao() {
        PapelDTO dto = new PapelDTO();
        dto.setNome("ADMIN");

        when(papelRepositorio.findByNome("ADMIN")).thenReturn(Optional.of(new Papel("ADMIN")));

        assertThrows(IllegalArgumentException.class, () -> papelServico.salvarPapel(dto));
        verify(papelRepositorio, never()).save(any());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\java\br\com\cloudport\servicoautenticacao\config\SecurityFilterTest.java ----- 
package br.com.cloudport.servicoautenticacao.config;

import br.com.cloudport.servicoautenticacao.app.usuarioslista.UsuarioRepositorio;
import java.io.IOException;
import java.util.Optional;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class SecurityFilterTest {

    private SecurityFilter securityFilter;
    private TokenService tokenService;
    private UsuarioRepositorio usuarioRepositorio;
    private FilterChain filterChain;

    @BeforeEach
    void setUp() {
        tokenService = mock(TokenService.class);
        usuarioRepositorio = mock(UsuarioRepositorio.class);
        securityFilter = new SecurityFilter(tokenService, usuarioRepositorio);
        filterChain = mock(FilterChain.class);
    }

    @Test
    void deveRetornar401QuandoTokenInvalidoSemConsultarRepositorio() throws ServletException, IOException {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("Authorization", "Bearer invalid");
        MockHttpServletResponse response = new MockHttpServletResponse();

        when(tokenService.validateToken("invalid")).thenReturn(Optional.empty());

        securityFilter.doFilterInternal(request, response, filterChain);

        assertEquals(401, response.getStatus());
        verify(tokenService).validateToken("invalid");
        verifyNoInteractions(usuarioRepositorio);
        verify(filterChain, never()).doFilter(any(), any());
    }

    @Test
    void deveRetornar401QuandoTokenAusenteSemConsultarTokenService() throws ServletException, IOException {
        MockHttpServletRequest request = new MockHttpServletRequest();
        MockHttpServletResponse response = new MockHttpServletResponse();

        securityFilter.doFilterInternal(request, response, filterChain);

        assertEquals(401, response.getStatus());
        verifyNoInteractions(tokenService);
        verifyNoInteractions(usuarioRepositorio);
        verify(filterChain, never()).doFilter(any(), any());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\java\br\com\cloudport\servicoautenticacao\config\UserInitializerIntegrationTest.java ----- 
package br.com.cloudport.servicoautenticacao.config;

import br.com.cloudport.servicoautenticacao.app.usuarioslista.UsuarioRepositorio;
import br.com.cloudport.servicoautenticacao.model.Usuario;
import br.com.cloudport.servicoautenticacao.model.UsuarioPapel;
import br.com.cloudport.servicoautenticacao.repositories.UsuarioPapelRepositorio;
import java.util.List;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
class UserInitializerIntegrationTest {

    @Autowired
    private UsuarioRepositorio usuarioRepositorio;

    @Autowired
    private UsuarioPapelRepositorio usuarioPapelRepositorio;

    @Test
    void usuarioAdministradorInicialPossuiPapeisPersistidos() {
        Usuario administrador = usuarioRepositorio.findByLogin("gitpod").orElse(null);
        assertNotNull(administrador, "Usuário administrador inicial não foi criado");

        assertNotNull(administrador.getPapeis(), "Coleção de papéis não deve ser nula");
        assertFalse(administrador.getPapeis().isEmpty(), "Usuário administrador deve possuir ao menos um papel associado");
        administrador.getPapeis().forEach(usuarioPapel -> {
            assertNotNull(usuarioPapel.getUsuario(), "Vínculo deve manter referência ao usuário");
            assertEquals(administrador.getId(), usuarioPapel.getUsuario().getId(), "Vínculo deve estar ligado ao administrador");
        });

        List<UsuarioPapel> papeisPersistidos = usuarioPapelRepositorio.findAll();
        assertFalse(papeisPersistidos.isEmpty(), "Deve haver registros de vínculo usuário-papel persistidos");
        papeisPersistidos.forEach(usuarioPapel -> {
            assertNotNull(usuarioPapel.getId(), "Vínculo deve possuir identificador persistido");
            assertNotNull(usuarioPapel.getUsuario(), "Vínculo persistido deve estar vinculado a um usuário");
        });
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\java\br\com\cloudport\servicoautenticacao\controllers\AuthenticationControllerTest.java ----- 
package br.com.cloudport.servicoautenticacao.controllers;

import br.com.cloudport.servicoautenticacao.app.configuracoes.dto.AuthenticationDTO;
import br.com.cloudport.servicoautenticacao.app.configuracoes.dto.RegisterDTO;
import br.com.cloudport.servicoautenticacao.app.usuarioslista.UsuarioRepositorio;
import br.com.cloudport.servicoautenticacao.config.TokenService;
import br.com.cloudport.servicoautenticacao.model.Papel;
import br.com.cloudport.servicoautenticacao.model.Usuario;
import br.com.cloudport.servicoautenticacao.model.UsuarioPapel;
import br.com.cloudport.servicoautenticacao.repositories.PapelRepositorio;
import br.com.cloudport.servicoautenticacao.repositories.UsuarioPapelRepositorio;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Optional;
import java.util.Set;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.test.web.servlet.MockMvc;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(AuthenticationController.class)
@AutoConfigureMockMvc(addFilters = false)
class AuthenticationControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private AuthenticationManager authenticationManager;

    @MockBean
    private UsuarioRepositorio usuarioRepositorio;

    @MockBean
    private PapelRepositorio papelRepositorio;

    @MockBean
    private TokenService tokenService;

    @MockBean
    private UsuarioPapelRepositorio usuarioPapelRepositorio;

    @Test
    void login_sucesso() throws Exception {
        Papel papel = new Papel("ADMIN");
        UsuarioPapel usuarioPapel = new UsuarioPapel(papel);
        Set<UsuarioPapel> papeis = Collections.singleton(usuarioPapel);
        Usuario usuario = new Usuario("test", "pass", papeis);

        Authentication autenticacao = new UsernamePasswordAuthenticationToken(usuario, null, Collections.emptyList());
        when(authenticationManager.authenticate(any())).thenReturn(autenticacao);
        when(tokenService.generateToken(usuario)).thenReturn("token");

        AuthenticationDTO dto = new AuthenticationDTO("test", "pass");

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(usuario.getId().toString()))
                .andExpect(jsonPath("$.login").value("test"))
                .andExpect(jsonPath("$.nome").value("test"))
                .andExpect(jsonPath("$.perfil").value("ADMIN"))
                .andExpect(jsonPath("$.token").value("token"))
                .andExpect(jsonPath("$.roles[0]").value("ADMIN"));
    }

    @Test
    void login_credenciaisInvalidas() throws Exception {
        when(authenticationManager.authenticate(any()))
                .thenThrow(new BadCredentialsException("bad creds"));

        AuthenticationDTO dto = new AuthenticationDTO("bad", "creds");

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isUnauthorized());
    }

    @Test
    void login_payloadInvalido_retornaErrosDeValidacao() throws Exception {
        AuthenticationDTO dto = new AuthenticationDTO("", "");

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.mensagem").value("Erro de validação dos dados enviados."))
                .andExpect(jsonPath("$.erros.login").value("O login é obrigatório."))
                .andExpect(jsonPath("$.erros.password").value("A senha é obrigatória."));
    }

    @Test
    void login_camposCurtos_retornaErrosDeValidacao() throws Exception {
        AuthenticationDTO dto = new AuthenticationDTO("ab", "123");

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.mensagem").value("Erro de validação dos dados enviados."))
                .andExpect(jsonPath("$.erros.login").value("O login deve ter entre 3 e 100 caracteres."))
                .andExpect(jsonPath("$.erros.password").value("A senha deve ter pelo menos 6 caracteres."));
    }

    @Test
    void registrar_loginDuplicado() throws Exception {
        when(usuarioRepositorio.findByLogin("john"))
                .thenReturn(Optional.of(new Usuario()));

        RegisterDTO dto = new RegisterDTO("john", "pass", Collections.singleton("ADMIN"));

        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value("Login informado já está em uso."));
    }

    @Test
    void registrar_payloadInvalido_retornaErros() throws Exception {
        RegisterDTO dto = new RegisterDTO("", "", Collections.emptySet());

        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.mensagem").value("Erro de validação dos dados enviados."))
                .andExpect(jsonPath("$.erros.login").value("O login é obrigatório."))
                .andExpect(jsonPath("$.erros.password").value("A senha é obrigatória."))
                .andExpect(jsonPath("$.erros.roles").value("Informe ao menos uma role."));
    }

    @Test
    void registrar_roleEmBranco_retornaErroDeElemento() throws Exception {
        Set<String> roles = new LinkedHashSet<>();
        roles.add(" ");
        roles.add("ADMIN");

        RegisterDTO dto = new RegisterDTO("usuario", "segredo", roles);

        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.mensagem").value("Erro de validação dos dados enviados."))
                .andExpect(jsonPath("$.erros['roles[0]']").value("A role não pode ser vazia."));
    }

    @Test
    void registrar_sucesso() throws Exception {
        when(usuarioRepositorio.findByLogin("john")).thenReturn(Optional.empty());
        when(papelRepositorio.findByNome("ADMIN")).thenReturn(Optional.of(new Papel("ADMIN")));

        RegisterDTO dto = new RegisterDTO("john", "pass", Collections.singleton("ADMIN"));

        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isOk());

        verify(usuarioRepositorio).save(any(Usuario.class));

        ArgumentCaptor<Iterable<UsuarioPapel>> papeisCaptor = ArgumentCaptor.forClass(Iterable.class);
        verify(usuarioPapelRepositorio).saveAll(papeisCaptor.capture());

        Iterable<UsuarioPapel> papeisSalvos = papeisCaptor.getValue();
        assertNotNull(papeisSalvos);
        assertTrue(papeisSalvos.iterator().hasNext());
        UsuarioPapel papelSalvo = papeisSalvos.iterator().next();
        assertNotNull(papelSalvo.getUsuario());
        assertEquals("john", papelSalvo.getUsuario().getLogin());
    }

    @Test
    void registrar_papelNaoEncontrado() throws Exception {
        when(usuarioRepositorio.findByLogin("john")).thenReturn(Optional.empty());
        when(papelRepositorio.findByNome("UNKNOWN")).thenReturn(Optional.empty());

        RegisterDTO dto = new RegisterDTO("john", "pass", Collections.singleton("UNKNOWN"));

        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value("Papel 'UNKNOWN' não encontrado."));
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\java\br\com\cloudport\servicoautenticacao\controllers\RoleControllerNotFoundIT.java ----- 
package br.com.cloudport.servicoautenticacao.controllers;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
class RoleControllerNotFoundIT {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @WithMockUser(roles = "ADMIN")
    @DisplayName("GET /api/roles/{name} deve retornar 404 quando o role não existir")
    void shouldReturn404WhenRoleIsNotFoundByName() throws Exception {
        mockMvc.perform(get("/api/roles/{name}", "role-inexistente"))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    @DisplayName("PUT /api/roles/{id} deve retornar 404 quando o role não existir")
    void shouldReturn404WhenRoleIsNotFoundOnUpdate() throws Exception {
        mockMvc.perform(put("/api/roles/{id}", 999L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"name\":\"Novo Nome\"}"))
                .andExpect(status().isNotFound());
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    @DisplayName("DELETE /api/roles/{id} deve retornar 404 quando o role não existir")
    void shouldReturn404WhenRoleIsNotFoundOnDelete() throws Exception {
        mockMvc.perform(delete("/api/roles/{id}", 999L))
                .andExpect(status().isNotFound());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\java\br\com\cloudport\servicoautenticacao\repositories\PapelRepositorioTest.java ----- 
package br.com.cloudport.servicoautenticacao.repositories;

import br.com.cloudport.servicoautenticacao.app.usuarioslista.UsuarioRepositorio;
import br.com.cloudport.servicoautenticacao.model.Papel;
import br.com.cloudport.servicoautenticacao.model.StatusUsuarioEnum;
import br.com.cloudport.servicoautenticacao.model.Usuario;
import br.com.cloudport.servicoautenticacao.model.UsuarioPapel;
import java.util.HashSet;
import java.util.UUID;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
class PapelRepositorioTest {

    @Autowired
    private PapelRepositorio papelRepositorio;

    @Autowired
    private UsuarioRepositorio usuarioRepositorio;

    @Autowired
    private UsuarioPapelRepositorio usuarioPapelRepositorio;

    @Test
    void buscarPorNomeRetornaPapelComVinculosDeUsuarios() {
        Papel papel = papelRepositorio.save(new Papel("ADMIN"));

        Usuario usuario = new Usuario(UUID.randomUUID(), "john.doe", "senha", new HashSet<>());
        usuarioRepositorio.save(usuario);

        UsuarioPapel vinculo = new UsuarioPapel(usuario, papel);
        vinculo.setStatus(StatusUsuarioEnum.ATIVO);
        usuario.getPapeis().add(vinculo);
        papel.getUsuarioPapeis().add(vinculo);
        usuarioPapelRepositorio.save(vinculo);

        Papel persistido = papelRepositorio.findByNome("ADMIN").orElseThrow();

        assertThat(persistido.getNome()).isEqualTo("ADMIN");
        assertThat(persistido.getUsuarioPapeis())
                .hasSize(1)
                .allSatisfy(usuarioPapel -> {
                    assertThat(usuarioPapel.getUsuario().getId()).isEqualTo(usuario.getId());
                    assertThat(usuarioPapel.getPapel().getId()).isEqualTo(papel.getId());
                    assertThat(usuarioPapel.getStatus()).isEqualTo(StatusUsuarioEnum.ATIVO);
                });
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-autenticacao\src\test\resources\application.properties ----- 
spring.datasource.url=jdbc:h2:mem:servicoautenticacao;DB_CLOSE_DELAY=-1;MODE=PostgreSQL
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.open-in-view=false
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=false
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\README.md ----- 
# Serviço Gate

O serviço **servico-gate** atua como orquestrador das integrações de gate do CloudPort. Ele expõe APIs REST, troca mensagens via RabbitMQ e se integra com o TOS, storage de documentos e serviços de autenticação.

- Visão completa da arquitetura: [`docs/servico-gate-architecture.md`](../../docs/servico-gate-architecture.md)
- Procedimentos operacionais padrão: [`docs/servico-gate-operacoes.md`](../../docs/servico-gate-operacoes.md)
- Scripts REST para testes manuais: [`tools/api/servico-gate.http`](../../tools/api/servico-gate.http)

## Pré-requisitos

- JDK 11 ou superior
- Maven 3.8+
- PostgreSQL com uma base dedicada
- Instância RabbitMQ acessível

## Configuração

1. Copie o arquivo `env.example` na raiz do projeto para `.env` e ajuste as variáveis que começam com `GATE_`, `TOS_API_` e `DOCUMENT_STORAGE_`.
2. Exporte as variáveis no terminal com `export $(grep -v '^#' .env | xargs)` ou configure-as no serviço de execução.
3. Garanta que o banco de dados configurado em `GATE_DB_URL` exista. Exemplo:
   ```bash
   createdb servico_gate
   ```

## Execução

Na raiz do projeto, execute o comando abaixo para iniciar o serviço:

```bash
cd backend/servico-gate
mvn spring-boot:run
```

Por padrão o serviço inicia na porta definida em `GATE_SERVER_PORT` (8082).

Para levantar a stack completa com PostgreSQL, RabbitMQ, Redis e mocks de integrações, utilize o [`docker-compose`](../../docker/docker-compose.yml):

```bash
cp env.example .env
docker compose -f docker/docker-compose.yml up --build
```

## Testes

Para rodar os testes automatizados:

```bash
mvn test
```
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\pom.xml ----- 
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.4</version>
        <relativePath/>
    </parent>
    <groupId>br.com.cloudport</groupId>
    <artifactId>servico-gate</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>servico-gate</name>
    <description>Serviço de orquestração e integração de gate</description>
    <properties>
        <java.version>11</java.version>
        <opentelemetry.version>1.27.0</opentelemetry.version>
        <logstash-logback.version>7.4</logstash-logback.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-ui</artifactId>
            <version>1.5.10</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-spring-boot2</artifactId>
            <version>1.7.1</version>
        </dependency>
        <dependency>
            <groupId>net.logstash.logback</groupId>
            <artifactId>logstash-logback-encoder</artifactId>
            <version>${logstash-logback.version}</version>
        </dependency>
        <dependency>
            <groupId>io.opentelemetry.instrumentation</groupId>
            <artifactId>opentelemetry-spring-boot-starter</artifactId>
            <version>${opentelemetry.version}</version>
        </dependency>
        <dependency>
            <groupId>io.opentelemetry</groupId>
            <artifactId>opentelemetry-exporter-otlp</artifactId>
            <version>${opentelemetry.version}</version>
        </dependency>
        <dependency>
            <groupId>io.opentelemetry.instrumentation</groupId>
            <artifactId>opentelemetry-logback-mdc-1.0</artifactId>
            <version>${opentelemetry.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.opencsv</groupId>
            <artifactId>opencsv</artifactId>
            <version>5.7.1</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>5.2.3</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>5.2.3</version>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>mockwebserver</artifactId>
            <version>4.12.0</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-contract-wiremock</artifactId>
            <version>3.1.7</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\.mvn\wrapper\maven-wrapper.properties ----- 
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.3/apache-maven-3.9.3-bin.zip
wrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\ServicoGateApplication.java ----- 
package br.com.cloudport.servicogate;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
@EnableAsync
@EnableCaching
public class ServicoGateApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServicoGateApplication.class, args);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\administracao\ContingenciaController.java ----- 
package br.com.cloudport.servicogate.app.administracao;

import br.com.cloudport.servicogate.app.administracao.dto.ContingenciaAgendamentoRequest;
import br.com.cloudport.servicogate.app.administracao.dto.ContingenciaLiberacaoRequest;
import br.com.cloudport.servicogate.app.administracao.dto.ContingenciaResponse;
import javax.validation.Valid;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/gate/contingencia")
@Validated
@ConditionalOnProperty(prefix = "cloudport.gate.contingencia", name = "enabled", havingValue = "true")
public class ContingenciaController {

    private final ContingenciaService contingenciaService;

    public ContingenciaController(ContingenciaService contingenciaService) {
        this.contingenciaService = contingenciaService;
    }

    @PostMapping("/agendar")
    public ResponseEntity<ContingenciaResponse> agendar(@Valid @RequestBody ContingenciaAgendamentoRequest request) {
        ContingenciaResponse response = contingenciaService.agendar(request);
        return ResponseEntity.status(HttpStatus.ACCEPTED).body(response);
    }

    @PostMapping("/liberar")
    public ResponseEntity<ContingenciaResponse> liberar(@Valid @RequestBody ContingenciaLiberacaoRequest request) {
        ContingenciaResponse response = contingenciaService.liberar(request);
        return ResponseEntity.status(HttpStatus.ACCEPTED).body(response);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\administracao\ContingenciaProperties.java ----- 
package br.com.cloudport.servicogate.app.administracao;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "cloudport.gate.contingencia")
public class ContingenciaProperties {

    /**
     * Indica se as rotas de contingência devem ser expostas.
     */
    private boolean enabled;

    /**
     * Orientação operacional a ser exibida quando a contingência for acionada.
     */
    private String orientacaoOperador = "Acione o playbook de contingência do gate e mantenha registros manuais até a normalização do TOS.";

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public String getOrientacaoOperador() {
        return orientacaoOperador;
    }

    public void setOrientacaoOperador(String orientacaoOperador) {
        this.orientacaoOperador = orientacaoOperador;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\administracao\ContingenciaService.java ----- 
package br.com.cloudport.servicogate.app.administracao;

import br.com.cloudport.servicogate.app.administracao.dto.ContingenciaAgendamentoRequest;
import br.com.cloudport.servicogate.app.administracao.dto.ContingenciaLiberacaoRequest;
import br.com.cloudport.servicogate.app.administracao.dto.ContingenciaResponse;
import br.com.cloudport.servicogate.monitoring.GateMetrics;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class ContingenciaService {

    private static final Logger LOGGER = LoggerFactory.getLogger(ContingenciaService.class);

    private final ContingenciaProperties properties;
    private final GateMetrics gateMetrics;

    public ContingenciaService(ContingenciaProperties properties, GateMetrics gateMetrics) {
        this.properties = properties;
        this.gateMetrics = gateMetrics;
    }

    public ContingenciaResponse agendar(ContingenciaAgendamentoRequest request) {
        String protocolo = gerarProtocolo();
        gateMetrics.registrarContingenciaAcionada("agendar");
        LOGGER.warn("event=contingencia.agendar codigo={} operador={} motivo=\"{}\" protocolo={} orientacao=\"{}\"",
                request.getCodigo(), request.getOperador(), request.getMotivo(), protocolo, properties.getOrientacaoOperador());
        String orientacoes = String.format("%s | Registrar atendimento manual para o código %s (motivo: %s).",
                properties.getOrientacaoOperador(), request.getCodigo(), request.getMotivo());
        return new ContingenciaResponse(protocolo, orientacoes);
    }

    public ContingenciaResponse liberar(ContingenciaLiberacaoRequest request) {
        String protocolo = gerarProtocolo();
        gateMetrics.registrarContingenciaAcionada("liberar");
        LOGGER.warn("event=contingencia.liberar codigo={} operador={} observacao=\"{}\" protocolo={} orientacao=\"{}\"",
                request.getCodigo(), request.getOperador(), request.getObservacao(), protocolo, properties.getOrientacaoOperador());
        String orientacoes = String.format("%s | Autorizar manualmente o gate para o código %s. Observação: %s.",
                properties.getOrientacaoOperador(), request.getCodigo(),
                request.getObservacao() != null ? request.getObservacao() : "sem observação");
        return new ContingenciaResponse(protocolo, orientacoes);
    }

    private String gerarProtocolo() {
        String timestamp = DateTimeFormatter.ofPattern("yyyyMMddHHmmss")
                .withZone(ZoneOffset.UTC)
                .format(Instant.now());
        return timestamp + "-" + UUID.randomUUID().toString().substring(0, 8);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\administracao\dto\ContingenciaAgendamentoRequest.java ----- 
package br.com.cloudport.servicogate.app.administracao.dto;

import javax.validation.constraints.NotBlank;

public class ContingenciaAgendamentoRequest {

    @NotBlank
    private String codigo;

    @NotBlank
    private String motivo;

    @NotBlank
    private String operador;

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getMotivo() {
        return motivo;
    }

    public void setMotivo(String motivo) {
        this.motivo = motivo;
    }

    public String getOperador() {
        return operador;
    }

    public void setOperador(String operador) {
        this.operador = operador;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\administracao\dto\ContingenciaLiberacaoRequest.java ----- 
package br.com.cloudport.servicogate.app.administracao.dto;

import javax.validation.constraints.NotBlank;

public class ContingenciaLiberacaoRequest {

    @NotBlank
    private String codigo;

    @NotBlank
    private String operador;

    private String observacao;

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getOperador() {
        return operador;
    }

    public void setOperador(String operador) {
        this.operador = operador;
    }

    public String getObservacao() {
        return observacao;
    }

    public void setObservacao(String observacao) {
        this.observacao = observacao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\administracao\dto\ContingenciaResponse.java ----- 
package br.com.cloudport.servicogate.app.administracao.dto;

public class ContingenciaResponse {

    private final String protocolo;
    private final String orientacoes;

    public ContingenciaResponse(String protocolo, String orientacoes) {
        this.protocolo = protocolo;
        this.orientacoes = orientacoes;
    }

    public String getProtocolo() {
        return protocolo;
    }

    public String getOrientacoes() {
        return orientacoes;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\auditoria\RelatorioController.java ----- 
package br.com.cloudport.servicogate.app.auditoria;

import br.com.cloudport.servicogate.app.transparencia.dto.DashboardFiltroDTO;
import br.com.cloudport.servicogate.app.auditoria.dto.FormatoExportacao;
import br.com.cloudport.servicogate.app.auditoria.dto.RelatorioAgendamentoDTO;
import br.com.cloudport.servicogate.app.auditoria.dto.RelatorioResponseDTO;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import br.com.cloudport.servicogate.app.transparencia.DashboardService;
import java.time.LocalDateTime;
import java.util.List;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/gate/relatorios")
public class RelatorioController {

    private final DashboardService dashboardService;

    public RelatorioController(DashboardService dashboardService) {
        this.dashboardService = dashboardService;
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE')")
    public RelatorioResponseDTO consultar(
            @RequestParam(value = "inicio", required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime inicio,
            @RequestParam(value = "fim", required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fim,
            @RequestParam(value = "transportadoraId", required = false) Long transportadoraId,
            @RequestParam(value = "tipoOperacao", required = false) String tipoOperacao
    ) {
        DashboardFiltroDTO filtro = construirFiltro(inicio, fim, transportadoraId, tipoOperacao);
        List<RelatorioAgendamentoDTO> agendamentos = dashboardService.buscarRelatorio(filtro);
        return new RelatorioResponseDTO(dashboardService.obterResumo(filtro), agendamentos);
    }

    @GetMapping("/export")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE')")
    public ResponseEntity<byte[]> exportar(
            @RequestParam(value = "inicio", required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime inicio,
            @RequestParam(value = "fim", required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fim,
            @RequestParam(value = "transportadoraId", required = false) Long transportadoraId,
            @RequestParam(value = "tipoOperacao", required = false) String tipoOperacao,
            @RequestParam(value = "formato", required = false) String formato
    ) {
        DashboardFiltroDTO filtro = construirFiltro(inicio, fim, transportadoraId, tipoOperacao);
        FormatoExportacao formatoExportacao = FormatoExportacao.from(formato);
        byte[] arquivo = dashboardService.exportarRelatorio(filtro, formatoExportacao);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(formatoExportacao.getMediaType());
        headers.setContentDisposition(ContentDisposition.attachment()
                .filename("relatorio-gate." + formatoExportacao.getExtensao())
                .build());

        return ResponseEntity.ok()
                .headers(headers)
                .body(arquivo);
    }

    private DashboardFiltroDTO construirFiltro(LocalDateTime inicio, LocalDateTime fim,
                                               Long transportadoraId, String tipoOperacao) {
        DashboardFiltroDTO filtro = new DashboardFiltroDTO();
        filtro.setInicio(inicio);
        filtro.setFim(fim);
        filtro.setTransportadoraId(transportadoraId);
        if (tipoOperacao != null && !tipoOperacao.isBlank()) {
            filtro.setTipoOperacao(TipoOperacao.valueOf(tipoOperacao.toUpperCase()));
        }
        return filtro;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\auditoria\dto\FormatoExportacao.java ----- 
package br.com.cloudport.servicogate.app.auditoria.dto;

import org.springframework.http.MediaType;

public enum FormatoExportacao {
    CSV("text/csv", "csv"),
    EXCEL("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx");

    private final String mediaType;
    private final String extensao;

    FormatoExportacao(String mediaType, String extensao) {
        this.mediaType = mediaType;
        this.extensao = extensao;
    }

    public MediaType getMediaType() {
        return MediaType.parseMediaType(mediaType);
    }

    public String getExtensao() {
        return extensao;
    }

    public static FormatoExportacao from(String value) {
        if (value == null) {
            return CSV;
        }
        return FormatoExportacao.valueOf(value.trim().toUpperCase());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\auditoria\dto\RelatorioAgendamentoDTO.java ----- 
package br.com.cloudport.servicogate.app.auditoria.dto;

import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import java.time.LocalDateTime;

public class RelatorioAgendamentoDTO {

    private String codigo;
    private TipoOperacao tipoOperacao;
    private StatusAgendamento status;
    private String transportadora;
    private LocalDateTime horarioPrevistoChegada;
    private LocalDateTime horarioRealChegada;
    private LocalDateTime horarioPrevistoSaida;
    private LocalDateTime horarioRealSaida;

    public static RelatorioAgendamentoDTO fromEntity(Agendamento agendamento) {
        RelatorioAgendamentoDTO dto = new RelatorioAgendamentoDTO();
        dto.setCodigo(agendamento.getCodigo());
        dto.setTipoOperacao(agendamento.getTipoOperacao());
        dto.setStatus(agendamento.getStatus());
        dto.setTransportadora(agendamento.getTransportadora() != null ? agendamento.getTransportadora().getNome() : null);
        dto.setHorarioPrevistoChegada(agendamento.getHorarioPrevistoChegada());
        dto.setHorarioRealChegada(agendamento.getHorarioRealChegada());
        dto.setHorarioPrevistoSaida(agendamento.getHorarioPrevistoSaida());
        dto.setHorarioRealSaida(agendamento.getHorarioRealSaida());
        return dto;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public TipoOperacao getTipoOperacao() {
        return tipoOperacao;
    }

    public void setTipoOperacao(TipoOperacao tipoOperacao) {
        this.tipoOperacao = tipoOperacao;
    }

    public StatusAgendamento getStatus() {
        return status;
    }

    public void setStatus(StatusAgendamento status) {
        this.status = status;
    }

    public String getTransportadora() {
        return transportadora;
    }

    public void setTransportadora(String transportadora) {
        this.transportadora = transportadora;
    }

    public LocalDateTime getHorarioPrevistoChegada() {
        return horarioPrevistoChegada;
    }

    public void setHorarioPrevistoChegada(LocalDateTime horarioPrevistoChegada) {
        this.horarioPrevistoChegada = horarioPrevistoChegada;
    }

    public LocalDateTime getHorarioRealChegada() {
        return horarioRealChegada;
    }

    public void setHorarioRealChegada(LocalDateTime horarioRealChegada) {
        this.horarioRealChegada = horarioRealChegada;
    }

    public LocalDateTime getHorarioPrevistoSaida() {
        return horarioPrevistoSaida;
    }

    public void setHorarioPrevistoSaida(LocalDateTime horarioPrevistoSaida) {
        this.horarioPrevistoSaida = horarioPrevistoSaida;
    }

    public LocalDateTime getHorarioRealSaida() {
        return horarioRealSaida;
    }

    public void setHorarioRealSaida(LocalDateTime horarioRealSaida) {
        this.horarioRealSaida = horarioRealSaida;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\auditoria\dto\RelatorioResponseDTO.java ----- 
package br.com.cloudport.servicogate.app.auditoria.dto;

import br.com.cloudport.servicogate.app.transparencia.dto.DashboardResumoDTO;
import java.util.List;

public class RelatorioResponseDTO {

    private DashboardResumoDTO resumo;
    private List<RelatorioAgendamentoDTO> agendamentos;

    public RelatorioResponseDTO() {
    }

    public RelatorioResponseDTO(DashboardResumoDTO resumo, List<RelatorioAgendamentoDTO> agendamentos) {
        this.resumo = resumo;
        this.agendamentos = agendamentos;
    }

    public DashboardResumoDTO getResumo() {
        return resumo;
    }

    public void setResumo(DashboardResumoDTO resumo) {
        this.resumo = resumo;
    }

    public List<RelatorioAgendamentoDTO> getAgendamentos() {
        return agendamentos;
    }

    public void setAgendamentos(List<RelatorioAgendamentoDTO> agendamentos) {
        this.agendamentos = agendamentos;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\AgendamentoController.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoRequest;
import br.com.cloudport.servicogate.app.cidadao.dto.DocumentoAgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.DocumentoUploadRequest;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoService;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRealtimeService;
import br.com.cloudport.servicogate.app.cidadao.DocumentoDownload;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import java.time.LocalDate;
import java.util.List;
import javax.validation.Valid;
import org.springdoc.api.annotations.ParameterObject;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@RestController
@RequestMapping("/gate/agendamentos")
@Validated
@Tag(name = "Agendamentos", description = "Gestão de agendamentos de gate")
public class AgendamentoController {

    private final AgendamentoService agendamentoService;
    private final AgendamentoRealtimeService agendamentoRealtimeService;

    public AgendamentoController(AgendamentoService agendamentoService,
                                 AgendamentoRealtimeService agendamentoRealtimeService) {
        this.agendamentoService = agendamentoService;
        this.agendamentoRealtimeService = agendamentoRealtimeService;
    }

    @GetMapping
    @Operation(summary = "Lista agendamentos com filtros de período e paginação")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE','TRANSPORTADORA')")
    public Page<AgendamentoDTO> listar(@Parameter(description = "Data inicial do período (inclusive)")
                                       @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
                                       @Parameter(description = "Data final do período (inclusive)")
                                       @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim,
                                       @ParameterObject Pageable pageable) {
        return agendamentoService.buscar(dataInicio, dataFim, pageable);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Detalha um agendamento específico")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE','TRANSPORTADORA')")
    public AgendamentoDTO buscarPorId(@PathVariable Long id) {
        return agendamentoService.buscarPorId(id);
    }

    @GetMapping(value = "/{id}/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    @Operation(summary = "Acompanha atualizações em tempo real do agendamento")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE','TRANSPORTADORA')")
    public SseEmitter acompanhar(@PathVariable Long id) {
        return agendamentoRealtimeService.registrar(id);
    }

    @PostMapping
    @Operation(summary = "Cria um novo agendamento")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR')")
    public ResponseEntity<AgendamentoDTO> criar(@Valid @RequestBody AgendamentoRequest request) {
        AgendamentoDTO criado = agendamentoService.criar(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(criado);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Atualiza um agendamento existente")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR')")
    public AgendamentoDTO atualizar(@PathVariable Long id, @Valid @RequestBody AgendamentoRequest request) {
        return agendamentoService.atualizar(id, request);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Cancela um agendamento")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR')")
    public ResponseEntity<Void> cancelar(@PathVariable Long id) {
        agendamentoService.cancelar(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping(value = "/{id}/documentos", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(summary = "Realiza upload de documento para o agendamento")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE','TRANSPORTADORA')")
    public ResponseEntity<DocumentoAgendamentoDTO> uploadDocumento(@PathVariable Long id,
                                                                   @Valid @RequestPart(value = "metadata", required = false) DocumentoUploadRequest metadata,
                                                                   @RequestPart("file") MultipartFile arquivo) {
        DocumentoAgendamentoDTO documento = agendamentoService.adicionarDocumento(id, metadata, arquivo);
        return ResponseEntity.status(HttpStatus.ACCEPTED).body(documento);
    }

    @GetMapping("/{id}/documentos")
    @Operation(summary = "Lista documentos de um agendamento")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE','TRANSPORTADORA')")
    public List<DocumentoAgendamentoDTO> listarDocumentos(@PathVariable Long id) {
        return agendamentoService.listarDocumentos(id);
    }

    @GetMapping("/{agendamentoId}/documentos/{documentoId}")
    @Operation(summary = "Download de documento do agendamento")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE','TRANSPORTADORA')")
    public ResponseEntity<org.springframework.core.io.Resource> downloadDocumento(@PathVariable Long agendamentoId,
                                                                                  @PathVariable Long documentoId) {
        DocumentoDownload download = agendamentoService.baixarDocumento(agendamentoId, documentoId);
        ContentDisposition disposition = ContentDisposition.attachment().filename(download.getFilename()).build();
        return ResponseEntity.ok()
                .header("Content-Disposition", disposition.toString())
                .contentType(MediaType.parseMediaType(download.getContentType()))
                .body(download.getResource());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\AgendamentoRealtimeService.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.config.AgendamentoRulesProperties;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.DocumentoAgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.GatePassDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.mapper.GateMapper;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import br.com.cloudport.servicogate.model.GatePass;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRepository;
import br.com.cloudport.servicogate.app.cidadao.NotificationGateway;
import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@Service
public class AgendamentoRealtimeService {

    private static final Logger LOGGER = LoggerFactory.getLogger(AgendamentoRealtimeService.class);
    private static final Duration DEFAULT_SSE_TIMEOUT = Duration.ofMinutes(30);
    private static final Duration DEFAULT_INTERVALO_REPETICAO = Duration.ofMinutes(5);

    private final AgendamentoRepository agendamentoRepository;
    private final NotificationGateway notificationGateway;
    private final AgendamentoRulesProperties rulesProperties;
    private final Map<Long, CopyOnWriteArrayList<SseEmitter>> emissoresPorAgendamento = new ConcurrentHashMap<>();
    private final Map<Long, LocalDateTime> ultimaJanelaNotificada = new ConcurrentHashMap<>();

    public AgendamentoRealtimeService(AgendamentoRepository agendamentoRepository,
                                      NotificationGateway notificationGateway,
                                      AgendamentoRulesProperties rulesProperties) {
        this.agendamentoRepository = agendamentoRepository;
        this.notificationGateway = notificationGateway;
        this.rulesProperties = rulesProperties;
    }

    public SseEmitter registrar(Long agendamentoId) {
        SseEmitter emitter = new SseEmitter(DEFAULT_SSE_TIMEOUT.toMillis());
        emissoresPorAgendamento.computeIfAbsent(agendamentoId, id -> new CopyOnWriteArrayList<>()).add(emitter);
        emitter.onCompletion(() -> removerEmissor(agendamentoId, emitter));
        emitter.onTimeout(() -> removerEmissor(agendamentoId, emitter));
        emitter.onError(throwable -> removerEmissor(agendamentoId, emitter));

        agendamentoRepository.findById(agendamentoId)
                .ifPresent(agendamento -> {
                    enviar(emitter, "snapshot", GateMapper.toAgendamentoDTO(agendamento));
                    verificarJanelaProxima(agendamento);
                });
        return emitter;
    }

    public void notificarStatus(Agendamento agendamento) {
        AgendamentoDTO dto = GateMapper.toAgendamentoDTO(agendamento);
        enviar(agendamento.getId(), "status-atualizado", dto);
        notificationGateway.enviarStatusAtualizado(agendamento);
    }

    public void notificarGatePass(GatePass gatePass) {
        if (gatePass == null || gatePass.getAgendamento() == null) {
            return;
        }
        GatePassDTO dto = GateMapper.toGatePassDTO(gatePass);
        enviar(gatePass.getAgendamento().getId(), "gate-pass-atualizado", dto);
    }

    public void notificarDocumentosAtualizados(Agendamento agendamento) {
        List<DocumentoAgendamento> documentos = Optional.ofNullable(agendamento.getDocumentos())
                .orElse(List.of());
        List<DocumentoAgendamentoDTO> documentosDto = GateMapper.toDocumentoAgendamentoDTO(documentos);
        enviar(agendamento.getId(), "documentos-atualizados", documentosDto);
    }

    public void notificarDocumentosRevalidados(Agendamento agendamento) {
        List<DocumentoAgendamento> documentos = Optional.ofNullable(agendamento.getDocumentos())
                .orElse(List.of());
        List<DocumentoAgendamentoDTO> documentosDto = GateMapper.toDocumentoAgendamentoDTO(documentos);
        enviar(agendamento.getId(), "documentos-revalidados", documentosDto);
        notificationGateway.enviarDocumentosRevalidados(agendamento, documentos);
    }

    public void verificarJanelaProxima(Agendamento agendamento) {
        if (agendamento == null || agendamento.getHorarioPrevistoChegada() == null) {
            return;
        }
        Duration antecedenciaConfigurada = Objects.requireNonNullElse(
                rulesProperties.getNotificacaoJanelaAntecedencia(),
                Duration.ofMinutes(30));
        LocalDateTime agora = LocalDateTime.now();
        Duration ateJanela = Duration.between(agora, agendamento.getHorarioPrevistoChegada());
        if (ateJanela.isNegative()) {
            return;
        }
        if (ateJanela.compareTo(antecedenciaConfigurada) > 0) {
            return;
        }

        LocalDateTime ultimoEnvio = ultimaJanelaNotificada.get(agendamento.getId());
        if (ultimoEnvio != null && Duration.between(ultimoEnvio, agora).compareTo(DEFAULT_INTERVALO_REPETICAO) < 0) {
            return;
        }

        ultimaJanelaNotificada.put(agendamento.getId(), agora);
        JanelaProximaDTO payload = new JanelaProximaDTO(
                agendamento.getCodigo(),
                agendamento.getHorarioPrevistoChegada(),
                agendamento.getHorarioPrevistoSaida(),
                ateJanela.toMinutes()
        );
        enviar(agendamento.getId(), "janela-proxima", payload);
        notificationGateway.enviarJanelaProxima(agendamento, ateJanela);
    }

    private void enviar(Long agendamentoId, String evento, Object payload) {
        CopyOnWriteArrayList<SseEmitter> emissores = emissoresPorAgendamento.get(agendamentoId);
        if (emissores == null || emissores.isEmpty()) {
            return;
        }
        emissores.forEach(emitter -> enviar(emitter, evento, payload));
    }

    private void enviar(SseEmitter emitter, String evento, Object payload) {
        try {
            emitter.send(SseEmitter.event().name(evento).data(payload));
        } catch (IOException ex) {
            LOGGER.debug("Falha ao enviar evento SSE", ex);
            emitter.completeWithError(ex);
        }
    }

    private void removerEmissor(Long agendamentoId, SseEmitter emitter) {
        CopyOnWriteArrayList<SseEmitter> emissores = emissoresPorAgendamento.get(agendamentoId);
        if (emissores != null) {
            emissores.remove(emitter);
            if (emissores.isEmpty()) {
                emissoresPorAgendamento.remove(agendamentoId);
            }
        }
    }

    public record JanelaProximaDTO(String codigo,
                                   LocalDateTime horarioPrevistoChegada,
                                   LocalDateTime horarioPrevistoSaida,
                                   long minutosRestantes) {
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\AgendamentoRepository.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.app.cidadao.dto.dashboard.OcupacaoPorHoraDTO;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import br.com.cloudport.servicogate.app.transparencia.DashboardMetricsProjection;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface AgendamentoRepository extends JpaRepository<Agendamento, Long> {

    Optional<Agendamento> findByCodigo(String codigo);

    Optional<Agendamento> findFirstByVeiculoPlacaIgnoreCaseAndStatusInOrderByHorarioPrevistoChegadaAsc(
            String placa,
            List<StatusAgendamento> status);

    Optional<Agendamento> findFirstByVeiculoIdAndStatusInOrderByHorarioPrevistoChegadaDesc(
            Long veiculoId,
            List<StatusAgendamento> status);

    List<Agendamento> findByStatus(StatusAgendamento status);

    List<Agendamento> findByStatusInOrderByHorarioPrevistoChegadaAsc(List<StatusAgendamento> status);

    List<Agendamento> findByJanelaAtendimentoData(LocalDate data);

    Page<Agendamento> findByJanelaAtendimentoData(LocalDate data, Pageable pageable);

    Page<Agendamento> findByJanelaAtendimentoDataBetween(LocalDate inicio, LocalDate fim, Pageable pageable);

    Page<Agendamento> findByJanelaAtendimentoDataGreaterThanEqual(LocalDate inicio, Pageable pageable);

    Page<Agendamento> findByJanelaAtendimentoDataLessThanEqual(LocalDate fim, Pageable pageable);

    long countByJanelaAtendimentoIdAndStatusNot(Long janelaAtendimentoId, StatusAgendamento status);

    long countByJanelaAtendimentoIdAndStatusNotAndIdNot(Long janelaAtendimentoId, StatusAgendamento status,
                                                        Long id);

    @Query("SELECT new br.com.cloudport.servicogate.app.cidadao.dto.dashboard.OcupacaoPorHoraDTO(" +
            "j.horaInicio, " +
            "SUM(CASE WHEN a.id IS NOT NULL AND a.status <> br.com.cloudport.servicogate.model.enums.StatusAgendamento.CANCELADO THEN 1 ELSE 0 END), " +
            "j.capacidade) " +
            "FROM JanelaAtendimento j LEFT JOIN j.agendamentos a " +
            "WHERE j.data = :data " +
            "GROUP BY j.horaInicio, j.capacidade " +
            "ORDER BY j.horaInicio")
    List<OcupacaoPorHoraDTO> calcularOcupacaoPorHora(@Param("data") LocalDate data);

    @Query(value = "SELECT " +
            "COUNT(*) FILTER (WHERE a.status <> 'CANCELADO') AS total_agendamentos, " +
            "SUM(CASE WHEN a.status <> 'CANCELADO' AND a.horario_real_chegada IS NOT NULL AND a.horario_previsto_chegada IS NOT NULL " +
            "AND ABS(EXTRACT(EPOCH FROM (a.horario_real_chegada - a.horario_previsto_chegada))) <= (:toleranciaPontualidade * 60) THEN 1 ELSE 0 END) AS pontuais, " +
            "SUM(CASE WHEN a.status = 'NO_SHOW' THEN 1 ELSE 0 END) AS no_show, " +
            "AVG(EXTRACT(EPOCH FROM (a.horario_real_saida - a.horario_real_chegada)) / 60) FILTER (WHERE a.horario_real_chegada IS NOT NULL AND a.horario_real_saida IS NOT NULL) AS turnaround_medio, " +
            "COALESCE(COUNT(*) FILTER (WHERE a.status <> 'CANCELADO')::decimal / NULLIF(( " +
            "SELECT SUM(j.capacidade) FROM janela_atendimento j WHERE EXISTS ( " +
            "SELECT 1 FROM agendamento a2 WHERE a2.janela_atendimento_id = j.id " +
            "AND a2.status <> 'CANCELADO' " +
            "AND (:inicio IS NULL OR a2.horario_previsto_chegada >= :inicio) " +
            "AND (:fim IS NULL OR a2.horario_previsto_saida <= :fim) " +
            "AND (:transportadoraId IS NULL OR a2.transportadora_id = :transportadoraId) " +
            "AND (:tipoOperacao IS NULL OR a2.tipo_operacao = :tipoOperacao))), 0), 0) AS ocupacao_slots " +
            "FROM agendamento a " +
            "WHERE (:inicio IS NULL OR a.horario_previsto_chegada >= :inicio) " +
            "AND (:fim IS NULL OR a.horario_previsto_saida <= :fim) " +
            "AND (:transportadoraId IS NULL OR a.transportadora_id = :transportadoraId) " +
            "AND (:tipoOperacao IS NULL OR a.tipo_operacao = :tipoOperacao)",
            nativeQuery = true)
    DashboardMetricsProjection calcularMetricasDashboard(@Param("inicio") java.time.LocalDateTime inicio,
                                                         @Param("fim") java.time.LocalDateTime fim,
                                                         @Param("transportadoraId") Long transportadoraId,
                                                         @Param("tipoOperacao") String tipoOperacao,
                                                         @Param("toleranciaPontualidade") int toleranciaPontualidade);

    @Query("SELECT a FROM Agendamento a " +
            "JOIN FETCH a.transportadora t " +
            "JOIN FETCH a.janelaAtendimento j " +
            "LEFT JOIN FETCH a.gatePass gp " +
            "WHERE (:inicio IS NULL OR a.horarioPrevistoChegada >= :inicio) " +
            "AND (:fim IS NULL OR a.horarioPrevistoSaida <= :fim) " +
            "AND (:transportadoraId IS NULL OR t.id = :transportadoraId) " +
            "AND (:tipoOperacao IS NULL OR a.tipoOperacao = :tipoOperacao) " +
            "AND a.status <> br.com.cloudport.servicogate.model.enums.StatusAgendamento.CANCELADO " +
            "ORDER BY a.horarioPrevistoChegada ASC")
    List<Agendamento> buscarRelatorio(@Param("inicio") java.time.LocalDateTime inicio,
                                      @Param("fim") java.time.LocalDateTime fim,
                                      @Param("transportadoraId") Long transportadoraId,
                                      @Param("tipoOperacao") TipoOperacao tipoOperacao);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\AgendamentoService.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.config.AgendamentoRulesProperties;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoRequest;
import br.com.cloudport.servicogate.app.cidadao.dto.DocumentoAgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.DocumentoUploadRequest;
import br.com.cloudport.servicogate.app.cidadao.dto.mapper.GateMapper;
import br.com.cloudport.servicogate.exception.BusinessException;
import br.com.cloudport.servicogate.exception.NotFoundException;
import br.com.cloudport.servicogate.integration.ocr.ProcessamentoOcrPublisher;
import br.com.cloudport.servicogate.integration.tos.TosIntegrationService;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import br.com.cloudport.servicogate.model.JanelaAtendimento;
import br.com.cloudport.servicogate.model.Motorista;
import br.com.cloudport.servicogate.model.Transportadora;
import br.com.cloudport.servicogate.model.Veiculo;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.StatusValidacaoDocumento;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRepository;
import br.com.cloudport.servicogate.app.cidadao.DocumentoAgendamentoRepository;
import br.com.cloudport.servicogate.app.cidadao.JanelaAtendimentoRepository;
import br.com.cloudport.servicogate.app.cidadao.MotoristaRepository;
import br.com.cloudport.servicogate.app.configuracoes.TransportadoraRepository;
import br.com.cloudport.servicogate.app.cidadao.VeiculoRepository;
import br.com.cloudport.servicogate.storage.DocumentoStorageService;
import br.com.cloudport.servicogate.storage.StoredDocumento;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.Normalizer;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.util.HtmlUtils;

@Service
@Transactional
public class AgendamentoService {

    private final AgendamentoRepository agendamentoRepository;
    private final JanelaAtendimentoRepository janelaAtendimentoRepository;
    private final TransportadoraRepository transportadoraRepository;
    private final MotoristaRepository motoristaRepository;
    private final VeiculoRepository veiculoRepository;
    private final DocumentoAgendamentoRepository documentoAgendamentoRepository;
    private final DocumentoStorageService documentoStorageService;
    private final AgendamentoRulesProperties rulesProperties;
    private final TosIntegrationService tosIntegrationService;
    private final DashboardService dashboardService;
    private final AgendamentoRealtimeService agendamentoRealtimeService;
    private final ProcessamentoOcrPublisher processamentoOcrPublisher;

    private static final Logger LOGGER = LoggerFactory.getLogger(AgendamentoService.class);

    public AgendamentoService(AgendamentoRepository agendamentoRepository,
                              JanelaAtendimentoRepository janelaAtendimentoRepository,
                              TransportadoraRepository transportadoraRepository,
                              MotoristaRepository motoristaRepository,
                              VeiculoRepository veiculoRepository,
                              DocumentoAgendamentoRepository documentoAgendamentoRepository,
                              DocumentoStorageService documentoStorageService,
                              AgendamentoRulesProperties rulesProperties,
                              TosIntegrationService tosIntegrationService,
                              DashboardService dashboardService,
                              AgendamentoRealtimeService agendamentoRealtimeService,
                              ProcessamentoOcrPublisher processamentoOcrPublisher) {
        this.agendamentoRepository = agendamentoRepository;
        this.janelaAtendimentoRepository = janelaAtendimentoRepository;
        this.transportadoraRepository = transportadoraRepository;
        this.motoristaRepository = motoristaRepository;
        this.veiculoRepository = veiculoRepository;
        this.documentoAgendamentoRepository = documentoAgendamentoRepository;
        this.documentoStorageService = documentoStorageService;
        this.rulesProperties = rulesProperties;
        this.tosIntegrationService = tosIntegrationService;
        this.dashboardService = dashboardService;
        this.agendamentoRealtimeService = agendamentoRealtimeService;
        this.processamentoOcrPublisher = processamentoOcrPublisher;
    }

    @Transactional(readOnly = true)
    public Page<AgendamentoDTO> buscar(LocalDate dataInicio, LocalDate dataFim, Pageable pageable) {
        Page<Agendamento> page;
        if (dataInicio != null && dataFim != null) {
            page = agendamentoRepository.findByJanelaAtendimentoDataBetween(dataInicio, dataFim, pageable);
        } else if (dataInicio != null) {
            page = agendamentoRepository.findByJanelaAtendimentoDataGreaterThanEqual(dataInicio, pageable);
        } else if (dataFim != null) {
            page = agendamentoRepository.findByJanelaAtendimentoDataLessThanEqual(dataFim, pageable);
        } else {
            page = agendamentoRepository.findAll(pageable);
        }
        return page.map(GateMapper::toAgendamentoDTO);
    }

    @Transactional(readOnly = true)
    public AgendamentoDTO buscarPorId(Long id) {
        Agendamento agendamento = obterAgendamento(id);
        agendamentoRealtimeService.verificarJanelaProxima(agendamento);
        return GateMapper.toAgendamentoDTO(agendamento);
    }

    public AgendamentoDTO criar(AgendamentoRequest request) {
        validarCodigoUnico(null, request.getCodigo());
        JanelaAtendimento janela = buscarJanela(request.getJanelaAtendimentoId());
        validarCapacidade(janela, null);
        validarRegrasDeHorario(janela, request.getHorarioPrevistoChegada());
        validarIntervaloPrevisto(request.getHorarioPrevistoChegada(), request.getHorarioPrevistoSaida());
        if (!horarioDentroDaJanela(janela, request.getHorarioPrevistoChegada())) {
            throw new BusinessException("Horário previsto de chegada deve estar dentro da janela de atendimento");
        }
        if (!horarioDentroDaJanela(janela, request.getHorarioPrevistoSaida())) {
            throw new BusinessException("Horário previsto de saída deve estar dentro da janela de atendimento");
        }

        TipoOperacao tipoOperacao = parseTipoOperacao(request.getTipoOperacao());
        tosIntegrationService.validarAgendamentoParaCriacao(request.getCodigo(), tipoOperacao);
        LOGGER.info("event=tos.validation.booking codigo={} tipoOperacao={}", request.getCodigo(), tipoOperacao);

        Agendamento agendamento = new Agendamento();
        aplicarDados(agendamento, request, janela);
        Agendamento salvo = agendamentoRepository.save(agendamento);
        agendamentoRepository.flush();
        dashboardService.publicarResumoGeral();
        agendamentoRealtimeService.notificarStatus(salvo);
        return GateMapper.toAgendamentoDTO(salvo);
    }

    public AgendamentoDTO atualizar(Long id, AgendamentoRequest request) {
        Agendamento existente = obterAgendamento(id);
        validarEdicaoPermitida(existente);
        validarCodigoUnico(id, request.getCodigo());

        JanelaAtendimento janela = buscarJanela(request.getJanelaAtendimentoId());
        if (!Objects.equals(janela.getId(), existente.getJanelaAtendimento().getId())) {
            validarCapacidade(janela, id);
            validarRegrasDeHorario(janela, request.getHorarioPrevistoChegada());
        } else {
            validarCapacidade(janela, id);
        }
        validarIntervaloPrevisto(request.getHorarioPrevistoChegada(), request.getHorarioPrevistoSaida());
        if (!horarioDentroDaJanela(janela, request.getHorarioPrevistoChegada())) {
            throw new BusinessException("Horário previsto de chegada deve estar dentro da janela de atendimento");
        }
        if (!horarioDentroDaJanela(janela, request.getHorarioPrevistoSaida())) {
            throw new BusinessException("Horário previsto de saída deve estar dentro da janela de atendimento");
        }

        aplicarDados(existente, request, janela);
        Agendamento salvo = agendamentoRepository.save(existente);
        agendamentoRepository.flush();
        dashboardService.publicarResumoGeral();
        agendamentoRealtimeService.notificarStatus(salvo);
        return GateMapper.toAgendamentoDTO(salvo);
    }

    public void cancelar(Long id) {
        Agendamento agendamento = obterAgendamento(id);
        validarEdicaoPermitida(agendamento);
        agendamento.setStatus(StatusAgendamento.CANCELADO);
        agendamentoRepository.save(agendamento);
        agendamentoRepository.flush();
        dashboardService.publicarResumoGeral();
        agendamentoRealtimeService.notificarStatus(agendamento);
    }

    public DocumentoAgendamentoDTO adicionarDocumento(Long agendamentoId, DocumentoUploadRequest request, MultipartFile arquivo) {
        Agendamento agendamento = obterAgendamento(agendamentoId);
        validarEdicaoPermitida(agendamento);
        StoredDocumento storedDocumento = documentoStorageService.armazenar(agendamentoId, arquivo);

        DocumentoAgendamento documento = new DocumentoAgendamento();
        documento.setAgendamento(agendamento);
        documento.setTipoDocumento(sanitizarTexto(resolverTipoDocumento(request, arquivo)));
        documento.setNumero(sanitizarTexto(request != null ? request.getNumero() : null));
        documento.setUrlDocumento(storedDocumento.getStorageKey());
        documento.setNomeArquivo(sanitizarTexto(storedDocumento.getNomeOriginal()));
        documento.setContentType(storedDocumento.getContentType());
        documento.setTamanhoBytes(storedDocumento.getTamanho());
        documento.setUltimaRevalidacao(null);
        documento.setStatusValidacao(StatusValidacaoDocumento.PROCESSANDO);
        documento.setMensagemValidacao("Documento enviado para validação automática via OCR.");

        DocumentoAgendamento salvo = documentoAgendamentoRepository.save(documento);
        agendamento.getDocumentos().add(salvo);
        agendamentoRealtimeService.notificarDocumentosAtualizados(agendamento);
        try {
            processamentoOcrPublisher.enfileirarProcessamento(salvo);
        } catch (RuntimeException ex) {
            LOGGER.error("Falha ao enfileirar documento para OCR", ex);
            salvo.setStatusValidacao(StatusValidacaoDocumento.FALHA);
            salvo.setMensagemValidacao("Não foi possível iniciar a validação automática. Tente novamente em instantes.");
            documentoAgendamentoRepository.save(salvo);
            agendamentoRealtimeService.notificarDocumentosAtualizados(agendamento);
        }
        return GateMapper.toDocumentoAgendamentoDTO(salvo);
    }

    @Transactional(readOnly = true)
    public DocumentoDownload baixarDocumento(Long agendamentoId, Long documentoId) {
        Agendamento agendamento = obterAgendamento(agendamentoId);
        DocumentoAgendamento documento = documentoAgendamentoRepository.findById(documentoId)
                .orElseThrow(() -> new NotFoundException("Documento não encontrado"));
        if (!Objects.equals(documento.getAgendamento().getId(), agendamento.getId())) {
            throw new NotFoundException("Documento não pertence ao agendamento informado");
        }
        org.springframework.core.io.Resource resource = documentoStorageService.carregarComoResource(documento.getUrlDocumento());
        if (!resource.exists()) {
            throw new NotFoundException("Arquivo do documento não encontrado");
        }
        String contentType = documento.getContentType() != null ? documento.getContentType() : determinarContentType(resource);
        String filename = documento.getNomeArquivo() != null ? documento.getNomeArquivo() : documento.getTipoDocumento();
        return new DocumentoDownload(resource, filename, contentType);
    }

    @Transactional(readOnly = true)
    public List<DocumentoAgendamentoDTO> listarDocumentos(Long agendamentoId) {
        Agendamento agendamento = obterAgendamento(agendamentoId);
        return documentoAgendamentoRepository.findByAgendamentoId(agendamento.getId()).stream()
                .map(GateMapper::toDocumentoAgendamentoDTO)
                .collect(Collectors.toList());
    }

    private String sanitizarTexto(String valor) {
        if (!StringUtils.hasText(valor)) {
            return null;
        }
        String normalizado = Normalizer.normalize(valor, Normalizer.Form.NFKC);
        String semCaracteresPerigosos = normalizado.replaceAll("[<>\"'`]", "");
        return semCaracteresPerigosos.replaceAll("[\\p{Cntrl}&&[^\n\t\r]]", "").trim();
    }

    private String resolverTipoDocumento(DocumentoUploadRequest request, MultipartFile arquivo) {
        if (request != null && StringUtils.hasText(request.getTipoDocumento())) {
            return request.getTipoDocumento();
        }
        if (arquivo != null) {
            if (StringUtils.hasText(arquivo.getContentType())) {
                return arquivo.getContentType();
            }
            String originalFilename = arquivo.getOriginalFilename();
            if (StringUtils.hasText(originalFilename) && originalFilename.contains(".")) {
                String extensao = originalFilename.substring(originalFilename.lastIndexOf('.') + 1);
                return extensao.toUpperCase(Locale.ROOT);
            }
        }
        return "ARQUIVO";
    }

    private String determinarContentType(org.springframework.core.io.Resource resource) {
        try {
            if (resource.isFile()) {
                Path path = resource.getFile().toPath();
                return Files.probeContentType(path);
            }
        } catch (Exception ignored) {
        }
        return "application/octet-stream";
    }

    private void aplicarDados(Agendamento agendamento, AgendamentoRequest request, JanelaAtendimento janela) {
        agendamento.setCodigo(request.getCodigo());
        agendamento.setTipoOperacao(parseTipoOperacao(request.getTipoOperacao()));
        agendamento.setStatus(parseStatus(request.getStatus()));
        agendamento.setTransportadora(buscarTransportadora(request.getTransportadoraId()));
        agendamento.setMotorista(buscarMotorista(request.getMotoristaId()));
        agendamento.setVeiculo(buscarVeiculo(request.getVeiculoId()));
        agendamento.setJanelaAtendimento(janela);
        agendamento.setHorarioPrevistoChegada(request.getHorarioPrevistoChegada());
        agendamento.setHorarioPrevistoSaida(request.getHorarioPrevistoSaida());
        agendamento.setObservacoes(request.getObservacoes());
    }

    private void validarCodigoUnico(Long id, String codigo) {
        agendamentoRepository.findByCodigo(codigo).ifPresent(existing -> {
            if (id == null || !existing.getId().equals(id)) {
                throw new BusinessException("Código de agendamento já utilizado");
            }
        });
    }

    private void validarCapacidade(JanelaAtendimento janela, Long agendamentoId) {
        long ocupacao;
        if (agendamentoId == null) {
            ocupacao = agendamentoRepository.countByJanelaAtendimentoIdAndStatusNot(janela.getId(), StatusAgendamento.CANCELADO);
        } else {
            ocupacao = agendamentoRepository.countByJanelaAtendimentoIdAndStatusNotAndIdNot(janela.getId(), StatusAgendamento.CANCELADO, agendamentoId);
        }
        if (ocupacao >= janela.getCapacidade()) {
            throw new BusinessException("Capacidade da janela atingida");
        }
    }

    private void validarRegrasDeHorario(JanelaAtendimento janela, LocalDateTime horarioPrevistoChegada) {
        LocalDateTime inicioJanela = LocalDateTime.of(janela.getData(), janela.getHoraInicio());
        LocalDateTime limiteCriacao = inicioJanela.minus(rulesProperties.getAntecedenciaMinima());
        LocalDateTime limiteAtraso = inicioJanela.plus(rulesProperties.getAtrasoMaximo());
        LocalDateTime agora = LocalDateTime.now();
        if (agora.isAfter(limiteCriacao)) {
            throw new BusinessException("Agendamento deve ser criado com antecedência mínima de "
                    + rulesProperties.getAntecedenciaMinima().toHours() + " horas");
        }
        if (agora.isAfter(limiteAtraso)) {
            throw new BusinessException("Prazo para criação do agendamento expirou");
        }
        if (!horarioDentroDaJanela(janela, horarioPrevistoChegada)) {
            throw new BusinessException("Horário previsto de chegada deve estar dentro da janela de atendimento");
        }
    }

    private void validarIntervaloPrevisto(LocalDateTime chegada, LocalDateTime saida) {
        if (saida.isBefore(chegada) || saida.equals(chegada)) {
            throw new BusinessException("Horário previsto de saída deve ser posterior ao horário de chegada");
        }
    }

    private boolean horarioDentroDaJanela(JanelaAtendimento janela, LocalDateTime horario) {
        LocalDateTime inicio = LocalDateTime.of(janela.getData(), janela.getHoraInicio());
        LocalDateTime fim = LocalDateTime.of(janela.getData(), janela.getHoraFim());
        return (horario.isAfter(inicio) || horario.isEqual(inicio))
                && (horario.isBefore(fim) || horario.isEqual(fim));
    }

    private void validarEdicaoPermitida(Agendamento agendamento) {
        JanelaAtendimento janela = agendamento.getJanelaAtendimento();
        LocalDateTime inicio = LocalDateTime.of(janela.getData(), janela.getHoraInicio());
        LocalDateTime limiteAnterior = inicio.minus(rulesProperties.getEdicaoAntecedencia());
        LocalDateTime limitePosterior = inicio.plus(rulesProperties.getEdicaoAtraso());
        LocalDateTime agora = LocalDateTime.now();
        if (agora.isBefore(limiteAnterior) || agora.isAfter(limitePosterior)) {
            throw new BusinessException("Edição bloqueada para esta janela de atendimento");
        }
    }

    private Agendamento obterAgendamento(Long id) {
        return agendamentoRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Agendamento não encontrado"));
    }

    private JanelaAtendimento buscarJanela(Long id) {
        return janelaAtendimentoRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Janela de atendimento não encontrada"));
    }

    private Transportadora buscarTransportadora(Long id) {
        return transportadoraRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Transportadora não encontrada"));
    }

    private Motorista buscarMotorista(Long id) {
        return motoristaRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Motorista não encontrado"));
    }

    private Veiculo buscarVeiculo(Long id) {
        return veiculoRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Veículo não encontrado"));
    }

    private TipoOperacao parseTipoOperacao(String tipoOperacao) {
        try {
            String normalized = tipoOperacao.trim().toUpperCase(Locale.ROOT)
                    .replace('-', '_')
                    .replace(' ', '_');
            return TipoOperacao.valueOf(normalized);
        } catch (IllegalArgumentException ex) {
            throw new BusinessException("Tipo de operação inválido: " + tipoOperacao);
        }
    }

    private StatusAgendamento parseStatus(String status) {
        try {
            String normalized = status.trim().toUpperCase(Locale.ROOT)
                    .replace('-', '_')
                    .replace(' ', '_');
            return StatusAgendamento.valueOf(normalized);
        } catch (IllegalArgumentException ex) {
            throw new BusinessException("Status de agendamento inválido: " + status);
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\DocumentoAgendamentoRepository.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;

public interface DocumentoAgendamentoRepository extends JpaRepository<DocumentoAgendamento, Long> {

    List<DocumentoAgendamento> findByAgendamentoId(Long agendamentoId);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\DocumentoDownload.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import org.springframework.core.io.Resource;

public class DocumentoDownload {

    private final Resource resource;
    private final String filename;
    private final String contentType;

    public DocumentoDownload(Resource resource, String filename, String contentType) {
        this.resource = resource;
        this.filename = filename;
        this.contentType = contentType != null ? contentType : "application/octet-stream";
    }

    public Resource getResource() {
        return resource;
    }

    public String getFilename() {
        return filename;
    }

    public String getContentType() {
        return contentType;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\JanelaAtendimentoController.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.app.cidadao.dto.JanelaAtendimentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.JanelaAtendimentoRequest;
import br.com.cloudport.servicogate.app.cidadao.JanelaAtendimentoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import java.time.LocalDate;
import javax.validation.Valid;
import org.springdoc.api.annotations.ParameterObject;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/gate/janelas")
@Validated
@Tag(name = "Janelas de Atendimento", description = "Gerenciamento de janelas de atendimento")
public class JanelaAtendimentoController {

    private final JanelaAtendimentoService janelaAtendimentoService;

    public JanelaAtendimentoController(JanelaAtendimentoService janelaAtendimentoService) {
        this.janelaAtendimentoService = janelaAtendimentoService;
    }

    @GetMapping
    @Operation(summary = "Lista janelas de atendimento com filtros de período")
    public Page<JanelaAtendimentoDTO> listar(@Parameter(description = "Data inicial do período (inclusive)")
                                             @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
                                             @Parameter(description = "Data final do período (inclusive)")
                                             @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim,
                                             @ParameterObject Pageable pageable) {
        return janelaAtendimentoService.buscar(dataInicio, dataFim, pageable);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Obtém detalhes de uma janela de atendimento")
    public JanelaAtendimentoDTO buscarPorId(@PathVariable Long id) {
        return janelaAtendimentoService.buscarPorId(id);
    }

    @PostMapping
    @Operation(summary = "Cria uma nova janela de atendimento")
    public ResponseEntity<JanelaAtendimentoDTO> criar(@Valid @RequestBody JanelaAtendimentoRequest request) {
        JanelaAtendimentoDTO criado = janelaAtendimentoService.criar(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(criado);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Atualiza uma janela de atendimento")
    public JanelaAtendimentoDTO atualizar(@PathVariable Long id, @Valid @RequestBody JanelaAtendimentoRequest request) {
        return janelaAtendimentoService.atualizar(id, request);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Remove uma janela de atendimento")
    public ResponseEntity<Void> remover(@PathVariable Long id) {
        janelaAtendimentoService.remover(id);
        return ResponseEntity.noContent().build();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\JanelaAtendimentoRepository.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.model.JanelaAtendimento;
import java.time.LocalDate;
import java.util.List;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface JanelaAtendimentoRepository extends JpaRepository<JanelaAtendimento, Long> {

    List<JanelaAtendimento> findByDataOrderByHoraInicio(LocalDate data);

    Page<JanelaAtendimento> findByData(LocalDate data, Pageable pageable);

    Page<JanelaAtendimento> findByDataBetween(LocalDate inicio, LocalDate fim, Pageable pageable);

    Page<JanelaAtendimento> findByDataGreaterThanEqual(LocalDate inicio, Pageable pageable);

    Page<JanelaAtendimento> findByDataLessThanEqual(LocalDate fim, Pageable pageable);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\JanelaAtendimentoService.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.app.cidadao.dto.JanelaAtendimentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.JanelaAtendimentoRequest;
import br.com.cloudport.servicogate.app.cidadao.dto.mapper.GateMapper;
import br.com.cloudport.servicogate.exception.BusinessException;
import br.com.cloudport.servicogate.exception.NotFoundException;
import br.com.cloudport.servicogate.model.JanelaAtendimento;
import br.com.cloudport.servicogate.model.enums.CanalEntrada;
import br.com.cloudport.servicogate.app.cidadao.JanelaAtendimentoRepository;
import java.time.LocalDate;
import java.util.Locale;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class JanelaAtendimentoService {

    private final JanelaAtendimentoRepository janelaAtendimentoRepository;

    public JanelaAtendimentoService(JanelaAtendimentoRepository janelaAtendimentoRepository) {
        this.janelaAtendimentoRepository = janelaAtendimentoRepository;
    }

    @Transactional(readOnly = true)
    public Page<JanelaAtendimentoDTO> buscar(LocalDate dataInicio, LocalDate dataFim, Pageable pageable) {
        Page<JanelaAtendimento> page;
        if (dataInicio != null && dataFim != null) {
            page = janelaAtendimentoRepository.findByDataBetween(dataInicio, dataFim, pageable);
        } else if (dataInicio != null) {
            page = janelaAtendimentoRepository.findByDataGreaterThanEqual(dataInicio, pageable);
        } else if (dataFim != null) {
            page = janelaAtendimentoRepository.findByDataLessThanEqual(dataFim, pageable);
        } else {
            page = janelaAtendimentoRepository.findAll(pageable);
        }
        return page.map(GateMapper::toJanelaAtendimentoDTO);
    }

    @Transactional(readOnly = true)
    public JanelaAtendimentoDTO buscarPorId(Long id) {
        JanelaAtendimento janela = janelaAtendimentoRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Janela de atendimento não encontrada"));
        return GateMapper.toJanelaAtendimentoDTO(janela);
    }

    public JanelaAtendimentoDTO criar(JanelaAtendimentoRequest request) {
        validarIntervaloHorarios(request);
        JanelaAtendimento janela = new JanelaAtendimento();
        aplicarDados(janela, request);
        JanelaAtendimento salvo = janelaAtendimentoRepository.save(janela);
        return GateMapper.toJanelaAtendimentoDTO(salvo);
    }

    public JanelaAtendimentoDTO atualizar(Long id, JanelaAtendimentoRequest request) {
        validarIntervaloHorarios(request);
        JanelaAtendimento existente = janelaAtendimentoRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Janela de atendimento não encontrada"));
        aplicarDados(existente, request);
        JanelaAtendimento salvo = janelaAtendimentoRepository.save(existente);
        return GateMapper.toJanelaAtendimentoDTO(salvo);
    }

    public void remover(Long id) {
        JanelaAtendimento existente = janelaAtendimentoRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Janela de atendimento não encontrada"));
        janelaAtendimentoRepository.delete(existente);
    }

    private void validarIntervaloHorarios(JanelaAtendimentoRequest request) {
        if (request.getHoraFim().isBefore(request.getHoraInicio()) || request.getHoraFim().equals(request.getHoraInicio())) {
            throw new BusinessException("Hora fim deve ser posterior à hora início");
        }
    }

    private void aplicarDados(JanelaAtendimento janela, JanelaAtendimentoRequest request) {
        janela.setData(request.getData());
        janela.setHoraInicio(request.getHoraInicio());
        janela.setHoraFim(request.getHoraFim());
        janela.setCapacidade(request.getCapacidade());
        janela.setCanalEntrada(parseCanalEntrada(request.getCanalEntrada()));
    }

    private CanalEntrada parseCanalEntrada(String canal) {
        try {
            String normalized = canal.trim().toUpperCase(Locale.ROOT)
                    .replace('-', '_')
                    .replace(' ', '_');
            return CanalEntrada.valueOf(normalized);
        } catch (IllegalArgumentException ex) {
            throw new BusinessException("Canal de entrada inválido: " + canal);
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\LoggingNotificationGateway.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import java.time.Duration;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class LoggingNotificationGateway implements NotificationGateway {

    private static final Logger LOGGER = LoggerFactory.getLogger(LoggingNotificationGateway.class);

    @Override
    public void enviarStatusAtualizado(Agendamento agendamento) {
        LOGGER.info("event=gate.status.atualizado agendamento={} status={}",
                agendamento.getCodigo(), agendamento.getStatus());
    }

    @Override
    public void enviarJanelaProxima(Agendamento agendamento, Duration antecedencia) {
        LOGGER.info("event=gate.janela.proxima agendamento={} antecedenciaMinutos={}",
                agendamento.getCodigo(), antecedencia != null ? antecedencia.toMinutes() : null);
    }

    @Override
    public void enviarDocumentosRevalidados(Agendamento agendamento, List<DocumentoAgendamento> documentos) {
        LOGGER.info("event=gate.documentos.revalidados agendamento={} totalDocumentos={}",
                agendamento.getCodigo(), documentos != null ? documentos.size() : 0);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\MotoristaRepository.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.model.Motorista;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MotoristaRepository extends JpaRepository<Motorista, Long> {

    Optional<Motorista> findByDocumento(String documento);

    List<Motorista> findByTransportadoraIdOrderByNomeAsc(Long transportadoraId);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\NotificationGateway.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import java.time.Duration;
import java.util.List;

public interface NotificationGateway {

    void enviarStatusAtualizado(Agendamento agendamento);

    void enviarJanelaProxima(Agendamento agendamento, Duration antecedencia);

    void enviarDocumentosRevalidados(Agendamento agendamento, List<DocumentoAgendamento> documentos);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\VeiculoRepository.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.model.Veiculo;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface VeiculoRepository extends JpaRepository<Veiculo, Long> {

    Optional<Veiculo> findByPlaca(String placa);

    List<Veiculo> findByTransportadoraIdOrderByPlacaAsc(Long transportadoraId);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\centralacao\CentralAcaoAgendamentoController.java ----- 
package br.com.cloudport.servicogate.app.cidadao.centralacao;

import br.com.cloudport.servicogate.app.cidadao.centralacao.dto.CentralAcaoAgendamentoRespostaDTO;
import br.com.cloudport.servicogate.app.cidadao.centralacao.dto.VisaoCompletaAgendamentoDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.HttpHeaders;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/gate/agendamentos")
@Validated
@Tag(name = "Central de Ação", description = "Visão consolidada dos agendamentos para atuação rápida")
public class CentralAcaoAgendamentoController {

    private final CentralAcaoAgendamentoService centralAcaoAgendamentoService;

    public CentralAcaoAgendamentoController(CentralAcaoAgendamentoService centralAcaoAgendamentoService) {
        this.centralAcaoAgendamentoService = centralAcaoAgendamentoService;
    }

    @GetMapping("/visao-completa")
    @Operation(summary = "Lista cartões de ação dos agendamentos com dados consolidados")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE','TRANSPORTADORA')")
    public CentralAcaoAgendamentoRespostaDTO listarVisaoCompleta(
            @RequestHeader(value = HttpHeaders.AUTHORIZATION, required = false) String authorizationHeader) {
        return centralAcaoAgendamentoService.montarVisaoCompleta(authorizationHeader);
    }

    @GetMapping("/{id}/visao-completa")
    @Operation(summary = "Detalha um agendamento com visão consolidada para ação imediata")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE','TRANSPORTADORA')")
    public VisaoCompletaAgendamentoDTO buscarPorId(
            @PathVariable Long id,
            @RequestHeader(value = HttpHeaders.AUTHORIZATION, required = false) String authorizationHeader) {
        return centralAcaoAgendamentoService.montarVisaoPorId(id, authorizationHeader);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\centralacao\CentralAcaoAgendamentoService.java ----- 
package br.com.cloudport.servicogate.app.cidadao.centralacao;

import br.com.cloudport.servicogate.app.cidadao.AgendamentoService;
import br.com.cloudport.servicogate.app.cidadao.centralacao.dto.AcaoAgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.centralacao.dto.CentralAcaoAgendamentoRespostaDTO;
import br.com.cloudport.servicogate.app.cidadao.centralacao.dto.DocumentoPendenteDTO;
import br.com.cloudport.servicogate.app.cidadao.centralacao.dto.SituacaoPatioDTO;
import br.com.cloudport.servicogate.app.cidadao.centralacao.dto.UsuarioCentralAcaoDTO;
import br.com.cloudport.servicogate.app.cidadao.centralacao.dto.VisaoCompletaAgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.DocumentoAgendamentoDTO;
import br.com.cloudport.servicogate.integration.yard.ClienteStatusPatio;
import br.com.cloudport.servicogate.integration.yard.dto.StatusPatioResposta;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.security.AutenticacaoClient;
import br.com.cloudport.servicogate.security.UserInfoResponse;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.util.HtmlUtils;

@Service
public class CentralAcaoAgendamentoService {

    private static final DateTimeFormatter DATA_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE;
    private static final DateTimeFormatter HORA_FORMATTER = DateTimeFormatter.ISO_LOCAL_TIME;
    private static final DateTimeFormatter DATA_HORA_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    private static final int LIMITE_CARTOES = 20;

    private final AgendamentoService agendamentoService;
    private final AutenticacaoClient autenticacaoClient;
    private final ClienteStatusPatio clienteStatusPatio;

    public CentralAcaoAgendamentoService(AgendamentoService agendamentoService,
                                         AutenticacaoClient autenticacaoClient,
                                         ClienteStatusPatio clienteStatusPatio) {
        this.agendamentoService = agendamentoService;
        this.autenticacaoClient = autenticacaoClient;
        this.clienteStatusPatio = clienteStatusPatio;
    }

    public CentralAcaoAgendamentoRespostaDTO montarVisaoCompleta(String authorizationHeader) {
        Page<AgendamentoDTO> pagina = agendamentoService.buscar(null, null,
                PageRequest.of(0, LIMITE_CARTOES, Sort.by(Sort.Direction.ASC, "horarioPrevistoChegada")));

        Optional<StatusPatioResposta> situacaoPatio = clienteStatusPatio.consultarStatus(authorizationHeader);
        Optional<UserInfoResponse> usuarioAtual = buscarUsuarioAtual(authorizationHeader);

        List<VisaoCompletaAgendamentoDTO> visoes = pagina.getContent().stream()
                .sorted(Comparator.comparing((AgendamentoDTO dto) ->
                        Optional.ofNullable(dto.getHorarioPrevistoChegada()).orElse(LocalDateTime.MAX)))
                .map(dto -> montarVisao(dto, situacaoPatio.orElse(null)))
                .collect(Collectors.toList());

        CentralAcaoAgendamentoRespostaDTO resposta = new CentralAcaoAgendamentoRespostaDTO();
        resposta.setAgendamentos(visoes);
        usuarioAtual.map(this::converterUsuario).ifPresent(resposta::setUsuario);
        situacaoPatio.map(this::converterSituacaoPatio).ifPresent(resposta::setSituacaoPatio);
        return resposta;
    }

    public VisaoCompletaAgendamentoDTO montarVisaoPorId(Long id, String authorizationHeader) {
        AgendamentoDTO agendamento = agendamentoService.buscarPorId(id);
        Optional<StatusPatioResposta> situacaoPatio = clienteStatusPatio.consultarStatus(authorizationHeader);
        return montarVisao(agendamento, situacaoPatio.orElse(null));
    }

    private VisaoCompletaAgendamentoDTO montarVisao(AgendamentoDTO agendamento, StatusPatioResposta situacaoPatio) {
        if (agendamento == null) {
            return new VisaoCompletaAgendamentoDTO();
        }

        String codigoSanitizado = HtmlUtils.htmlEscape(agendamento.getCodigo());
        String statusSanitizado = HtmlUtils.htmlEscape(agendamento.getStatus());
        String statusDescricao = HtmlUtils.htmlEscape(agendamento.getStatusDescricao());
        String tipoOperacaoDescricao = HtmlUtils.htmlEscape(agendamento.getTipoOperacaoDescricao());
        String placaVeiculo = HtmlUtils.htmlEscape(agendamento.getPlacaVeiculo());
        String transportadoraNome = HtmlUtils.htmlEscape(agendamento.getTransportadoraNome());
        String motoristaNome = HtmlUtils.htmlEscape(agendamento.getMotoristaNome());

        AcaoAgendamentoDTO acao = definirAcaoPrincipal(agendamento);
        String mensagemOrientacao = construirMensagemOrientacao(agendamento, acao, situacaoPatio);

        VisaoCompletaAgendamentoDTO visao = new VisaoCompletaAgendamentoDTO();
        visao.setAgendamentoId(agendamento.getId());
        visao.setCodigo(codigoSanitizado);
        visao.setStatus(statusSanitizado);
        visao.setStatusDescricao(statusDescricao);
        visao.setTipoOperacaoDescricao(tipoOperacaoDescricao);
        visao.setHorarioPrevistoChegada(formatarDataHora(agendamento.getHorarioPrevistoChegada()));
        visao.setHorarioPrevistoSaida(formatarDataHora(agendamento.getHorarioPrevistoSaida()));
        visao.setPlacaVeiculo(placaVeiculo);
        visao.setTransportadoraNome(transportadoraNome);
        visao.setMotoristaNome(motoristaNome);
        visao.setJanelaData(formatarData(agendamento.getDataJanela()));
        visao.setJanelaHoraInicio(formatarHora(agendamento.getHoraInicioJanela()));
        visao.setJanelaHoraFim(formatarHora(agendamento.getHoraFimJanela()));
        visao.setMensagemOrientacao(HtmlUtils.htmlEscape(mensagemOrientacao));
        visao.setAcaoPrincipal(acao);
        visao.setDocumentosPendentes(mapearDocumentosPendentes(agendamento.getDocumentos()));
        return visao;
    }

    private List<DocumentoPendenteDTO> mapearDocumentosPendentes(List<DocumentoAgendamentoDTO> documentos) {
        if (documentos == null) {
            return Collections.emptyList();
        }
        return documentos.stream()
                .filter(Objects::nonNull)
                .filter(doc -> !"VALIDADO".equalsIgnoreCase(doc.getStatusValidacao()))
                .map(doc -> new DocumentoPendenteDTO(
                        doc.getId(),
                        HtmlUtils.htmlEscape(doc.getNomeArquivo()),
                        HtmlUtils.htmlEscape(doc.getTipoDocumento()),
                        HtmlUtils.htmlEscape(Objects.requireNonNullElse(doc.getMensagemValidacao(),
                                doc.getStatusValidacaoDescricao()))))
                .collect(Collectors.toList());
    }

    private String construirMensagemOrientacao(AgendamentoDTO agendamento,
                                                AcaoAgendamentoDTO acao,
                                                StatusPatioResposta situacaoPatio) {
        StringBuilder mensagem = new StringBuilder();
        String tituloAcao = null;
        if (acao != null && StringUtils.hasText(acao.getTitulo())) {
            tituloAcao = HtmlUtils.htmlUnescape(acao.getTitulo());
        }
        if (StringUtils.hasText(tituloAcao)) {
            mensagem.append("Próxima ação: ").append(tituloAcao);
        }
        if (agendamento.getHorarioPrevistoChegada() != null) {
            if (mensagem.length() > 0) {
                mensagem.append(" • ");
            }
            mensagem.append("Janela prevista às ")
                    .append(HORA_FORMATTER.format(agendamento.getHorarioPrevistoChegada().toLocalTime()));
        }
        if (situacaoPatio != null && StringUtils.hasText(situacaoPatio.getDescricao())) {
            if (mensagem.length() > 0) {
                mensagem.append(" • ");
            }
            mensagem.append("Pátio: ").append(situacaoPatio.getDescricao());
        }
        return mensagem.toString();
    }

    private AcaoAgendamentoDTO definirAcaoPrincipal(AgendamentoDTO agendamento) {
        StatusAgendamento status = interpretarStatus(agendamento.getStatus());
        if (status == null) {
            return null;
        }
        String rotaConfirmacao = String.format("/gate/agendamentos/%d/confirmar-chegada", agendamento.getId());
        switch (status) {
            case PENDENTE:
            case CONFIRMADO:
                return new AcaoAgendamentoDTO(
                        "CONFIRMAR_CHEGADA",
                        HtmlUtils.htmlEscape("Confirmar chegada"),
                        HtmlUtils.htmlEscape("Avise ao gate que você já está no local e aguarde liberação."),
                        "POST",
                        rotaConfirmacao,
                        true
                );
            case EM_ATENDIMENTO:
                return new AcaoAgendamentoDTO(
                        "AGUARDAR_LIBERACAO",
                        HtmlUtils.htmlEscape("Aguardar liberação"),
                        HtmlUtils.htmlEscape("Aguarde a atualização do status do gate pass pelo operador."),
                        "GET",
                        null,
                        false
                );
            case EM_EXECUCAO:
                return new AcaoAgendamentoDTO(
                        "ACOMPANHAR_OPERACAO",
                        HtmlUtils.htmlEscape("Acompanhar operação"),
                        HtmlUtils.htmlEscape("Siga as orientações no local até a conclusão do atendimento."),
                        "GET",
                        null,
                        false
                );
            default:
                return new AcaoAgendamentoDTO(
                        "FINALIZADO",
                        HtmlUtils.htmlEscape("Operação finalizada"),
                        HtmlUtils.htmlEscape("Revise os documentos e prepare-se para o próximo agendamento."),
                        "GET",
                        null,
                        false
                );
        }
    }

    private StatusAgendamento interpretarStatus(String status) {
        if (!StringUtils.hasText(status)) {
            return null;
        }
        try {
            return StatusAgendamento.valueOf(status.trim().toUpperCase(Locale.ROOT));
        } catch (IllegalArgumentException ex) {
            return null;
        }
    }

    private Optional<UserInfoResponse> buscarUsuarioAtual(String authorizationHeader) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication instanceof JwtAuthenticationToken) {
            JwtAuthenticationToken jwtAuthenticationToken = (JwtAuthenticationToken) authentication;
            Jwt token = jwtAuthenticationToken.getToken();
            String login = token.getSubject();
            if (StringUtils.hasText(login)) {
                return autenticacaoClient.buscarUsuario(login, authorizationHeader);
            }
        }
        return Optional.empty();
    }

    private UsuarioCentralAcaoDTO converterUsuario(UserInfoResponse response) {
        if (response == null) {
            return null;
        }
        return new UsuarioCentralAcaoDTO(
                HtmlUtils.htmlEscape(response.getLogin()),
                HtmlUtils.htmlEscape(response.getNome()),
                HtmlUtils.htmlEscape(response.getPerfil()),
                HtmlUtils.htmlEscape(response.getTransportadoraDocumento()),
                HtmlUtils.htmlEscape(response.getTransportadoraNome())
        );
    }

    private SituacaoPatioDTO converterSituacaoPatio(StatusPatioResposta resposta) {
        if (resposta == null) {
            return null;
        }
        return new SituacaoPatioDTO(
                HtmlUtils.htmlEscape(resposta.getStatus()),
                HtmlUtils.htmlEscape(resposta.getDescricao()),
                HtmlUtils.htmlEscape(resposta.getVerificadoEm())
        );
    }

    private String formatarData(LocalDate data) {
        return data != null ? DATA_FORMATTER.format(data) : null;
    }

    private String formatarHora(LocalTime hora) {
        return hora != null ? HORA_FORMATTER.format(hora) : null;
    }

    private String formatarDataHora(LocalDateTime dataHora) {
        return dataHora != null ? DATA_HORA_FORMATTER.format(dataHora) : null;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\centralacao\dto\AcaoAgendamentoDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.centralacao.dto;

public class AcaoAgendamentoDTO {

    private String codigo;
    private String titulo;
    private String descricao;
    private String metodoHttp;
    private String rotaApiRelativa;
    private boolean habilitada;

    public AcaoAgendamentoDTO() {
    }

    public AcaoAgendamentoDTO(String codigo,
                               String titulo,
                               String descricao,
                               String metodoHttp,
                               String rotaApiRelativa,
                               boolean habilitada) {
        this.codigo = codigo;
        this.titulo = titulo;
        this.descricao = descricao;
        this.metodoHttp = metodoHttp;
        this.rotaApiRelativa = rotaApiRelativa;
        this.habilitada = habilitada;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getTitulo() {
        return titulo;
    }

    public void setTitulo(String titulo) {
        this.titulo = titulo;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public String getMetodoHttp() {
        return metodoHttp;
    }

    public void setMetodoHttp(String metodoHttp) {
        this.metodoHttp = metodoHttp;
    }

    public String getRotaApiRelativa() {
        return rotaApiRelativa;
    }

    public void setRotaApiRelativa(String rotaApiRelativa) {
        this.rotaApiRelativa = rotaApiRelativa;
    }

    public boolean isHabilitada() {
        return habilitada;
    }

    public void setHabilitada(boolean habilitada) {
        this.habilitada = habilitada;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\centralacao\dto\CentralAcaoAgendamentoRespostaDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.centralacao.dto;

import java.util.ArrayList;
import java.util.List;

public class CentralAcaoAgendamentoRespostaDTO {

    private UsuarioCentralAcaoDTO usuario;
    private SituacaoPatioDTO situacaoPatio;
    private List<VisaoCompletaAgendamentoDTO> agendamentos = new ArrayList<>();

    public CentralAcaoAgendamentoRespostaDTO() {
    }

    public CentralAcaoAgendamentoRespostaDTO(UsuarioCentralAcaoDTO usuario,
                                             SituacaoPatioDTO situacaoPatio,
                                             List<VisaoCompletaAgendamentoDTO> agendamentos) {
        this.usuario = usuario;
        this.situacaoPatio = situacaoPatio;
        if (agendamentos != null) {
            this.agendamentos = agendamentos;
        }
    }

    public UsuarioCentralAcaoDTO getUsuario() {
        return usuario;
    }

    public void setUsuario(UsuarioCentralAcaoDTO usuario) {
        this.usuario = usuario;
    }

    public SituacaoPatioDTO getSituacaoPatio() {
        return situacaoPatio;
    }

    public void setSituacaoPatio(SituacaoPatioDTO situacaoPatio) {
        this.situacaoPatio = situacaoPatio;
    }

    public List<VisaoCompletaAgendamentoDTO> getAgendamentos() {
        return agendamentos;
    }

    public void setAgendamentos(List<VisaoCompletaAgendamentoDTO> agendamentos) {
        this.agendamentos = agendamentos != null ? agendamentos : new ArrayList<>();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\centralacao\dto\DocumentoPendenteDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.centralacao.dto;

public class DocumentoPendenteDTO {

    private Long id;
    private String nomeArquivo;
    private String tipoDocumento;
    private String mensagem;

    public DocumentoPendenteDTO() {
    }

    public DocumentoPendenteDTO(Long id, String nomeArquivo, String tipoDocumento, String mensagem) {
        this.id = id;
        this.nomeArquivo = nomeArquivo;
        this.tipoDocumento = tipoDocumento;
        this.mensagem = mensagem;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNomeArquivo() {
        return nomeArquivo;
    }

    public void setNomeArquivo(String nomeArquivo) {
        this.nomeArquivo = nomeArquivo;
    }

    public String getTipoDocumento() {
        return tipoDocumento;
    }

    public void setTipoDocumento(String tipoDocumento) {
        this.tipoDocumento = tipoDocumento;
    }

    public String getMensagem() {
        return mensagem;
    }

    public void setMensagem(String mensagem) {
        this.mensagem = mensagem;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\centralacao\dto\SituacaoPatioDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.centralacao.dto;

public class SituacaoPatioDTO {

    private String status;
    private String descricao;
    private String verificadoEm;

    public SituacaoPatioDTO() {
    }

    public SituacaoPatioDTO(String status, String descricao, String verificadoEm) {
        this.status = status;
        this.descricao = descricao;
        this.verificadoEm = verificadoEm;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public String getVerificadoEm() {
        return verificadoEm;
    }

    public void setVerificadoEm(String verificadoEm) {
        this.verificadoEm = verificadoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\centralacao\dto\UsuarioCentralAcaoDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.centralacao.dto;

public class UsuarioCentralAcaoDTO {

    private String login;
    private String nome;
    private String perfil;
    private String transportadoraDocumento;
    private String transportadoraNome;

    public UsuarioCentralAcaoDTO() {
    }

    public UsuarioCentralAcaoDTO(String login,
                                  String nome,
                                  String perfil,
                                  String transportadoraDocumento,
                                  String transportadoraNome) {
        this.login = login;
        this.nome = nome;
        this.perfil = perfil;
        this.transportadoraDocumento = transportadoraDocumento;
        this.transportadoraNome = transportadoraNome;
    }

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getPerfil() {
        return perfil;
    }

    public void setPerfil(String perfil) {
        this.perfil = perfil;
    }

    public String getTransportadoraDocumento() {
        return transportadoraDocumento;
    }

    public void setTransportadoraDocumento(String transportadoraDocumento) {
        this.transportadoraDocumento = transportadoraDocumento;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }

    public void setTransportadoraNome(String transportadoraNome) {
        this.transportadoraNome = transportadoraNome;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\centralacao\dto\VisaoCompletaAgendamentoDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.centralacao.dto;

import java.util.ArrayList;
import java.util.List;

public class VisaoCompletaAgendamentoDTO {

    private Long agendamentoId;
    private String codigo;
    private String status;
    private String statusDescricao;
    private String tipoOperacaoDescricao;
    private String horarioPrevistoChegada;
    private String horarioPrevistoSaida;
    private String placaVeiculo;
    private String transportadoraNome;
    private String motoristaNome;
    private String janelaData;
    private String janelaHoraInicio;
    private String janelaHoraFim;
    private String mensagemOrientacao;
    private AcaoAgendamentoDTO acaoPrincipal;
    private List<DocumentoPendenteDTO> documentosPendentes = new ArrayList<>();

    public VisaoCompletaAgendamentoDTO() {
    }

    public VisaoCompletaAgendamentoDTO(Long agendamentoId,
                                        String codigo,
                                        String status,
                                        String statusDescricao,
                                        String tipoOperacaoDescricao,
                                        String horarioPrevistoChegada,
                                        String horarioPrevistoSaida,
                                        String placaVeiculo,
                                        String transportadoraNome,
                                        String motoristaNome,
                                        String janelaData,
                                        String janelaHoraInicio,
                                        String janelaHoraFim,
                                        String mensagemOrientacao,
                                        AcaoAgendamentoDTO acaoPrincipal,
                                        List<DocumentoPendenteDTO> documentosPendentes) {
        this.agendamentoId = agendamentoId;
        this.codigo = codigo;
        this.status = status;
        this.statusDescricao = statusDescricao;
        this.tipoOperacaoDescricao = tipoOperacaoDescricao;
        this.horarioPrevistoChegada = horarioPrevistoChegada;
        this.horarioPrevistoSaida = horarioPrevistoSaida;
        this.placaVeiculo = placaVeiculo;
        this.transportadoraNome = transportadoraNome;
        this.motoristaNome = motoristaNome;
        this.janelaData = janelaData;
        this.janelaHoraInicio = janelaHoraInicio;
        this.janelaHoraFim = janelaHoraFim;
        this.mensagemOrientacao = mensagemOrientacao;
        this.acaoPrincipal = acaoPrincipal;
        if (documentosPendentes != null) {
            this.documentosPendentes = documentosPendentes;
        }
    }

    public Long getAgendamentoId() {
        return agendamentoId;
    }

    public void setAgendamentoId(Long agendamentoId) {
        this.agendamentoId = agendamentoId;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getStatusDescricao() {
        return statusDescricao;
    }

    public void setStatusDescricao(String statusDescricao) {
        this.statusDescricao = statusDescricao;
    }

    public String getTipoOperacaoDescricao() {
        return tipoOperacaoDescricao;
    }

    public void setTipoOperacaoDescricao(String tipoOperacaoDescricao) {
        this.tipoOperacaoDescricao = tipoOperacaoDescricao;
    }

    public String getHorarioPrevistoChegada() {
        return horarioPrevistoChegada;
    }

    public void setHorarioPrevistoChegada(String horarioPrevistoChegada) {
        this.horarioPrevistoChegada = horarioPrevistoChegada;
    }

    public String getHorarioPrevistoSaida() {
        return horarioPrevistoSaida;
    }

    public void setHorarioPrevistoSaida(String horarioPrevistoSaida) {
        this.horarioPrevistoSaida = horarioPrevistoSaida;
    }

    public String getPlacaVeiculo() {
        return placaVeiculo;
    }

    public void setPlacaVeiculo(String placaVeiculo) {
        this.placaVeiculo = placaVeiculo;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }

    public void setTransportadoraNome(String transportadoraNome) {
        this.transportadoraNome = transportadoraNome;
    }

    public String getMotoristaNome() {
        return motoristaNome;
    }

    public void setMotoristaNome(String motoristaNome) {
        this.motoristaNome = motoristaNome;
    }

    public String getJanelaData() {
        return janelaData;
    }

    public void setJanelaData(String janelaData) {
        this.janelaData = janelaData;
    }

    public String getJanelaHoraInicio() {
        return janelaHoraInicio;
    }

    public void setJanelaHoraInicio(String janelaHoraInicio) {
        this.janelaHoraInicio = janelaHoraInicio;
    }

    public String getJanelaHoraFim() {
        return janelaHoraFim;
    }

    public void setJanelaHoraFim(String janelaHoraFim) {
        this.janelaHoraFim = janelaHoraFim;
    }

    public String getMensagemOrientacao() {
        return mensagemOrientacao;
    }

    public void setMensagemOrientacao(String mensagemOrientacao) {
        this.mensagemOrientacao = mensagemOrientacao;
    }

    public AcaoAgendamentoDTO getAcaoPrincipal() {
        return acaoPrincipal;
    }

    public void setAcaoPrincipal(AcaoAgendamentoDTO acaoPrincipal) {
        this.acaoPrincipal = acaoPrincipal;
    }

    public List<DocumentoPendenteDTO> getDocumentosPendentes() {
        return documentosPendentes;
    }

    public void setDocumentosPendentes(List<DocumentoPendenteDTO> documentosPendentes) {
        this.documentosPendentes = documentosPendentes != null ? documentosPendentes : new ArrayList<>();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\AgendamentoDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

public class AgendamentoDTO {

    private Long id;
    private String codigo;
    private String tipoOperacao;
    private String tipoOperacaoDescricao;
    private String status;
    private String statusDescricao;
    private Long transportadoraId;
    private String transportadoraNome;
    private Long motoristaId;
    private String motoristaNome;
    private Long veiculoId;
    private String placaVeiculo;
    private Long janelaAtendimentoId;
    private LocalDate dataJanela;
    private LocalTime horaInicioJanela;
    private LocalTime horaFimJanela;
    private LocalDateTime horarioPrevistoChegada;
    private LocalDateTime horarioPrevistoSaida;
    private LocalDateTime horarioRealChegada;
    private LocalDateTime horarioRealSaida;
    private String observacoes;
    private List<DocumentoAgendamentoDTO> documentos;
    private GatePassDTO gatePass;

    public AgendamentoDTO() {
    }

    public AgendamentoDTO(Long id, String codigo, String tipoOperacao, String tipoOperacaoDescricao,
                           String status, String statusDescricao, Long transportadoraId,
                           String transportadoraNome, Long motoristaId, String motoristaNome,
                           Long veiculoId, String placaVeiculo, Long janelaAtendimentoId,
                           LocalDate dataJanela, LocalTime horaInicioJanela, LocalTime horaFimJanela,
                           LocalDateTime horarioPrevistoChegada, LocalDateTime horarioPrevistoSaida,
                           LocalDateTime horarioRealChegada, LocalDateTime horarioRealSaida,
                           String observacoes, List<DocumentoAgendamentoDTO> documentos,
                           GatePassDTO gatePass) {
        this.id = id;
        this.codigo = codigo;
        this.tipoOperacao = tipoOperacao;
        this.tipoOperacaoDescricao = tipoOperacaoDescricao;
        this.status = status;
        this.statusDescricao = statusDescricao;
        this.transportadoraId = transportadoraId;
        this.transportadoraNome = transportadoraNome;
        this.motoristaId = motoristaId;
        this.motoristaNome = motoristaNome;
        this.veiculoId = veiculoId;
        this.placaVeiculo = placaVeiculo;
        this.janelaAtendimentoId = janelaAtendimentoId;
        this.dataJanela = dataJanela;
        this.horaInicioJanela = horaInicioJanela;
        this.horaFimJanela = horaFimJanela;
        this.horarioPrevistoChegada = horarioPrevistoChegada;
        this.horarioPrevistoSaida = horarioPrevistoSaida;
        this.horarioRealChegada = horarioRealChegada;
        this.horarioRealSaida = horarioRealSaida;
        this.observacoes = observacoes;
        this.documentos = documentos;
        this.gatePass = gatePass;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getTipoOperacao() {
        return tipoOperacao;
    }

    public void setTipoOperacao(String tipoOperacao) {
        this.tipoOperacao = tipoOperacao;
    }

    public String getTipoOperacaoDescricao() {
        return tipoOperacaoDescricao;
    }

    public void setTipoOperacaoDescricao(String tipoOperacaoDescricao) {
        this.tipoOperacaoDescricao = tipoOperacaoDescricao;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getStatusDescricao() {
        return statusDescricao;
    }

    public void setStatusDescricao(String statusDescricao) {
        this.statusDescricao = statusDescricao;
    }

    public Long getTransportadoraId() {
        return transportadoraId;
    }

    public void setTransportadoraId(Long transportadoraId) {
        this.transportadoraId = transportadoraId;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }

    public void setTransportadoraNome(String transportadoraNome) {
        this.transportadoraNome = transportadoraNome;
    }

    public Long getMotoristaId() {
        return motoristaId;
    }

    public void setMotoristaId(Long motoristaId) {
        this.motoristaId = motoristaId;
    }

    public String getMotoristaNome() {
        return motoristaNome;
    }

    public void setMotoristaNome(String motoristaNome) {
        this.motoristaNome = motoristaNome;
    }

    public Long getVeiculoId() {
        return veiculoId;
    }

    public void setVeiculoId(Long veiculoId) {
        this.veiculoId = veiculoId;
    }

    public String getPlacaVeiculo() {
        return placaVeiculo;
    }

    public void setPlacaVeiculo(String placaVeiculo) {
        this.placaVeiculo = placaVeiculo;
    }

    public Long getJanelaAtendimentoId() {
        return janelaAtendimentoId;
    }

    public void setJanelaAtendimentoId(Long janelaAtendimentoId) {
        this.janelaAtendimentoId = janelaAtendimentoId;
    }

    public LocalDate getDataJanela() {
        return dataJanela;
    }

    public void setDataJanela(LocalDate dataJanela) {
        this.dataJanela = dataJanela;
    }

    public LocalTime getHoraInicioJanela() {
        return horaInicioJanela;
    }

    public void setHoraInicioJanela(LocalTime horaInicioJanela) {
        this.horaInicioJanela = horaInicioJanela;
    }

    public LocalTime getHoraFimJanela() {
        return horaFimJanela;
    }

    public void setHoraFimJanela(LocalTime horaFimJanela) {
        this.horaFimJanela = horaFimJanela;
    }

    public LocalDateTime getHorarioPrevistoChegada() {
        return horarioPrevistoChegada;
    }

    public void setHorarioPrevistoChegada(LocalDateTime horarioPrevistoChegada) {
        this.horarioPrevistoChegada = horarioPrevistoChegada;
    }

    public LocalDateTime getHorarioPrevistoSaida() {
        return horarioPrevistoSaida;
    }

    public void setHorarioPrevistoSaida(LocalDateTime horarioPrevistoSaida) {
        this.horarioPrevistoSaida = horarioPrevistoSaida;
    }

    public LocalDateTime getHorarioRealChegada() {
        return horarioRealChegada;
    }

    public void setHorarioRealChegada(LocalDateTime horarioRealChegada) {
        this.horarioRealChegada = horarioRealChegada;
    }

    public LocalDateTime getHorarioRealSaida() {
        return horarioRealSaida;
    }

    public void setHorarioRealSaida(LocalDateTime horarioRealSaida) {
        this.horarioRealSaida = horarioRealSaida;
    }

    public String getObservacoes() {
        return observacoes;
    }

    public void setObservacoes(String observacoes) {
        this.observacoes = observacoes;
    }

    public List<DocumentoAgendamentoDTO> getDocumentos() {
        return documentos;
    }

    public void setDocumentos(List<DocumentoAgendamentoDTO> documentos) {
        this.documentos = documentos;
    }

    public GatePassDTO getGatePass() {
        return gatePass;
    }

    public void setGatePass(GatePassDTO gatePass) {
        this.gatePass = gatePass;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\AgendamentoRequest.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

import java.time.LocalDateTime;
import javax.validation.constraints.Future;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class AgendamentoRequest {

    @NotBlank
    @Size(max = 40)
    private String codigo;

    @NotBlank
    private String tipoOperacao;

    @NotBlank
    private String status;

    @NotNull
    private Long transportadoraId;

    @NotNull
    private Long motoristaId;

    @NotNull
    private Long veiculoId;

    @NotNull
    private Long janelaAtendimentoId;

    @NotNull
    @Future(message = "Horário previsto de chegada deve estar no futuro")
    private LocalDateTime horarioPrevistoChegada;

    @NotNull
    @Future(message = "Horário previsto de saída deve estar no futuro")
    private LocalDateTime horarioPrevistoSaida;

    @Size(max = 500)
    private String observacoes;

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getTipoOperacao() {
        return tipoOperacao;
    }

    public void setTipoOperacao(String tipoOperacao) {
        this.tipoOperacao = tipoOperacao;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public Long getTransportadoraId() {
        return transportadoraId;
    }

    public void setTransportadoraId(Long transportadoraId) {
        this.transportadoraId = transportadoraId;
    }

    public Long getMotoristaId() {
        return motoristaId;
    }

    public void setMotoristaId(Long motoristaId) {
        this.motoristaId = motoristaId;
    }

    public Long getVeiculoId() {
        return veiculoId;
    }

    public void setVeiculoId(Long veiculoId) {
        this.veiculoId = veiculoId;
    }

    public Long getJanelaAtendimentoId() {
        return janelaAtendimentoId;
    }

    public void setJanelaAtendimentoId(Long janelaAtendimentoId) {
        this.janelaAtendimentoId = janelaAtendimentoId;
    }

    public LocalDateTime getHorarioPrevistoChegada() {
        return horarioPrevistoChegada;
    }

    public void setHorarioPrevistoChegada(LocalDateTime horarioPrevistoChegada) {
        this.horarioPrevistoChegada = horarioPrevistoChegada;
    }

    public LocalDateTime getHorarioPrevistoSaida() {
        return horarioPrevistoSaida;
    }

    public void setHorarioPrevistoSaida(LocalDateTime horarioPrevistoSaida) {
        this.horarioPrevistoSaida = horarioPrevistoSaida;
    }

    public String getObservacoes() {
        return observacoes;
    }

    public void setObservacoes(String observacoes) {
        this.observacoes = observacoes;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\DocumentoAgendamentoDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

import java.time.LocalDateTime;

public class DocumentoAgendamentoDTO {

    private Long id;
    private String tipoDocumento;
    private String numero;
    private String urlDocumento;
    private String nomeArquivo;
    private String contentType;
    private Long tamanhoBytes;
    private LocalDateTime ultimaRevalidacao;
    private String statusValidacao;
    private String statusValidacaoDescricao;
    private String mensagemValidacao;

    public DocumentoAgendamentoDTO() {
    }

    public DocumentoAgendamentoDTO(Long id, String tipoDocumento, String numero, String urlDocumento,
                                   String nomeArquivo, String contentType, Long tamanhoBytes,
                                   LocalDateTime ultimaRevalidacao, String statusValidacao,
                                   String statusValidacaoDescricao, String mensagemValidacao) {
        this.id = id;
        this.tipoDocumento = tipoDocumento;
        this.numero = numero;
        this.urlDocumento = urlDocumento;
        this.nomeArquivo = nomeArquivo;
        this.contentType = contentType;
        this.tamanhoBytes = tamanhoBytes;
        this.ultimaRevalidacao = ultimaRevalidacao;
        this.statusValidacao = statusValidacao;
        this.statusValidacaoDescricao = statusValidacaoDescricao;
        this.mensagemValidacao = mensagemValidacao;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTipoDocumento() {
        return tipoDocumento;
    }

    public void setTipoDocumento(String tipoDocumento) {
        this.tipoDocumento = tipoDocumento;
    }

    public String getNumero() {
        return numero;
    }

    public void setNumero(String numero) {
        this.numero = numero;
    }

    public String getUrlDocumento() {
        return urlDocumento;
    }

    public void setUrlDocumento(String urlDocumento) {
        this.urlDocumento = urlDocumento;
    }

    public String getNomeArquivo() {
        return nomeArquivo;
    }

    public void setNomeArquivo(String nomeArquivo) {
        this.nomeArquivo = nomeArquivo;
    }

    public String getContentType() {
        return contentType;
    }

    public void setContentType(String contentType) {
        this.contentType = contentType;
    }

    public Long getTamanhoBytes() {
        return tamanhoBytes;
    }

    public void setTamanhoBytes(Long tamanhoBytes) {
        this.tamanhoBytes = tamanhoBytes;
    }

    public LocalDateTime getUltimaRevalidacao() {
        return ultimaRevalidacao;
    }

    public void setUltimaRevalidacao(LocalDateTime ultimaRevalidacao) {
        this.ultimaRevalidacao = ultimaRevalidacao;
    }

    public String getStatusValidacao() {
        return statusValidacao;
    }

    public void setStatusValidacao(String statusValidacao) {
        this.statusValidacao = statusValidacao;
    }

    public String getStatusValidacaoDescricao() {
        return statusValidacaoDescricao;
    }

    public void setStatusValidacaoDescricao(String statusValidacaoDescricao) {
        this.statusValidacaoDescricao = statusValidacaoDescricao;
    }

    public String getMensagemValidacao() {
        return mensagemValidacao;
    }

    public void setMensagemValidacao(String mensagemValidacao) {
        this.mensagemValidacao = mensagemValidacao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\DocumentoUploadRequest.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public class DocumentoUploadRequest {

    @NotBlank
    @Size(max = 80)
    private String tipoDocumento;

    @Size(max = 80)
    private String numero;

    public String getTipoDocumento() {
        return tipoDocumento;
    }

    public void setTipoDocumento(String tipoDocumento) {
        this.tipoDocumento = tipoDocumento;
    }

    public String getNumero() {
        return numero;
    }

    public void setNumero(String numero) {
        this.numero = numero;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\JanelaAtendimentoDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

import java.time.LocalDate;
import java.time.LocalTime;

public class JanelaAtendimentoDTO {

    private Long id;
    private LocalDate data;
    private LocalTime horaInicio;
    private LocalTime horaFim;
    private Integer capacidade;
    private String canalEntrada;
    private String canalEntradaDescricao;

    public JanelaAtendimentoDTO() {
    }

    public JanelaAtendimentoDTO(Long id, LocalDate data, LocalTime horaInicio, LocalTime horaFim,
                                 Integer capacidade, String canalEntrada, String canalEntradaDescricao) {
        this.id = id;
        this.data = data;
        this.horaInicio = horaInicio;
        this.horaFim = horaFim;
        this.capacidade = capacidade;
        this.canalEntrada = canalEntrada;
        this.canalEntradaDescricao = canalEntradaDescricao;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public LocalDate getData() {
        return data;
    }

    public void setData(LocalDate data) {
        this.data = data;
    }

    public LocalTime getHoraInicio() {
        return horaInicio;
    }

    public void setHoraInicio(LocalTime horaInicio) {
        this.horaInicio = horaInicio;
    }

    public LocalTime getHoraFim() {
        return horaFim;
    }

    public void setHoraFim(LocalTime horaFim) {
        this.horaFim = horaFim;
    }

    public Integer getCapacidade() {
        return capacidade;
    }

    public void setCapacidade(Integer capacidade) {
        this.capacidade = capacidade;
    }

    public String getCanalEntrada() {
        return canalEntrada;
    }

    public void setCanalEntrada(String canalEntrada) {
        this.canalEntrada = canalEntrada;
    }

    public String getCanalEntradaDescricao() {
        return canalEntradaDescricao;
    }

    public void setCanalEntradaDescricao(String canalEntradaDescricao) {
        this.canalEntradaDescricao = canalEntradaDescricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\JanelaAtendimentoRequest.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

import java.time.LocalDate;
import java.time.LocalTime;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;

public class JanelaAtendimentoRequest {

    @NotNull
    private LocalDate data;

    @NotNull
    private LocalTime horaInicio;

    @NotNull
    private LocalTime horaFim;

    @NotNull
    @Min(1)
    private Integer capacidade;

    @NotBlank
    private String canalEntrada;

    public LocalDate getData() {
        return data;
    }

    public void setData(LocalDate data) {
        this.data = data;
    }

    public LocalTime getHoraInicio() {
        return horaInicio;
    }

    public void setHoraInicio(LocalTime horaInicio) {
        this.horaInicio = horaInicio;
    }

    public LocalTime getHoraFim() {
        return horaFim;
    }

    public void setHoraFim(LocalTime horaFim) {
        this.horaFim = horaFim;
    }

    public Integer getCapacidade() {
        return capacidade;
    }

    public void setCapacidade(Integer capacidade) {
        this.capacidade = capacidade;
    }

    public String getCanalEntrada() {
        return canalEntrada;
    }

    public void setCanalEntrada(String canalEntrada) {
        this.canalEntrada = canalEntrada;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\MotoristaDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

public class MotoristaDTO {

    private Long id;
    private String nome;
    private String documento;
    private String telefone;
    private Long transportadoraId;
    private String transportadoraNome;

    public MotoristaDTO() {
    }

    public MotoristaDTO(Long id, String nome, String documento, String telefone,
                         Long transportadoraId, String transportadoraNome) {
        this.id = id;
        this.nome = nome;
        this.documento = documento;
        this.telefone = telefone;
        this.transportadoraId = transportadoraId;
        this.transportadoraNome = transportadoraNome;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public String getTelefone() {
        return telefone;
    }

    public void setTelefone(String telefone) {
        this.telefone = telefone;
    }

    public Long getTransportadoraId() {
        return transportadoraId;
    }

    public void setTransportadoraId(Long transportadoraId) {
        this.transportadoraId = transportadoraId;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }

    public void setTransportadoraNome(String transportadoraNome) {
        this.transportadoraNome = transportadoraNome;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\TransportadoraDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

public class TransportadoraDTO {

    private Long id;
    private String nome;
    private String documento;
    private String contato;

    public TransportadoraDTO() {
    }

    public TransportadoraDTO(Long id, String nome, String documento, String contato) {
        this.id = id;
        this.nome = nome;
        this.documento = documento;
        this.contato = contato;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public String getContato() {
        return contato;
    }

    public void setContato(String contato) {
        this.contato = contato;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\cidadao\dto\VeiculoDTO.java ----- 
package br.com.cloudport.servicogate.app.cidadao.dto;

public class VeiculoDTO {

    private Long id;
    private String placa;
    private String modelo;
    private String tipo;
    private Long transportadoraId;
    private String transportadoraNome;

    public VeiculoDTO() {
    }

    public VeiculoDTO(Long id, String placa, String modelo, String tipo,
                       Long transportadoraId, String transportadoraNome) {
        this.id = id;
        this.placa = placa;
        this.modelo = modelo;
        this.tipo = tipo;
        this.transportadoraId = transportadoraId;
        this.transportadoraNome = transportadoraNome;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getPlaca() {
        return placa;
    }

    public void setPlaca(String placa) {
        this.placa = placa;
    }

    public String getModelo() {
        return modelo;
    }

    public void setModelo(String modelo) {
        this.modelo = modelo;
    }

    public String getTipo() {
        return tipo;
    }

    public void setTipo(String tipo) {
        this.tipo = tipo;
    }

    public Long getTransportadoraId() {
        return transportadoraId;
    }

    public void setTransportadoraId(Long transportadoraId) {
        this.transportadoraId = transportadoraId;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }

    public void setTransportadoraNome(String transportadoraNome) {
        this.transportadoraNome = transportadoraNome;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\configuracoes\ConfigController.java ----- 
package br.com.cloudport.servicogate.app.configuracoes;

import br.com.cloudport.servicogate.app.configuracoes.dto.EnumResponseDTO;
import br.com.cloudport.servicogate.model.enums.CanalEntrada;
import br.com.cloudport.servicogate.model.enums.MotivoExcecao;
import br.com.cloudport.servicogate.model.enums.NivelEvento;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import br.com.cloudport.servicogate.model.enums.TipoOcorrenciaOperador;
import br.com.cloudport.servicogate.app.configuracoes.TransportadoraRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.springframework.data.domain.Sort;
import org.springframework.http.CacheControl;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/gate/config")
@Tag(name = "Configurações", description = "Endpoints de configuração para combobox dinâmicas")
public class ConfigController {

    private static final CacheControl ENUM_CACHE = CacheControl.maxAge(Duration.ofHours(1)).cachePublic();

    private final TransportadoraRepository transportadoraRepository;

    public ConfigController(TransportadoraRepository transportadoraRepository) {
        this.transportadoraRepository = transportadoraRepository;
    }

    @GetMapping("/tipos-operacao")
    @Operation(summary = "Lista os tipos de operação disponíveis")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<EnumResponseDTO>> listarTiposOperacao() {
        return buildEnumResponse(TipoOperacao.values(), TipoOperacao::getDescricao);
    }

    @GetMapping("/status-agendamento")
    @Operation(summary = "Lista os status possíveis de um agendamento")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<EnumResponseDTO>> listarStatusAgendamento() {
        return buildEnumResponse(StatusAgendamento.values(), StatusAgendamento::getDescricao);
    }

    @GetMapping("/status-gate")
    @Operation(summary = "Lista os status disponíveis para um gate pass")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<EnumResponseDTO>> listarStatusGate() {
        return buildEnumResponse(StatusGate.values(), StatusGate::getDescricao);
    }

    @GetMapping("/motivos-excecao")
    @Operation(summary = "Lista os motivos de exceção configurados")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<EnumResponseDTO>> listarMotivosExcecao() {
        return buildEnumResponse(MotivoExcecao.values(), MotivoExcecao::getDescricao);
    }

    @GetMapping("/canais-entrada")
    @Operation(summary = "Lista os canais de entrada aceitos pela operação")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<EnumResponseDTO>> listarCanaisEntrada() {
        return buildEnumResponse(CanalEntrada.values(), CanalEntrada::getDescricao);
    }

    @GetMapping("/tipos-ocorrencia")
    @Operation(summary = "Lista os tipos de ocorrência disponíveis para o operador")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<EnumResponseDTO>> listarTiposOcorrencia() {
        return buildEnumResponse(TipoOcorrenciaOperador.values(), TipoOcorrenciaOperador::getDescricao);
    }

    @GetMapping("/niveis-evento")
    @Operation(summary = "Lista os níveis de eventos operacionais")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<EnumResponseDTO>> listarNiveisEvento() {
        return buildEnumResponse(NivelEvento.values(), NivelEvento::getDescricao);
    }

    @GetMapping("/transportadoras")
    @Operation(summary = "Lista transportadoras cadastradas para filtros analíticos")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<EnumResponseDTO>> listarTransportadoras() {
        List<EnumResponseDTO> body = transportadoraRepository.findAll(Sort.by(Sort.Direction.ASC, "nome")).stream()
                .map(transportadora -> new EnumResponseDTO(
                        transportadora.getId() != null ? transportadora.getId().toString() : null,
                        transportadora.getNome()))
                .collect(Collectors.toList());
        return ResponseEntity.ok()
                .cacheControl(ENUM_CACHE)
                .body(body);
    }

    private <E extends Enum<E>> ResponseEntity<List<EnumResponseDTO>> buildEnumResponse(E[] values,
                                                                                        Function<E, String> descricaoMapper) {
        List<EnumResponseDTO> body = Arrays.stream(values)
                .map(valor -> EnumResponseDTO.fromEnum(valor, descricaoMapper.apply(valor)))
                .collect(Collectors.toList());
        return ResponseEntity.ok()
                .cacheControl(ENUM_CACHE)
                .body(body);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\configuracoes\TransportadoraRepository.java ----- 
package br.com.cloudport.servicogate.app.configuracoes;

import br.com.cloudport.servicogate.model.Transportadora;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface TransportadoraRepository extends JpaRepository<Transportadora, Long> {

    Optional<Transportadora> findByDocumento(String documento);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\configuracoes\dto\EnumResponseDTO.java ----- 
package br.com.cloudport.servicogate.app.configuracoes.dto;

public class EnumResponseDTO {

    private String codigo;
    private String descricao;

    public EnumResponseDTO() {
    }

    public EnumResponseDTO(String codigo, String descricao) {
        this.codigo = codigo;
        this.descricao = descricao;
    }

    public static EnumResponseDTO fromEnum(Enum<?> valor, String descricao) {
        if (valor == null) {
            return new EnumResponseDTO(null, descricao);
        }
        return new EnumResponseDTO(valor.name(), descricao);
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateEventRepository.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.model.GateEvent;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;

public interface GateEventRepository extends JpaRepository<GateEvent, Long> {

    List<GateEvent> findByGatePassIdOrderByRegistradoEmAsc(Long gatePassId);

    List<GateEvent> findTop100ByOrderByRegistradoEmDesc();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateFlowController.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.app.gestor.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateDecisionDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateEventDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateFlowRequest;
import br.com.cloudport.servicogate.app.gestor.dto.ManualReleaseRequest;
import br.com.cloudport.servicogate.app.gestor.dto.TosSyncResponse;
import br.com.cloudport.servicogate.app.gestor.GateFlowService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import javax.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/gate")
@Tag(name = "Fluxo de Gate", description = "Processamento de eventos de entrada e saída do gate")
public class GateFlowController {

    private final GateFlowService gateFlowService;

    public GateFlowController(GateFlowService gateFlowService) {
        this.gateFlowService = gateFlowService;
    }

    @PostMapping("/entrada")
    @Operation(summary = "Processa um evento de entrada identificado por placa ou QR code")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE')")
    public ResponseEntity<GateDecisionDTO> registrarEntrada(@Valid @RequestBody GateFlowRequest request) {
        GateDecisionDTO decision = gateFlowService.registrarEntrada(request);
        return ResponseEntity.ok(decision);
    }

    @PostMapping("/saida")
    @Operation(summary = "Processa um evento de saída identificado por placa ou QR code")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE')")
    public ResponseEntity<GateDecisionDTO> registrarSaida(@Valid @RequestBody GateFlowRequest request) {
        GateDecisionDTO decision = gateFlowService.registrarSaida(request);
        return ResponseEntity.ok(decision);
    }

    @PostMapping("/agendamentos/{id}/liberacao-manual")
    @Operation(summary = "Registra liberação ou bloqueio manual para um agendamento")
    @PreAuthorize("hasRole('OPERADOR_GATE')")
    public ResponseEntity<GateEventDTO> liberarManual(@PathVariable("id") Long agendamentoId,
                                                      @Valid @RequestBody ManualReleaseRequest request) {
        GateEventDTO evento = gateFlowService.liberarManual(agendamentoId, request);
        return ResponseEntity.ok(evento);
    }

    @PostMapping("/agendamentos/{id}/sincronizar")
    @Operation(summary = "Força a ressincronização das informações do agendamento com o TOS")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE','PLANEJADOR')")
    public ResponseEntity<TosSyncResponse> sincronizar(@PathVariable("id") Long agendamentoId) {
        TosSyncResponse sincronizacao = gateFlowService.sincronizarAgendamento(agendamentoId);
        return ResponseEntity.ok(sincronizacao);
    }

    @PostMapping("/agendamentos/{id}/confirmar-chegada")
    @Operation(summary = "Confirma chegada antecipada do motorista antes da janela")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE','PLANEJADOR')")
    public ResponseEntity<AgendamentoDTO> confirmarChegada(@PathVariable("id") Long agendamentoId) {
        AgendamentoDTO atualizado = gateFlowService.confirmarChegadaAntecipada(agendamentoId);
        return ResponseEntity.ok(atualizado);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateFlowService.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.config.GateFlowProperties;
import br.com.cloudport.servicogate.app.gestor.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateDecisionDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateFlowRequest;
import br.com.cloudport.servicogate.app.gestor.dto.ManualReleaseAction;
import br.com.cloudport.servicogate.app.gestor.dto.ManualReleaseRequest;
import br.com.cloudport.servicogate.app.gestor.dto.TosContainerStatus;
import br.com.cloudport.servicogate.app.gestor.dto.TosSyncResponse;
import br.com.cloudport.servicogate.app.gestor.GateMapper;
import br.com.cloudport.servicogate.app.gestor.GateOperadorMapper;
import br.com.cloudport.servicogate.exception.BusinessException;
import br.com.cloudport.servicogate.exception.NotFoundException;
import br.com.cloudport.servicogate.integration.tos.TosIntegrationService;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import br.com.cloudport.servicogate.model.GateEvent;
import br.com.cloudport.servicogate.model.GatePass;
import br.com.cloudport.servicogate.model.enums.MotivoExcecao;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import br.com.cloudport.servicogate.monitoring.GateMetrics;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRepository;
import br.com.cloudport.servicogate.app.gestor.GateEventRepository;
import br.com.cloudport.servicogate.app.gestor.GatePassRepository;
import br.com.cloudport.servicogate.app.gestor.GateOperadorRealtimeService;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

@Service
@Transactional
public class GateFlowService {

    private static final Logger LOGGER = LoggerFactory.getLogger(GateFlowService.class);

    private static final EnumSet<StatusAgendamento> STATUS_VALIDOS_ENTRADA = EnumSet.of(
            StatusAgendamento.CONFIRMADO,
            StatusAgendamento.EM_ATENDIMENTO,
            StatusAgendamento.EM_EXECUCAO
    );

    private static final EnumSet<StatusAgendamento> STATUS_VALIDOS_SAIDA = EnumSet.of(
            StatusAgendamento.EM_EXECUCAO,
            StatusAgendamento.EM_ATENDIMENTO
    );

    private final AgendamentoRepository agendamentoRepository;
    private final GatePassRepository gatePassRepository;
    private final GateEventRepository gateEventRepository;
    private final GateFlowProperties flowProperties;
    private final TosIntegrationService tosIntegrationService;
    private final GateMetrics gateMetrics;
    private final AgendamentoRealtimeService agendamentoRealtimeService;
    private final GateOperadorRealtimeService gateOperadorRealtimeService;

    public GateFlowService(AgendamentoRepository agendamentoRepository,
                           GatePassRepository gatePassRepository,
                           GateEventRepository gateEventRepository,
                           GateFlowProperties flowProperties,
                           TosIntegrationService tosIntegrationService,
                              GateMetrics gateMetrics,
                              AgendamentoRealtimeService agendamentoRealtimeService,
                              GateOperadorRealtimeService gateOperadorRealtimeService) {
        this.agendamentoRepository = agendamentoRepository;
        this.gatePassRepository = gatePassRepository;
        this.gateEventRepository = gateEventRepository;
        this.flowProperties = flowProperties;
        this.tosIntegrationService = tosIntegrationService;
        this.gateMetrics = gateMetrics;
        this.agendamentoRealtimeService = agendamentoRealtimeService;
        this.gateOperadorRealtimeService = gateOperadorRealtimeService;
    }

    public GateDecisionDTO registrarEntrada(GateFlowRequest request) {
        LocalDateTime timestamp = resolverTimestamp(request.getTimestamp());
        Agendamento agendamento = localizarAgendamento(request);
        GatePass gatePass = obterOuCriarGatePass(agendamento);
        long inicioValidacao = System.nanoTime();
        boolean sucesso = false;
        try {
            TosContainerStatus statusContainer = tosIntegrationService.validarParaEntrada(agendamento);
            validarStatusParaEntrada(agendamento);
            validarDocumentos(agendamento);
            validarJanela(agendamento.getHorarioPrevistoChegada(), timestamp,
                    flowProperties.getToleranciaEntradaAntecipada(),
                    flowProperties.getToleranciaEntradaAtraso(),
                    "Horário de chegada fora da tolerância permitida");

            agendamento.setHorarioRealChegada(timestamp);
            agendamento.setStatus(StatusAgendamento.EM_EXECUCAO);
            gatePass.setDataEntrada(timestamp);
            gatePass.setStatus(StatusGate.EM_PROCESSAMENTO);

            gatePassRepository.save(gatePass);
            agendamentoRepository.save(agendamento);

            GateEvent evento = registrarEvento(gatePass, StatusGate.LIBERADO, null,
                    "Entrada autorizada", resolverOperador(request.getOperador()), timestamp);
            LOGGER.info("Entrada autorizada para agendamento {} containerStatus={} customsLiberado={}",
                    agendamento.getCodigo(),
                    statusContainer != null ? statusContainer.getStatus() : null,
                    statusContainer != null && statusContainer.isLiberacaoAduaneira());

            sucesso = true;
            agendamentoRealtimeService.notificarStatus(agendamento);
            return GateDecisionDTO.autorizado(evento.getStatus(), agendamento, gatePass,
                    "Entrada liberada com sucesso");
        } catch (RuntimeException ex) {
            registrarEvento(gatePass, StatusGate.RETIDO, null, ex.getMessage(),
                    resolverOperador(request.getOperador()), timestamp);
            throw ex;
        } finally {
            Duration duracao = Duration.ofNanos(System.nanoTime() - inicioValidacao);
            gateMetrics.registrarTempoValidacao(duracao, sucesso);
        }
    }

    public GateDecisionDTO registrarSaida(GateFlowRequest request) {
        LocalDateTime timestamp = resolverTimestamp(request.getTimestamp());
        Agendamento agendamento = localizarAgendamento(request);
        GatePass gatePass = obterOuCriarGatePass(agendamento);
        try {
            validarStatusParaSaida(agendamento, gatePass);
            validarJanela(agendamento.getHorarioPrevistoSaida(), timestamp,
                    flowProperties.getToleranciaSaidaAntecipada(),
                    flowProperties.getToleranciaSaidaAtraso(),
                    "Horário de saída fora da tolerância permitida");

            agendamento.setHorarioRealSaida(timestamp);
            gatePass.setDataSaida(timestamp);
            gatePass.setStatus(StatusGate.FINALIZADO);

            if (agendamento.getHorarioRealChegada() == null) {
                agendamento.setStatus(StatusAgendamento.NO_SHOW);
            } else {
                agendamento.setStatus(StatusAgendamento.COMPLETO);
            }

            gatePassRepository.save(gatePass);
            agendamentoRepository.save(agendamento);

            GateEvent evento = registrarEvento(gatePass, StatusGate.FINALIZADO, null,
                    "Saída registrada", resolverOperador(request.getOperador()), timestamp);
            LOGGER.info("Saída registrada para agendamento {}", agendamento.getCodigo());

            agendamentoRealtimeService.notificarStatus(agendamento);
            return GateDecisionDTO.autorizado(evento.getStatus(), agendamento, gatePass,
                    "Saída registrada e gate finalizado");
        } catch (RuntimeException ex) {
            registrarEvento(gatePass, StatusGate.RETIDO, null, ex.getMessage(),
                    resolverOperador(request.getOperador()), timestamp);
            throw ex;
        }
    }

    public GateEvent registrarBloqueioManual(Long agendamentoId, ManualReleaseRequest request) {
        validarPermissaoManual(request.getOperador());
        Agendamento agendamento = obterAgendamento(agendamentoId);
        GatePass gatePass = obterOuCriarGatePass(agendamento);
        gatePass.setStatus(StatusGate.RETIDO);
        gatePassRepository.save(gatePass);
        return registrarEvento(gatePass, StatusGate.RETIDO, parseMotivo(request.getMotivo()),
                request.getObservacao(), resolverOperador(request.getOperador()), LocalDateTime.now());
    }

    public GateEvent registrarLiberacaoManual(Long agendamentoId, ManualReleaseRequest request) {
        validarPermissaoManual(request.getOperador());
        Agendamento agendamento = obterAgendamento(agendamentoId);
        GatePass gatePass = obterOuCriarGatePass(agendamento);
        gatePass.setStatus(StatusGate.LIBERADO);
        gatePassRepository.save(gatePass);
        return registrarEvento(gatePass, StatusGate.LIBERADO, parseMotivo(request.getMotivo()),
                request.getObservacao(), resolverOperador(request.getOperador()), LocalDateTime.now());
    }

    public br.com.cloudport.servicogate.app.gestor.dto.GateEventDTO liberarManual(Long agendamentoId, ManualReleaseRequest request) {
        GateEvent evento;
        if (request.getAcao() == ManualReleaseAction.LIBERAR) {
            evento = registrarLiberacaoManual(agendamentoId, request);
        } else {
            evento = registrarBloqueioManual(agendamentoId, request);
        }
        return GateMapper.toGateEventDTO(evento);
    }

    public TosSyncResponse sincronizarAgendamento(Long agendamentoId) {
        Agendamento agendamento = obterAgendamento(agendamentoId);
        TosSyncResponse sincronizacao = tosIntegrationService.sincronizar(agendamento);
        LOGGER.info("Sincronização solicitada para agendamento {}", agendamento.getCodigo());
        agendamentoRealtimeService.notificarStatus(agendamento);
        return sincronizacao;
    }

    public AgendamentoDTO confirmarChegadaAntecipada(Long agendamentoId) {
        Agendamento agendamento = obterAgendamento(agendamentoId);
        if (EnumSet.of(StatusAgendamento.CANCELADO, StatusAgendamento.NO_SHOW, StatusAgendamento.COMPLETO)
                .contains(agendamento.getStatus())) {
            throw new BusinessException("Agendamento não permite confirmação antecipada no status atual");
        }
        if (agendamento.getStatus() == StatusAgendamento.EM_EXECUCAO) {
            return GateMapper.toAgendamentoDTO(agendamento);
        }
        GatePass gatePass = obterOuCriarGatePass(agendamento);
        agendamento.setStatus(StatusAgendamento.EM_ATENDIMENTO);
        gatePass.setStatus(StatusGate.AGUARDANDO_ENTRADA);

        gatePassRepository.save(gatePass);
        agendamentoRepository.save(agendamento);

        registrarEvento(gatePass, StatusGate.AGUARDANDO_ENTRADA, null,
                "Chegada antecipada confirmada", resolverOperador(null), LocalDateTime.now());
        agendamentoRealtimeService.notificarStatus(agendamento);
        agendamentoRealtimeService.verificarJanelaProxima(agendamento);
        return GateMapper.toAgendamentoDTO(agendamento);
    }

    private Agendamento localizarAgendamento(GateFlowRequest request) {
        if (StringUtils.hasText(request.getQrCode())) {
            return agendamentoRepository.findByCodigo(request.getQrCode().trim())
                    .orElseThrow(() -> new NotFoundException("Agendamento não encontrado para o QR code informado"));
        }
        if (StringUtils.hasText(request.getPlaca())) {
            List<StatusAgendamento> status = new ArrayList<>(STATUS_VALIDOS_ENTRADA);
            return agendamentoRepository.findFirstByVeiculoPlacaIgnoreCaseAndStatusInOrderByHorarioPrevistoChegadaAsc(
                            request.getPlaca().trim(), status)
                    .orElseThrow(() -> new NotFoundException("Agendamento não encontrado para a placa informada"));
        }
        throw new BusinessException("Informe a placa ou o QR code para processar o evento");
    }

    private GatePass obterOuCriarGatePass(Agendamento agendamento) {
        GatePass gatePass = gatePassRepository.findByAgendamentoId(agendamento.getId()).orElse(null);
        if (gatePass == null) {
            gatePass = new GatePass();
            gatePass.setAgendamento(agendamento);
            gatePass.setCodigo(gerarCodigoGatePass(agendamento));
            gatePass.setToken(gerarTokenGatePass());
            gatePass.setStatus(StatusGate.AGUARDANDO_ENTRADA);
            gatePass = gatePassRepository.save(gatePass);
            agendamento.setGatePass(gatePass);
        } else if (agendamento.getGatePass() == null) {
            agendamento.setGatePass(gatePass);
        }
        if (!StringUtils.hasText(gatePass.getToken())) {
            gatePass.setToken(gerarTokenGatePass());
        }
        return gatePass;
    }

    private String gerarCodigoGatePass(Agendamento agendamento) {
        return "GP-" + agendamento.getCodigo() + "-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase(Locale.ROOT);
    }

    private String gerarTokenGatePass() {
        return UUID.randomUUID().toString();
    }

    private void validarStatusParaEntrada(Agendamento agendamento) {
        if (!STATUS_VALIDOS_ENTRADA.contains(agendamento.getStatus())) {
            throw new BusinessException("Agendamento não está elegível para entrada");
        }
        if (agendamento.getStatus() == StatusAgendamento.CANCELADO) {
            throw new BusinessException("Agendamento cancelado não pode ingressar no site");
        }
    }

    private void validarStatusParaSaida(Agendamento agendamento, GatePass gatePass) {
        if (!STATUS_VALIDOS_SAIDA.contains(agendamento.getStatus())) {
            throw new BusinessException("Agendamento não está em execução para registrar a saída");
        }
        if (gatePass.getDataEntrada() == null) {
            throw new BusinessException("Não é possível registrar saída sem entrada registrada");
        }
    }

    private void validarDocumentos(Agendamento agendamento) {
        List<DocumentoAgendamento> documentos = agendamento.getDocumentos();
        if (CollectionUtils.isEmpty(documentos)) {
            throw new BusinessException("Agendamento sem documentação obrigatória");
        }
        boolean documentoInvalido = documentos.stream()
                .anyMatch(doc -> !StringUtils.hasText(doc.getUrlDocumento()));
        if (documentoInvalido) {
            throw new BusinessException("Documentação pendente de validação");
        }
    }

    private void validarJanela(LocalDateTime horarioPrevisto,
                               LocalDateTime timestamp,
                               Duration toleranciaAntecipada,
                               Duration toleranciaAtraso,
                               String mensagemErro) {
        if (horarioPrevisto == null) {
            return;
        }
        LocalDateTime inicio = horarioPrevisto.minus(toleranciaAntecipada != null ? toleranciaAntecipada : Duration.ZERO);
        LocalDateTime fim = horarioPrevisto.plus(toleranciaAtraso != null ? toleranciaAtraso : Duration.ZERO);
        if (timestamp.isBefore(inicio) || timestamp.isAfter(fim)) {
            throw new BusinessException(mensagemErro);
        }
    }

    private GateEvent registrarEvento(GatePass gatePass,
                                      StatusGate status,
                                      MotivoExcecao motivo,
                                      String observacao,
                                      String operador,
                                      LocalDateTime timestamp) {
        GateEvent event = new GateEvent();
        event.setGatePass(gatePass);
        event.setStatus(status);
        event.setMotivoExcecao(motivo);
        event.setObservacao(observacao);
        event.setUsuarioResponsavel(operador);
        event.setRegistradoEm(timestamp != null ? timestamp : LocalDateTime.now());
        GateEvent salvo = gateEventRepository.save(event);
        gatePass.getEventos().add(salvo);
        agendamentoRealtimeService.notificarGatePass(gatePass);
        gateOperadorRealtimeService.publicarEvento(GateOperadorMapper.toEventoDTO(salvo));
        return salvo;
    }

    private MotivoExcecao parseMotivo(String motivo) {
        if (!StringUtils.hasText(motivo)) {
            return null;
        }
        try {
            String normalized = motivo.trim().toUpperCase(Locale.ROOT)
                    .replace('-', '_')
                    .replace(' ', '_');
            return MotivoExcecao.valueOf(normalized);
        } catch (IllegalArgumentException ex) {
            throw new BusinessException("Motivo de exceção inválido: " + motivo);
        }
    }

    private Agendamento obterAgendamento(Long agendamentoId) {
        return agendamentoRepository.findById(agendamentoId)
                .orElseThrow(() -> new NotFoundException("Agendamento não encontrado"));
    }

    private void validarPermissaoManual(String operador) {
        List<String> roles = flowProperties.getRolesLiberacaoManual();
        if (CollectionUtils.isEmpty(roles)) {
            return;
        }
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null) {
            throw new BusinessException("Usuário não autorizado para liberação manual");
        }
        List<String> authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList());
        boolean permitido = authorities.stream()
                .map(authority -> authority != null ? authority.toUpperCase(Locale.ROOT) : null)
                .filter(Objects::nonNull)
                .anyMatch(auth -> roles.stream()
                        .map(role -> role != null ? role.toUpperCase(Locale.ROOT) : null)
                        .filter(Objects::nonNull)
                        .anyMatch(auth::equals));
        if (!permitido) {
            throw new BusinessException("Usuário não possui permissão para liberação manual");
        }
    }

    private LocalDateTime resolverTimestamp(LocalDateTime timestamp) {
        return timestamp != null ? timestamp : LocalDateTime.now();
    }

    private String resolverOperador(String operadorInformado) {
        if (StringUtils.hasText(operadorInformado)) {
            return operadorInformado.trim();
        }
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && StringUtils.hasText(authentication.getName())) {
            return authentication.getName();
        }
        return "sistema";
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateMapper.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.app.gestor.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.DocumentoAgendamentoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateEventDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GatePassDTO;
import br.com.cloudport.servicogate.app.gestor.dto.JanelaAtendimentoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.MotoristaDTO;
import br.com.cloudport.servicogate.app.gestor.dto.TransportadoraDTO;
import br.com.cloudport.servicogate.app.gestor.dto.VeiculoDTO;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import br.com.cloudport.servicogate.model.GateEvent;
import br.com.cloudport.servicogate.model.GatePass;
import br.com.cloudport.servicogate.model.JanelaAtendimento;
import br.com.cloudport.servicogate.model.Motorista;
import br.com.cloudport.servicogate.model.Transportadora;
import br.com.cloudport.servicogate.model.Veiculo;
import br.com.cloudport.servicogate.model.enums.CanalEntrada;
import br.com.cloudport.servicogate.model.enums.MotivoExcecao;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public final class GateMapper {

    private GateMapper() {
    }

    public static TransportadoraDTO toTransportadoraDTO(Transportadora entity) {
        if (entity == null) {
            return null;
        }
        return new TransportadoraDTO(entity.getId(), entity.getNome(), entity.getDocumento(), entity.getContato());
    }

    public static MotoristaDTO toMotoristaDTO(Motorista entity) {
        if (entity == null) {
            return null;
        }
        return new MotoristaDTO(
                entity.getId(),
                entity.getNome(),
                entity.getDocumento(),
                entity.getTelefone(),
                entity.getTransportadora() != null ? entity.getTransportadora().getId() : null,
                entity.getTransportadora() != null ? entity.getTransportadora().getNome() : null
        );
    }

    public static VeiculoDTO toVeiculoDTO(Veiculo entity) {
        if (entity == null) {
            return null;
        }
        return new VeiculoDTO(
                entity.getId(),
                entity.getPlaca(),
                entity.getModelo(),
                entity.getTipo(),
                entity.getTransportadora() != null ? entity.getTransportadora().getId() : null,
                entity.getTransportadora() != null ? entity.getTransportadora().getNome() : null
        );
    }

    public static JanelaAtendimentoDTO toJanelaAtendimentoDTO(JanelaAtendimento entity) {
        if (entity == null) {
            return null;
        }
        CanalEntrada canal = entity.getCanalEntrada();
        return new JanelaAtendimentoDTO(
                entity.getId(),
                entity.getData(),
                entity.getHoraInicio(),
                entity.getHoraFim(),
                entity.getCapacidade(),
                canal != null ? canal.name() : null,
                canal != null ? canal.getDescricao() : null
        );
    }

    public static DocumentoAgendamentoDTO toDocumentoAgendamentoDTO(DocumentoAgendamento entity) {
        if (entity == null) {
            return null;
        }
        return new DocumentoAgendamentoDTO(
                entity.getId(),
                entity.getTipoDocumento(),
                entity.getNumero(),
                entity.getUrlDocumento(),
                entity.getNomeArquivo(),
                entity.getContentType(),
                entity.getTamanhoBytes(),
                entity.getUltimaRevalidacao(),
                entity.getStatusValidacao() != null ? entity.getStatusValidacao().name() : null,
                entity.getStatusValidacao() != null ? entity.getStatusValidacao().getDescricao() : null,
                entity.getMensagemValidacao()
        );
    }

    public static GateEventDTO toGateEventDTO(GateEvent entity) {
        if (entity == null) {
            return null;
        }
        StatusGate statusGate = entity.getStatus();
        MotivoExcecao motivo = entity.getMotivoExcecao();
        return new GateEventDTO(
                entity.getId(),
                statusGate != null ? statusGate.name() : null,
                statusGate != null ? statusGate.getDescricao() : null,
                motivo != null ? motivo.name() : null,
                motivo != null ? motivo.getDescricao() : null,
                entity.getObservacao(),
                entity.getUsuarioResponsavel(),
                entity.getRegistradoEm()
        );
    }

    public static GatePassDTO toGatePassDTO(GatePass entity) {
        if (entity == null) {
            return null;
        }
        StatusGate statusGate = entity.getStatus();
        List<GateEventDTO> eventos = safeList(entity.getEventos()).stream()
                .map(GateMapper::toGateEventDTO)
                .collect(Collectors.toList());
        return new GatePassDTO(
                entity.getId(),
                entity.getCodigo(),
                statusGate != null ? statusGate.name() : null,
                statusGate != null ? statusGate.getDescricao() : null,
                entity.getDataEntrada(),
                entity.getDataSaida(),
                eventos,
                entity.getToken()
        );
    }

    public static AgendamentoDTO toAgendamentoDTO(Agendamento entity) {
        if (entity == null) {
            return null;
        }
        TipoOperacao tipoOperacao = entity.getTipoOperacao();
        StatusAgendamento statusAgendamento = entity.getStatus();
        JanelaAtendimento janela = entity.getJanelaAtendimento();
        return new AgendamentoDTO(
                entity.getId(),
                entity.getCodigo(),
                tipoOperacao != null ? tipoOperacao.name() : null,
                tipoOperacao != null ? tipoOperacao.getDescricao() : null,
                statusAgendamento != null ? statusAgendamento.name() : null,
                statusAgendamento != null ? statusAgendamento.getDescricao() : null,
                entity.getTransportadora() != null ? entity.getTransportadora().getId() : null,
                entity.getTransportadora() != null ? entity.getTransportadora().getNome() : null,
                entity.getMotorista() != null ? entity.getMotorista().getId() : null,
                entity.getMotorista() != null ? entity.getMotorista().getNome() : null,
                entity.getVeiculo() != null ? entity.getVeiculo().getId() : null,
                entity.getVeiculo() != null ? entity.getVeiculo().getPlaca() : null,
                janela != null ? janela.getId() : null,
                janela != null ? janela.getData() : null,
                janela != null ? janela.getHoraInicio() : null,
                janela != null ? janela.getHoraFim() : null,
                entity.getHorarioPrevistoChegada(),
                entity.getHorarioPrevistoSaida(),
                entity.getHorarioRealChegada(),
                entity.getHorarioRealSaida(),
                entity.getObservacoes(),
                safeList(entity.getDocumentos()).stream()
                        .map(GateMapper::toDocumentoAgendamentoDTO)
                        .collect(Collectors.toList()),
                toGatePassDTO(entity.getGatePass())
        );
    }

    private static <T> List<T> safeList(List<T> collection) {
        return collection == null ? Collections.emptyList() : collection;
    }

    public static List<TransportadoraDTO> toTransportadoraDTO(List<Transportadora> entities) {
        return safeStream(entities).map(GateMapper::toTransportadoraDTO).collect(Collectors.toList());
    }

    public static List<MotoristaDTO> toMotoristaDTO(List<Motorista> entities) {
        return safeStream(entities).map(GateMapper::toMotoristaDTO).collect(Collectors.toList());
    }

    public static List<VeiculoDTO> toVeiculoDTO(List<Veiculo> entities) {
        return safeStream(entities).map(GateMapper::toVeiculoDTO).collect(Collectors.toList());
    }

    public static List<DocumentoAgendamentoDTO> toDocumentoAgendamentoDTO(List<DocumentoAgendamento> entities) {
        return safeStream(entities).map(GateMapper::toDocumentoAgendamentoDTO).collect(Collectors.toList());
    }

    private static <T> java.util.stream.Stream<T> safeStream(List<T> collection) {
        return Objects.requireNonNullElse(collection, Collections.<T>emptyList()).stream();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateOcorrenciaRepository.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.model.GateOcorrencia;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;

public interface GateOcorrenciaRepository extends JpaRepository<GateOcorrencia, Long> {

    List<GateOcorrencia> findTop100ByOrderByRegistradoEmDesc();

    List<GateOcorrencia> findByVeiculoIdOrderByRegistradoEmDesc(Long veiculoId);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateOperadorController.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorBloqueioRequest;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorEventoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorLiberacaoRequest;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorOcorrenciaRequest;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorPainelDTO;
import br.com.cloudport.servicogate.app.gestor.GateOperadorOperacoesService;
import br.com.cloudport.servicogate.app.gestor.GateOperadorPainelService;
import br.com.cloudport.servicogate.app.gestor.GateOperadorRealtimeService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import java.util.List;
import javax.validation.Valid;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@RestController
@RequestMapping("/gate/operador")
@Tag(name = "Operador de Gate", description = "Painel operacional e ações de liberação/bloqueio do gate")
public class GateOperadorController {

    private final GateOperadorPainelService painelService;
    private final GateOperadorOperacoesService operacoesService;
    private final GateOperadorRealtimeService realtimeService;

    public GateOperadorController(GateOperadorPainelService painelService,
                                  GateOperadorOperacoesService operacoesService,
                                  GateOperadorRealtimeService realtimeService) {
        this.painelService = painelService;
        this.operacoesService = operacoesService;
        this.realtimeService = realtimeService;
    }

    @GetMapping("/painel")
    @Operation(summary = "Resumo atualizado do painel do operador do gate")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE','PLANEJADOR')")
    public GateOperadorPainelDTO obterPainel() {
        return painelService.montarPainel();
    }

    @GetMapping("/eventos")
    @Operation(summary = "Histórico recente de eventos operacionais do gate")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE','PLANEJADOR')")
    public List<GateOperadorEventoDTO> listarEventos() {
        return painelService.listarEventosRecentes(50);
    }

    @GetMapping(value = "/eventos/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    @Operation(summary = "Canal em tempo real para eventos do gate")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE','PLANEJADOR')")
    public SseEmitter streamEventos() {
        return realtimeService.registrar();
    }

    @PostMapping("/veiculos/{veiculoId}/liberacao")
    @Operation(summary = "Liberação manual de veículo", description = "Registra liberação manual com justificativa")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE')")
    public ResponseEntity<Void> liberarVeiculo(@PathVariable Long veiculoId,
                                               @Valid @RequestBody GateOperadorLiberacaoRequest request) {
        operacoesService.liberarVeiculo(veiculoId, request);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/veiculos/{veiculoId}/bloqueio")
    @Operation(summary = "Bloqueio manual de veículo", description = "Registra bloqueio temporário com motivo")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE')")
    public ResponseEntity<Void> bloquearVeiculo(@PathVariable Long veiculoId,
                                                @Valid @RequestBody GateOperadorBloqueioRequest request) {
        operacoesService.bloquearVeiculo(veiculoId, request);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/ocorrencias")
    @Operation(summary = "Registro de ocorrência operacional")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE','PLANEJADOR')")
    public ResponseEntity<Void> registrarOcorrencia(@Valid @RequestBody GateOperadorOcorrenciaRequest request) {
        operacoesService.registrarOcorrencia(request);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/veiculos/{veiculoId}/comprovante")
    @Operation(summary = "Gera comprovante textual do gate para o veículo informado")
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','OPERADOR_GATE','PLANEJADOR')")
    public ResponseEntity<ByteArrayResource> imprimirComprovante(@PathVariable Long veiculoId) {
        var comprovante = operacoesService.gerarComprovante(veiculoId);
        ByteArrayResource resource = new ByteArrayResource(comprovante.conteudo());
        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(comprovante.contentType()))
                .header(HttpHeaders.CONTENT_DISPOSITION,
                        "inline; filename=\"" + comprovante.nomeArquivo() + "\"")
                .body(resource);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateOperadorMapper.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorEventoDTO;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.GateEvent;
import br.com.cloudport.servicogate.model.GateOcorrencia;
import br.com.cloudport.servicogate.model.Transportadora;
import br.com.cloudport.servicogate.model.Veiculo;
import br.com.cloudport.servicogate.model.enums.NivelEvento;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import org.springframework.util.StringUtils;

public final class GateOperadorMapper {

    private GateOperadorMapper() {
    }

    public static GateOperadorEventoDTO toEventoDTO(GateEvent event) {
        if (event == null || event.getGatePass() == null || event.getGatePass().getAgendamento() == null) {
            return null;
        }
        Agendamento agendamento = event.getGatePass().getAgendamento();
        Veiculo veiculo = agendamento.getVeiculo();
        Transportadora transportadora = agendamento.getTransportadora();
        StatusGate statusGate = event.getStatus();
        String tipo = statusGate != null ? statusGate.getDescricao() : "Evento de gate";
        String descricao = StringUtils.hasText(event.getObservacao()) ? event.getObservacao() : tipo;
        NivelEvento nivel = nivelFromStatus(statusGate);
        return new GateOperadorEventoDTO(
                event.getId(),
                tipo,
                descricao,
                nivel.name(),
                event.getRegistradoEm(),
                veiculo != null ? veiculo.getId() : null,
                veiculo != null ? veiculo.getPlaca() : null,
                transportadora != null ? transportadora.getNome() : null,
                event.getUsuarioResponsavel()
        );
    }

    public static GateOperadorEventoDTO toEventoDTO(GateOcorrencia ocorrencia) {
        if (ocorrencia == null) {
            return null;
        }
        Veiculo veiculo = ocorrencia.getVeiculo();
        Transportadora transportadora = ocorrencia.getTransportadora();
        String tipo = ocorrencia.getTipo() != null ? ocorrencia.getTipo().getDescricao() : "Ocorrência";
        NivelEvento nivel = ocorrencia.getNivel() != null ? ocorrencia.getNivel() : NivelEvento.INFO;
        return new GateOperadorEventoDTO(
                ocorrencia.getId(),
                tipo,
                ocorrencia.getDescricao(),
                nivel.name(),
                ocorrencia.getRegistradoEm(),
                veiculo != null ? veiculo.getId() : null,
                veiculo != null ? veiculo.getPlaca() : null,
                transportadora != null ? transportadora.getNome() : null,
                ocorrencia.getUsuarioResponsavel()
        );
    }

    public static NivelEvento nivelFromStatus(StatusGate status) {
        if (status == null) {
            return NivelEvento.INFO;
        }
        return switch (status) {
            case RETIDO -> NivelEvento.CRITICA;
            case LIBERADO, FINALIZADO -> NivelEvento.INFO;
            case EM_PROCESSAMENTO, AGUARDANDO_ENTRADA -> NivelEvento.OPERACIONAL;
        };
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateOperadorOperacoesService.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.app.gestor.dto.ManualReleaseAction;
import br.com.cloudport.servicogate.app.gestor.dto.ManualReleaseRequest;
import br.com.cloudport.servicogate.app.gestor.GateOperadorMapper;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorBloqueioRequest;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorComprovanteDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorEventoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorLiberacaoRequest;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorOcorrenciaRequest;
import br.com.cloudport.servicogate.exception.NotFoundException;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.GateEvent;
import br.com.cloudport.servicogate.model.GateOcorrencia;
import br.com.cloudport.servicogate.model.Veiculo;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.TipoOcorrenciaOperador;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRepository;
import br.com.cloudport.servicogate.app.gestor.GateOcorrenciaRepository;
import br.com.cloudport.servicogate.app.cidadao.VeiculoRepository;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Locale;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

@Service
@Transactional
public class GateOperadorOperacoesService {

    private static final DateTimeFormatter DATA_HORA_FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");

    private final AgendamentoRepository agendamentoRepository;
    private final GateFlowService gateFlowService;
    private final GateOperadorRealtimeService realtimeService;
    private final GateOcorrenciaRepository gateOcorrenciaRepository;
    private final VeiculoRepository veiculoRepository;

    public GateOperadorOperacoesService(AgendamentoRepository agendamentoRepository,
                                        GateFlowService gateFlowService,
                                        GateOperadorRealtimeService realtimeService,
                                        GateOcorrenciaRepository gateOcorrenciaRepository,
                                        VeiculoRepository veiculoRepository) {
        this.agendamentoRepository = agendamentoRepository;
        this.gateFlowService = gateFlowService;
        this.realtimeService = realtimeService;
        this.gateOcorrenciaRepository = gateOcorrenciaRepository;
        this.veiculoRepository = veiculoRepository;
    }

    public void liberarVeiculo(Long veiculoId, GateOperadorLiberacaoRequest request) {
        Agendamento agendamento = localizarAgendamentoAtivo(veiculoId);
        ManualReleaseRequest manual = new ManualReleaseRequest();
        manual.setAcao(ManualReleaseAction.LIBERAR);
        manual.setObservacao(formatarJustificativaLiberacao(request));
        manual.setOperador(obterOperadorAtual());
        manual.setMotivo(null);
        GateEvent evento = gateFlowService.registrarLiberacaoManual(agendamento.getId(), manual);
        realtimeService.publicarEvento(GateOperadorMapper.toEventoDTO(evento));
    }

    public void bloquearVeiculo(Long veiculoId, GateOperadorBloqueioRequest request) {
        Agendamento agendamento = localizarAgendamentoAtivo(veiculoId);
        ManualReleaseRequest manual = new ManualReleaseRequest();
        manual.setAcao(ManualReleaseAction.BLOQUEAR);
        manual.setMotivo(request.motivoCodigo());
        manual.setObservacao(formatarJustificativaBloqueio(request));
        manual.setOperador(obterOperadorAtual());
        GateEvent evento = gateFlowService.registrarBloqueioManual(agendamento.getId(), manual);
        realtimeService.publicarEvento(GateOperadorMapper.toEventoDTO(evento));
    }

    public GateOperadorEventoDTO registrarOcorrencia(GateOperadorOcorrenciaRequest request) {
        TipoOcorrenciaOperador tipo;
        try {
            tipo = TipoOcorrenciaOperador.fromCodigo(request.tipoCodigo());
        } catch (IllegalArgumentException ex) {
            throw new NotFoundException("Tipo de ocorrência informado é inválido");
        }
        Veiculo veiculo = null;
        if (request.veiculoId() != null) {
            veiculo = veiculoRepository.findById(request.veiculoId())
                    .orElseThrow(() -> new NotFoundException("Veículo informado na ocorrência não foi encontrado"));
        }
        GateOcorrencia ocorrencia = new GateOcorrencia();
        ocorrencia.setTipo(tipo);
        ocorrencia.setNivel(tipo.getNivelPadrao());
        ocorrencia.setDescricao(request.descricao());
        ocorrencia.setRegistradoEm(LocalDateTime.now());
        ocorrencia.setUsuarioResponsavel(obterOperadorAtual());
        ocorrencia.setVeiculo(veiculo);
        ocorrencia.setTransportadora(veiculo != null ? veiculo.getTransportadora() : null);
        GateOcorrencia salvo = gateOcorrenciaRepository.save(ocorrencia);
        GateOperadorEventoDTO evento = GateOperadorMapper.toEventoDTO(salvo);
        realtimeService.publicarEvento(evento);
        return evento;
    }

    @Transactional(readOnly = true)
    public GateOperadorComprovanteDTO gerarComprovante(Long veiculoId) {
        Agendamento agendamento = localizarAgendamentoAtivo(veiculoId);
        StringBuilder builder = new StringBuilder();
        builder.append("Comprovante de Gate\n");
        builder.append("Emitido em: ").append(LocalDateTime.now().format(DATA_HORA_FORMATTER)).append('\n');
        builder.append("Agendamento: ").append(agendamento.getCodigo()).append('\n');
        builder.append("Status: ").append(agendamento.getStatus() != null ? agendamento.getStatus().getDescricao() : "").append('\n');
        if (agendamento.getTransportadora() != null) {
            builder.append("Transportadora: ").append(agendamento.getTransportadora().getNome()).append('\n');
        }
        if (agendamento.getMotorista() != null) {
            builder.append("Motorista: ").append(agendamento.getMotorista().getNome()).append('\n');
        }
        if (agendamento.getVeiculo() != null) {
            builder.append("Placa: ").append(agendamento.getVeiculo().getPlaca()).append('\n');
        }
        if (agendamento.getHorarioPrevistoChegada() != null) {
            builder.append("Chegada prevista: ")
                    .append(agendamento.getHorarioPrevistoChegada().format(DATA_HORA_FORMATTER))
                    .append('\n');
        }
        if (agendamento.getHorarioRealChegada() != null) {
            builder.append("Chegada registrada: ")
                    .append(agendamento.getHorarioRealChegada().format(DATA_HORA_FORMATTER))
                    .append('\n');
        }
        if (agendamento.getHorarioRealSaida() != null) {
            builder.append("Saída registrada: ")
                    .append(agendamento.getHorarioRealSaida().format(DATA_HORA_FORMATTER))
                    .append('\n');
        }
        builder.append("Operador responsável: ").append(obterOperadorAtual()).append('\n');

        byte[] conteudo = builder.toString().getBytes(StandardCharsets.UTF_8);
        String nomeArquivo = "comprovante-gate-" +
                (agendamento.getVeiculo() != null ? agendamento.getVeiculo().getPlaca() : "veiculo") + ".txt";
        return new GateOperadorComprovanteDTO(nomeArquivo, conteudo, "text/plain;charset=UTF-8");
    }

    private Agendamento localizarAgendamentoAtivo(Long veiculoId) {
        List<StatusAgendamento> status = List.of(
                StatusAgendamento.CONFIRMADO,
                StatusAgendamento.EM_ATENDIMENTO,
                StatusAgendamento.EM_EXECUCAO
        );
        return agendamentoRepository.findFirstByVeiculoIdAndStatusInOrderByHorarioPrevistoChegadaDesc(veiculoId, status)
                .orElseThrow(() -> new NotFoundException("Não foi encontrado agendamento ativo para o veículo informado"));
    }

    private String formatarJustificativaLiberacao(GateOperadorLiberacaoRequest request) {
        StringBuilder builder = new StringBuilder();
        builder.append(request.justificativa());
        if (StringUtils.hasText(request.canalEntrada())) {
            builder.append(" | Canal: ").append(request.canalEntrada());
        }
        if (Boolean.TRUE.equals(request.notificarTransportadora())) {
            builder.append(" | Transportadora notificada");
        }
        return builder.toString();
    }

    private String formatarJustificativaBloqueio(GateOperadorBloqueioRequest request) {
        StringBuilder builder = new StringBuilder();
        builder.append(request.justificativa());
        if (StringUtils.hasText(request.bloqueioAte())) {
            builder.append(" | Bloqueio até: ").append(request.bloqueioAte());
        }
        return builder.toString();
    }

    private String obterOperadorAtual() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !StringUtils.hasText(authentication.getName())) {
            return "SISTEMA";
        }
        return authentication.getName();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateOperadorPainelService.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.app.gestor.GateOperadorMapper;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorContatoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorEventoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorExcecaoDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorFilaDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorPainelDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorVeiculoDTO;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.GateEvent;
import br.com.cloudport.servicogate.model.JanelaAtendimento;
import br.com.cloudport.servicogate.model.Motorista;
import br.com.cloudport.servicogate.model.Transportadora;
import br.com.cloudport.servicogate.model.Veiculo;
import br.com.cloudport.servicogate.model.enums.CanalEntrada;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRepository;
import br.com.cloudport.servicogate.app.gestor.GateEventRepository;
import br.com.cloudport.servicogate.app.gestor.GateOcorrenciaRepository;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

@Service
@Transactional(readOnly = true)
public class GateOperadorPainelService {

    private static final int HISTORICO_LIMITE_PADRAO = 50;

    private final AgendamentoRepository agendamentoRepository;
    private final GateEventRepository gateEventRepository;
    private final GateOcorrenciaRepository gateOcorrenciaRepository;

    public GateOperadorPainelService(AgendamentoRepository agendamentoRepository,
                                     GateEventRepository gateEventRepository,
                                     GateOcorrenciaRepository gateOcorrenciaRepository) {
        this.agendamentoRepository = agendamentoRepository;
        this.gateEventRepository = gateEventRepository;
        this.gateOcorrenciaRepository = gateOcorrenciaRepository;
    }

    public GateOperadorPainelDTO montarPainel() {
        LocalDateTime agora = LocalDateTime.now();
        List<StatusAgendamento> statusConsiderados = List.of(
                StatusAgendamento.CONFIRMADO,
                StatusAgendamento.EM_ATENDIMENTO,
                StatusAgendamento.EM_EXECUCAO
        );
        List<Agendamento> agendamentos = agendamentoRepository
                .findByStatusInOrderByHorarioPrevistoChegadaAsc(statusConsiderados);

        List<GateOperadorVeiculoDTO> veiculosAtendimento = agendamentos.stream()
                .filter(agendamento -> agendamento.getStatus() == StatusAgendamento.EM_ATENDIMENTO)
                .map(agendamento -> toVeiculoDTO(agendamento,
                        calcularMinutos(agendamento.getHorarioRealChegada(), agora)))
                .collect(Collectors.toList());

        List<GateOperadorFilaDTO> filasEntrada = montarFilas(
                agendamentos.stream()
                        .filter(agendamento -> agendamento.getStatus() == StatusAgendamento.CONFIRMADO)
                        .collect(Collectors.toList()),
                true,
                agora
        );

        List<GateOperadorFilaDTO> filasSaida = montarFilas(
                agendamentos.stream()
                        .filter(agendamento -> agendamento.getStatus() == StatusAgendamento.EM_EXECUCAO)
                        .collect(Collectors.toList()),
                false,
                agora
        );

        List<GateOperadorEventoDTO> historico = listarEventosRecentes(HISTORICO_LIMITE_PADRAO);

        return new GateOperadorPainelDTO(
                filasEntrada,
                filasSaida,
                veiculosAtendimento,
                historico,
                agora
        );
    }

    public List<GateOperadorEventoDTO> listarEventosRecentes(int limite) {
        List<GateOperadorEventoDTO> eventosGate = gateEventRepository.findTop100ByOrderByRegistradoEmDesc()
                .stream()
                .map(GateOperadorMapper::toEventoDTO)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        List<GateOperadorEventoDTO> ocorrencias = gateOcorrenciaRepository.findTop100ByOrderByRegistradoEmDesc()
                .stream()
                .map(GateOperadorMapper::toEventoDTO)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        return Stream.concat(eventosGate.stream(), ocorrencias.stream())
                .sorted(Comparator.comparing(GateOperadorEventoDTO::registradoEm,
                        Comparator.nullsLast(Comparator.reverseOrder())))
                .limit(limite)
                .collect(Collectors.toList());
    }

    private List<GateOperadorFilaDTO> montarFilas(List<Agendamento> agendamentos,
                                                  boolean entrada,
                                                  LocalDateTime agora) {
        if (agendamentos.isEmpty()) {
            return Collections.emptyList();
        }
        Map<String, List<Agendamento>> agrupados = agendamentos.stream()
                .collect(Collectors.groupingBy(agendamento -> identificarFila(agendamento, entrada)));

        return agrupados.entrySet().stream()
                .map(entry -> {
                    List<GateOperadorVeiculoDTO> veiculos = entry.getValue().stream()
                            .map(agendamento -> toVeiculoDTO(agendamento, calcularTempoFila(agendamento, entrada, agora)))
                            .collect(Collectors.toList());
                    long media = veiculos.stream()
                            .map(GateOperadorVeiculoDTO::tempoFilaMinutos)
                            .filter(Objects::nonNull)
                            .mapToLong(Long::longValue)
                            .average()
                            .orElse(0);
                    String id = gerarIdentificadorFila(entry.getKey(), entrada);
                    return new GateOperadorFilaDTO(
                            id,
                            entry.getKey(),
                            veiculos.size(),
                            media > 0 ? Math.round(media) : 0L,
                            veiculos
                    );
                })
                .sorted(Comparator.comparing(GateOperadorFilaDTO::nome, String.CASE_INSENSITIVE_ORDER))
                .collect(Collectors.toList());
    }

    private String identificarFila(Agendamento agendamento, boolean entrada) {
        JanelaAtendimento janela = agendamento.getJanelaAtendimento();
        if (janela != null && janela.getCanalEntrada() != null) {
            String canal = janela.getCanalEntrada().getDescricao();
            if (janela.getHoraInicio() != null) {
                return canal + " - " + janela.getHoraInicio();
            }
            return canal;
        }
        Transportadora transportadora = agendamento.getTransportadora();
        if (!entrada && transportadora != null && StringUtils.hasText(transportadora.getNome())) {
            return transportadora.getNome();
        }
        return entrada ? "Fila de entrada" : "Fila de saída";
    }

    private String gerarIdentificadorFila(String nome, boolean entrada) {
        String base = StringUtils.hasText(nome) ? nome : (entrada ? "entrada" : "saida");
        return base.toLowerCase(Locale.ROOT).replaceAll("[^a-z0-9]+", "-");
    }

    private GateOperadorVeiculoDTO toVeiculoDTO(Agendamento agendamento, Long tempoFilaMinutos) {
        Veiculo veiculo = agendamento.getVeiculo();
        Transportadora transportadora = agendamento.getTransportadora();
        Motorista motorista = agendamento.getMotorista();
        JanelaAtendimento janela = agendamento.getJanelaAtendimento();
        CanalEntrada canal = janela != null ? janela.getCanalEntrada() : null;

        List<GateOperadorContatoDTO> contatos = montarContatos(motorista, transportadora);
        List<GateOperadorExcecaoDTO> excecoes = buscarExcecoes(agendamento);

        boolean podeImprimir = agendamento.getGatePass() != null &&
                StringUtils.hasText(agendamento.getGatePass().getToken());

        return new GateOperadorVeiculoDTO(
                veiculo != null ? veiculo.getId() : null,
                veiculo != null ? veiculo.getPlaca() : null,
                motorista != null ? motorista.getDocumento() : null,
                motorista != null ? motorista.getNome() : null,
                agendamento.getStatus() != null ? agendamento.getStatus().name() : null,
                agendamento.getStatus() != null ? agendamento.getStatus().getDescricao() : null,
                tempoFilaMinutos,
                canal != null ? canal.getDescricao() : null,
                transportadora != null ? transportadora.getNome() : null,
                contatos,
                excecoes,
                podeImprimir
        );
    }

    private Long calcularTempoFila(Agendamento agendamento, boolean entrada, LocalDateTime agora) {
        if (entrada) {
            return calcularMinutos(agendamento.getHorarioPrevistoChegada(), agora);
        }
        LocalDateTime referencia = Optional.ofNullable(agendamento.getHorarioRealChegada())
                .orElse(agendamento.getHorarioPrevistoChegada());
        return calcularMinutos(referencia, agora);
    }

    private Long calcularMinutos(LocalDateTime inicio, LocalDateTime fim) {
        if (inicio == null || fim == null) {
            return 0L;
        }
        long minutos = Duration.between(inicio, fim).toMinutes();
        return minutos < 0 ? 0L : minutos;
    }

    private List<GateOperadorContatoDTO> montarContatos(Motorista motorista, Transportadora transportadora) {
        List<GateOperadorContatoDTO> contatos = new ArrayList<>();
        if (motorista != null && StringUtils.hasText(motorista.getTelefone())) {
            contatos.add(new GateOperadorContatoDTO("TELEFONE", motorista.getTelefone(), "Motorista"));
        }
        if (transportadora != null && StringUtils.hasText(transportadora.getContato())) {
            String contato = transportadora.getContato();
            String tipo = contato.contains("@") ? "EMAIL" : "TELEFONE";
            contatos.add(new GateOperadorContatoDTO(tipo, contato, "Transportadora"));
        }
        return contatos;
    }

    private List<GateOperadorExcecaoDTO> buscarExcecoes(Agendamento agendamento) {
        if (agendamento.getGatePass() == null) {
            return Collections.emptyList();
        }
        return gateEventRepository.findByGatePassIdOrderByRegistradoEmAsc(agendamento.getGatePass().getId())
                .stream()
                .filter(evento -> evento.getMotivoExcecao() != null)
                .map(evento -> new GateOperadorExcecaoDTO(
                        evento.getMotivoExcecao().name(),
                        evento.getMotivoExcecao().getDescricao(),
                        GateOperadorMapper.nivelFromStatus(evento.getStatus()).name()
                ))
                .collect(Collectors.toList());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GateOperadorRealtimeService.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.app.gestor.dto.GateOperadorEventoDTO;
import java.io.IOException;
import java.time.Duration;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@Service
public class GateOperadorRealtimeService {

    private static final Logger LOGGER = LoggerFactory.getLogger(GateOperadorRealtimeService.class);
    private static final Duration TIMEOUT = Duration.ofMinutes(30);

    private final List<SseEmitter> emissores = new CopyOnWriteArrayList<>();

    public SseEmitter registrar() {
        SseEmitter emitter = new SseEmitter(TIMEOUT.toMillis());
        emissores.add(emitter);
        emitter.onCompletion(() -> remover(emitter));
        emitter.onTimeout(() -> remover(emitter));
        emitter.onError(throwable -> remover(emitter));
        return emitter;
    }

    public void publicarEvento(GateOperadorEventoDTO evento) {
        if (evento == null || emissores.isEmpty()) {
            return;
        }
        for (SseEmitter emitter : emissores) {
            try {
                emitter.send(evento);
            } catch (IOException ex) {
                LOGGER.debug("Falha ao enviar evento SSE do gate", ex);
                emitter.completeWithError(ex);
                emissores.remove(emitter);
            }
        }
    }

    private void remover(SseEmitter emitter) {
        emissores.remove(emitter);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\GatePassRepository.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.model.GatePass;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import br.com.cloudport.servicogate.app.transparencia.TempoMedioPermanenciaProjection;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface GatePassRepository extends JpaRepository<GatePass, Long> {

    Optional<GatePass> findByCodigo(String codigo);

    List<GatePass> findByStatus(StatusGate status);

    Optional<GatePass> findByAgendamentoId(Long agendamentoId);

    @Query(value = "SELECT DATE(gp.data_entrada) AS dia, " +
            "AVG(EXTRACT(EPOCH FROM (gp.data_saida - gp.data_entrada))/60) AS tempoMedioMinutos " +
            "FROM gate_pass gp " +
            "WHERE gp.data_entrada IS NOT NULL AND gp.data_saida IS NOT NULL " +
            "GROUP BY DATE(gp.data_entrada) " +
            "ORDER BY dia",
            nativeQuery = true)
    List<TempoMedioPermanenciaProjection> calcularTempoMedioPermanencia();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateDecisionDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.GatePass;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import com.fasterxml.jackson.annotation.JsonInclude;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class GateDecisionDTO {

    private boolean autorizado;
    private String statusGate;
    private String statusDescricao;
    private Long agendamentoId;
    private String codigoAgendamento;
    private Long gatePassId;
    private String codigoGatePass;
    private String mensagem;

    public static GateDecisionDTO autorizado(StatusGate status, Agendamento agendamento, GatePass gatePass,
                                             String mensagem) {
        GateDecisionDTO dto = new GateDecisionDTO();
        dto.setAutorizado(true);
        dto.preencherContexto(status, agendamento, gatePass);
        dto.setMensagem(mensagem);
        return dto;
    }

    public static GateDecisionDTO negado(StatusGate status, Agendamento agendamento, GatePass gatePass,
                                         String mensagem) {
        GateDecisionDTO dto = new GateDecisionDTO();
        dto.setAutorizado(false);
        dto.preencherContexto(status, agendamento, gatePass);
        dto.setMensagem(mensagem);
        return dto;
    }

    private void preencherContexto(StatusGate status, Agendamento agendamento, GatePass gatePass) {
        if (status != null) {
            this.statusGate = status.name();
            this.statusDescricao = status.getDescricao();
        }
        if (agendamento != null) {
            this.agendamentoId = agendamento.getId();
            this.codigoAgendamento = agendamento.getCodigo();
        }
        if (gatePass != null) {
            this.gatePassId = gatePass.getId();
            this.codigoGatePass = gatePass.getCodigo();
        }
    }

    public boolean isAutorizado() {
        return autorizado;
    }

    public void setAutorizado(boolean autorizado) {
        this.autorizado = autorizado;
    }

    public String getStatusGate() {
        return statusGate;
    }

    public void setStatusGate(String statusGate) {
        this.statusGate = statusGate;
    }

    public String getStatusDescricao() {
        return statusDescricao;
    }

    public void setStatusDescricao(String statusDescricao) {
        this.statusDescricao = statusDescricao;
    }

    public Long getAgendamentoId() {
        return agendamentoId;
    }

    public void setAgendamentoId(Long agendamentoId) {
        this.agendamentoId = agendamentoId;
    }

    public String getCodigoAgendamento() {
        return codigoAgendamento;
    }

    public void setCodigoAgendamento(String codigoAgendamento) {
        this.codigoAgendamento = codigoAgendamento;
    }

    public Long getGatePassId() {
        return gatePassId;
    }

    public void setGatePassId(Long gatePassId) {
        this.gatePassId = gatePassId;
    }

    public String getCodigoGatePass() {
        return codigoGatePass;
    }

    public void setCodigoGatePass(String codigoGatePass) {
        this.codigoGatePass = codigoGatePass;
    }

    public String getMensagem() {
        return mensagem;
    }

    public void setMensagem(String mensagem) {
        this.mensagem = mensagem;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateEventDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import java.time.LocalDateTime;

public class GateEventDTO {

    private Long id;
    private String status;
    private String statusDescricao;
    private String motivoExcecao;
    private String motivoExcecaoDescricao;
    private String observacao;
    private String usuarioResponsavel;
    private LocalDateTime registradoEm;

    public GateEventDTO() {
    }

    public GateEventDTO(Long id, String status, String statusDescricao, String motivoExcecao,
                         String motivoExcecaoDescricao, String observacao, String usuarioResponsavel,
                         LocalDateTime registradoEm) {
        this.id = id;
        this.status = status;
        this.statusDescricao = statusDescricao;
        this.motivoExcecao = motivoExcecao;
        this.motivoExcecaoDescricao = motivoExcecaoDescricao;
        this.observacao = observacao;
        this.usuarioResponsavel = usuarioResponsavel;
        this.registradoEm = registradoEm;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getStatusDescricao() {
        return statusDescricao;
    }

    public void setStatusDescricao(String statusDescricao) {
        this.statusDescricao = statusDescricao;
    }

    public String getMotivoExcecao() {
        return motivoExcecao;
    }

    public void setMotivoExcecao(String motivoExcecao) {
        this.motivoExcecao = motivoExcecao;
    }

    public String getMotivoExcecaoDescricao() {
        return motivoExcecaoDescricao;
    }

    public void setMotivoExcecaoDescricao(String motivoExcecaoDescricao) {
        this.motivoExcecaoDescricao = motivoExcecaoDescricao;
    }

    public String getObservacao() {
        return observacao;
    }

    public void setObservacao(String observacao) {
        this.observacao = observacao;
    }

    public String getUsuarioResponsavel() {
        return usuarioResponsavel;
    }

    public void setUsuarioResponsavel(String usuarioResponsavel) {
        this.usuarioResponsavel = usuarioResponsavel;
    }

    public LocalDateTime getRegistradoEm() {
        return registradoEm;
    }

    public void setRegistradoEm(LocalDateTime registradoEm) {
        this.registradoEm = registradoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateFlowRequest.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;
import javax.validation.constraints.Size;

public class GateFlowRequest {

    @Size(max = 10)
    private String placa;

    @Size(max = 120)
    private String qrCode;

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime timestamp;

    @Size(max = 80)
    private String operador;

    public String getPlaca() {
        return placa;
    }

    public void setPlaca(String placa) {
        this.placa = placa;
    }

    public String getQrCode() {
        return qrCode;
    }

    public void setQrCode(String qrCode) {
        this.qrCode = qrCode;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getOperador() {
        return operador;
    }

    public void setOperador(String operador) {
        this.operador = operador;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorBloqueioRequest.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public record GateOperadorBloqueioRequest(@NotBlank @Size(max = 40) String motivoCodigo,
                                          @NotBlank @Size(max = 500) String justificativa,
                                          @Size(max = 40) String bloqueioAte) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorComprovanteDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

public record GateOperadorComprovanteDTO(String nomeArquivo, byte[] conteudo, String contentType) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorContatoDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

public record GateOperadorContatoDTO(String tipo, String valor, String descricao) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorEventoDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import java.time.LocalDateTime;

public record GateOperadorEventoDTO(Long id,
                                    String tipo,
                                    String descricao,
                                    String nivel,
                                    LocalDateTime registradoEm,
                                    Long veiculoId,
                                    String placaVeiculo,
                                    String transportadora,
                                    String usuario) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorExcecaoDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

public record GateOperadorExcecaoDTO(String codigo, String descricao, String nivel) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorFilaDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import java.util.List;

public record GateOperadorFilaDTO(String id,
                                  String nome,
                                  Integer quantidade,
                                  Long tempoMedioEsperaMinutos,
                                  List<GateOperadorVeiculoDTO> veiculos) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorLiberacaoRequest.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public record GateOperadorLiberacaoRequest(@NotBlank @Size(max = 40) String canalEntrada,
                                           @NotBlank @Size(max = 500) String justificativa,
                                           Boolean notificarTransportadora) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorOcorrenciaRequest.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public record GateOperadorOcorrenciaRequest(@NotBlank @Size(max = 40) String tipoCodigo,
                                            @NotBlank @Size(max = 500) String descricao,
                                            Long veiculoId) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorPainelDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import java.time.LocalDateTime;
import java.util.List;

public record GateOperadorPainelDTO(List<GateOperadorFilaDTO> filasEntrada,
                                    List<GateOperadorFilaDTO> filasSaida,
                                    List<GateOperadorVeiculoDTO> veiculosAtendimento,
                                    List<GateOperadorEventoDTO> historico,
                                    LocalDateTime ultimaAtualizacao) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GateOperadorVeiculoDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import java.util.List;

public record GateOperadorVeiculoDTO(Long id,
                                     String placa,
                                     String documento,
                                     String motorista,
                                     String status,
                                     String statusDescricao,
                                     Long tempoFilaMinutos,
                                     String canalEntrada,
                                     String transportadora,
                                     List<GateOperadorContatoDTO> contatos,
                                     List<GateOperadorExcecaoDTO> excecoes,
                                     boolean podeImprimirComprovante) {
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\GatePassDTO.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import java.time.LocalDateTime;
import java.util.List;

public class GatePassDTO {

    private Long id;
    private String codigo;
    private String status;
    private String statusDescricao;
    private LocalDateTime dataEntrada;
    private LocalDateTime dataSaida;
    private List<GateEventDTO> eventos;
    private String token;

    public GatePassDTO() {
    }

    public GatePassDTO(Long id, String codigo, String status, String statusDescricao,
                       LocalDateTime dataEntrada, LocalDateTime dataSaida, List<GateEventDTO> eventos,
                       String token) {
        this.id = id;
        this.codigo = codigo;
        this.status = status;
        this.statusDescricao = statusDescricao;
        this.dataEntrada = dataEntrada;
        this.dataSaida = dataSaida;
        this.eventos = eventos;
        this.token = token;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getStatusDescricao() {
        return statusDescricao;
    }

    public void setStatusDescricao(String statusDescricao) {
        this.statusDescricao = statusDescricao;
    }

    public LocalDateTime getDataEntrada() {
        return dataEntrada;
    }

    public void setDataEntrada(LocalDateTime dataEntrada) {
        this.dataEntrada = dataEntrada;
    }

    public LocalDateTime getDataSaida() {
        return dataSaida;
    }

    public void setDataSaida(LocalDateTime dataSaida) {
        this.dataSaida = dataSaida;
    }

    public List<GateEventDTO> getEventos() {
        return eventos;
    }

    public void setEventos(List<GateEventDTO> eventos) {
        this.eventos = eventos;
    }

    public String getToken() {
        return token;
    }

    public void setToken(String token) {
        this.token = token;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\ManualReleaseAction.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

public enum ManualReleaseAction {
    LIBERAR,
    BLOQUEAR
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\ManualReleaseRequest.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class ManualReleaseRequest {

    @NotNull
    private ManualReleaseAction acao;

    @Size(max = 40)
    private String motivo;

    @Size(max = 500)
    private String observacao;

    @Size(max = 80)
    private String operador;

    public ManualReleaseAction getAcao() {
        return acao;
    }

    public void setAcao(ManualReleaseAction acao) {
        this.acao = acao;
    }

    public String getMotivo() {
        return motivo;
    }

    public void setMotivo(String motivo) {
        this.motivo = motivo;
    }

    public String getObservacao() {
        return observacao;
    }

    public void setObservacao(String observacao) {
        this.observacao = observacao;
    }

    public String getOperador() {
        return operador;
    }

    public void setOperador(String operador) {
        this.operador = operador;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\TosBookingInfo.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import java.time.LocalDateTime;

public class TosBookingInfo {

    private final String bookingNumber;
    private final String vessel;
    private final String voyage;
    private final LocalDateTime cutoff;
    private final boolean liberado;
    private final String motivoRestricao;

    public TosBookingInfo(String bookingNumber,
                          String vessel,
                          String voyage,
                          LocalDateTime cutoff,
                          boolean liberado,
                          String motivoRestricao) {
        this.bookingNumber = bookingNumber;
        this.vessel = vessel;
        this.voyage = voyage;
        this.cutoff = cutoff;
        this.liberado = liberado;
        this.motivoRestricao = motivoRestricao;
    }

    public String getBookingNumber() {
        return bookingNumber;
    }

    public String getVessel() {
        return vessel;
    }

    public String getVoyage() {
        return voyage;
    }

    public LocalDateTime getCutoff() {
        return cutoff;
    }

    public boolean isLiberado() {
        return liberado;
    }

    public String getMotivoRestricao() {
        return motivoRestricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\TosContainerStatus.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

import java.time.LocalDateTime;

public class TosContainerStatus {

    private final String containerNumber;
    private final String status;
    private final boolean gateLiberado;
    private final boolean liberacaoAduaneira;
    private final LocalDateTime ultimaAtualizacao;
    private final String motivoRestricao;

    public TosContainerStatus(String containerNumber,
                              String status,
                              boolean gateLiberado,
                              boolean liberacaoAduaneira,
                              LocalDateTime ultimaAtualizacao,
                              String motivoRestricao) {
        this.containerNumber = containerNumber;
        this.status = status;
        this.gateLiberado = gateLiberado;
        this.liberacaoAduaneira = liberacaoAduaneira;
        this.ultimaAtualizacao = ultimaAtualizacao;
        this.motivoRestricao = motivoRestricao;
    }

    public String getContainerNumber() {
        return containerNumber;
    }

    public String getStatus() {
        return status;
    }

    public boolean isGateLiberado() {
        return gateLiberado;
    }

    public boolean isLiberacaoAduaneira() {
        return liberacaoAduaneira;
    }

    public LocalDateTime getUltimaAtualizacao() {
        return ultimaAtualizacao;
    }

    public String getMotivoRestricao() {
        return motivoRestricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\gestor\dto\TosSyncResponse.java ----- 
package br.com.cloudport.servicogate.app.gestor.dto;

public class TosSyncResponse {

    private final Long agendamentoId;
    private final TosBookingInfo booking;
    private final TosContainerStatus containerStatus;

    public TosSyncResponse(Long agendamentoId, TosBookingInfo booking, TosContainerStatus containerStatus) {
        this.agendamentoId = agendamentoId;
        this.booking = booking;
        this.containerStatus = containerStatus;
    }

    public Long getAgendamentoId() {
        return agendamentoId;
    }

    public TosBookingInfo getBooking() {
        return booking;
    }

    public TosContainerStatus getContainerStatus() {
        return containerStatus;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\DashboardController.java ----- 
package br.com.cloudport.servicogate.app.transparencia;

import br.com.cloudport.servicogate.app.transparencia.dto.DashboardFiltroDTO;
import br.com.cloudport.servicogate.app.transparencia.dto.DashboardResumoDTO;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import br.com.cloudport.servicogate.app.transparencia.DashboardService;
import java.time.LocalDateTime;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.MediaType;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@RestController
@RequestMapping("/gate/dashboard")
public class DashboardController {

    private final DashboardService dashboardService;

    public DashboardController(DashboardService dashboardService) {
        this.dashboardService = dashboardService;
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE')")
    public DashboardResumoDTO consultar(
            @RequestParam(value = "inicio", required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime inicio,
            @RequestParam(value = "fim", required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fim,
            @RequestParam(value = "transportadoraId", required = false) Long transportadoraId,
            @RequestParam(value = "tipoOperacao", required = false) String tipoOperacao
    ) {
        DashboardFiltroDTO filtro = construirFiltro(inicio, fim, transportadoraId, tipoOperacao);
        return dashboardService.obterResumo(filtro);
    }

    @GetMapping(path = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    @PreAuthorize("hasAnyRole('ADMIN_PORTO','PLANEJADOR','OPERADOR_GATE')")
    public SseEmitter streamDashboard() {
        return dashboardService.registrarAssinante();
    }

    private DashboardFiltroDTO construirFiltro(LocalDateTime inicio, LocalDateTime fim,
                                               Long transportadoraId, String tipoOperacao) {
        DashboardFiltroDTO filtro = new DashboardFiltroDTO();
        filtro.setInicio(inicio);
        filtro.setFim(fim);
        filtro.setTransportadoraId(transportadoraId);
        if (tipoOperacao != null && !tipoOperacao.isBlank()) {
            filtro.setTipoOperacao(TipoOperacao.valueOf(tipoOperacao.toUpperCase()));
        }
        return filtro;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\DashboardMetricsProjection.java ----- 
package br.com.cloudport.servicogate.app.transparencia;

public interface DashboardMetricsProjection {

    Long getTotalAgendamentos();

    Long getPontuais();

    Long getNoShow();

    Double getTurnaroundMedio();

    Double getOcupacaoSlots();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\DashboardService.java ----- 
package br.com.cloudport.servicogate.app.transparencia;

import br.com.cloudport.servicogate.app.transparencia.dto.DashboardFiltroDTO;
import br.com.cloudport.servicogate.app.transparencia.dto.DashboardResumoDTO;
import br.com.cloudport.servicogate.app.transparencia.dto.OcupacaoPorHoraDTO;
import br.com.cloudport.servicogate.app.transparencia.dto.TempoMedioPermanenciaDTO;
import br.com.cloudport.servicogate.app.auditoria.dto.FormatoExportacao;
import br.com.cloudport.servicogate.app.auditoria.dto.RelatorioAgendamentoDTO;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRepository;
import br.com.cloudport.servicogate.app.transparencia.DashboardMetricsProjection;
import com.opencsv.CSVWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@Service
@Transactional(readOnly = true)
public class DashboardService {

    private static final int TOLERANCIA_PONTUALIDADE_MINUTOS = 15;
    private static final long SSE_TIMEOUT_MILLIS = Duration.ofMinutes(30).toMillis();

    private final AgendamentoRepository agendamentoRepository;
    private final CopyOnWriteArrayList<SseEmitter> emitters = new CopyOnWriteArrayList<>();

    public DashboardService(AgendamentoRepository agendamentoRepository) {
        this.agendamentoRepository = agendamentoRepository;
    }

    public DashboardResumoDTO obterResumo(DashboardFiltroDTO filtro) {
        DashboardFiltroDTO filtroNormalizado = normalizarFiltro(filtro);
        PeriodoConsulta periodoAtual = determinarPeriodoConsulta(filtroNormalizado);

        DashboardMetricsProjection projection = agendamentoRepository.calcularMetricasDashboard(
                periodoAtual.getInicio(),
                periodoAtual.getFim(),
                filtroNormalizado.getTransportadoraId(),
                filtroNormalizado.getTipoOperacao() != null ? filtroNormalizado.getTipoOperacao().name() : null,
                TOLERANCIA_PONTUALIDADE_MINUTOS
        );

        long total = Optional.ofNullable(projection.getTotalAgendamentos()).orElse(0L);
        long pontuais = Optional.ofNullable(projection.getPontuais()).orElse(0L);
        long noShow = Optional.ofNullable(projection.getNoShow()).orElse(0L);
        double turnaround = Optional.ofNullable(projection.getTurnaroundMedio()).orElse(0D);
        double ocupacao = Optional.ofNullable(projection.getOcupacaoSlots()).orElse(0D);

        List<Agendamento> agendamentosFiltrados = buscarAgendamentos(filtroNormalizado, periodoAtual);

        double percentualPontualidade = total > 0 ? (pontuais * 100.0) / total : 0D;
        double percentualNoShow = calcularPercentualAbandono(total, noShow);

        DashboardResumoDTO resumo = new DashboardResumoDTO();
        resumo.setTotalAgendamentos(total);
        resumo.setPercentualPontualidade(percentualPontualidade);
        resumo.setPercentualNoShow(percentualNoShow);
        resumo.setPercentualOcupacaoSlots(ocupacao * 100.0);
        resumo.setTempoMedioTurnaroundMinutos(turnaround);
        resumo.setOcupacaoPorHora(calcularOcupacaoPorHora(agendamentosFiltrados));
        resumo.setTurnaroundPorDia(calcularTurnaroundPorDia(agendamentosFiltrados));
        resumo.setPercentualAbandono(percentualNoShow);

        ComparativoAbandono comparativoAbandono = calcularComparativoAbandono(
                filtroNormalizado,
                periodoAtual,
                percentualNoShow
        );
        resumo.setPercentualAbandonoAnterior(comparativoAbandono.getTaxaAnterior());
        resumo.setVariacaoAbandonoPercentual(comparativoAbandono.getVariacaoPercentual());
        return resumo;
    }

    public List<RelatorioAgendamentoDTO> buscarRelatorio(DashboardFiltroDTO filtro) {
        DashboardFiltroDTO filtroNormalizado = normalizarFiltro(filtro);
        PeriodoConsulta periodo = determinarPeriodoConsulta(filtroNormalizado);
        List<Agendamento> agendamentos = buscarAgendamentos(filtroNormalizado, periodo);
        if (CollectionUtils.isEmpty(agendamentos)) {
            return Collections.emptyList();
        }
        return agendamentos.stream()
                .map(RelatorioAgendamentoDTO::fromEntity)
                .collect(Collectors.toList());
    }

    public byte[] exportarRelatorio(DashboardFiltroDTO filtro, FormatoExportacao formato) {
        List<RelatorioAgendamentoDTO> linhas = buscarRelatorio(filtro);
        if (formato == FormatoExportacao.EXCEL) {
            return gerarPlanilhaExcel(linhas);
        }
        return gerarCsv(linhas);
    }

    public SseEmitter registrarAssinante() {
        SseEmitter emitter = new SseEmitter(SSE_TIMEOUT_MILLIS);
        emitters.add(emitter);
        emitter.onCompletion(() -> emitters.remove(emitter));
        emitter.onTimeout(() -> emitters.remove(emitter));
        emitter.onError(throwable -> emitters.remove(emitter));
        enviarSnapshotInicial(emitter);
        return emitter;
    }

    public void publicarResumo(DashboardFiltroDTO filtro) {
        DashboardResumoDTO resumo = obterResumo(filtro);
        publicarAtualizacao(resumo);
    }

    public void publicarResumoGeral() {
        publicarResumo(null);
    }

    private void publicarAtualizacao(DashboardResumoDTO resumo) {
        if (emitters.isEmpty()) {
            return;
        }
        emitters.forEach(emitter -> {
            try {
                emitter.send(SseEmitter.event()
                        .name("dashboard-atualizado")
                        .data(resumo));
            } catch (IOException ex) {
                emitter.completeWithError(ex);
                emitters.remove(emitter);
            }
        });
    }

    private DashboardFiltroDTO normalizarFiltro(DashboardFiltroDTO filtro) {
        return filtro != null ? filtro : new DashboardFiltroDTO();
    }

    private List<Agendamento> buscarAgendamentos(DashboardFiltroDTO filtro, PeriodoConsulta periodo) {
        return agendamentoRepository.buscarRelatorio(
                periodo.getInicio(),
                periodo.getFim(),
                filtro.getTransportadoraId(),
                filtro.getTipoOperacao()
        );
    }

    private void enviarSnapshotInicial(SseEmitter emitter) {
        try {
            DashboardResumoDTO resumo = obterResumo(null);
            emitter.send(SseEmitter.event()
                    .name("dashboard-atualizado")
                    .data(resumo));
        } catch (IOException ex) {
            emitter.completeWithError(ex);
            emitters.remove(emitter);
        }
    }

    private List<OcupacaoPorHoraDTO> calcularOcupacaoPorHora(List<Agendamento> agendamentos) {
        if (CollectionUtils.isEmpty(agendamentos)) {
            return Collections.emptyList();
        }
        return agendamentos.stream()
                .collect(Collectors.groupingBy(agendamento -> agendamento.getJanelaAtendimento().getHoraInicio()))
                .entrySet()
                .stream()
                .map(entry -> {
                    long total = entry.getValue().stream()
                            .filter(agendamento -> agendamento.getStatus() != null
                                    && agendamento.getStatus() != br.com.cloudport.servicogate.model.enums.StatusAgendamento.CANCELADO)
                            .count();
                    Integer capacidade = Optional.ofNullable(entry.getValue().get(0).getJanelaAtendimento().getCapacidade())
                            .orElse(0);
                    return new OcupacaoPorHoraDTO(entry.getKey(), total, capacidade);
                })
                .sorted((a, b) -> a.getHoraInicio().compareTo(b.getHoraInicio()))
                .collect(Collectors.toList());
    }

    private List<TempoMedioPermanenciaDTO> calcularTurnaroundPorDia(List<Agendamento> agendamentos) {
        if (CollectionUtils.isEmpty(agendamentos)) {
            return Collections.emptyList();
        }
        return agendamentos.stream()
                .filter(agendamento -> Objects.nonNull(agendamento.getHorarioRealChegada())
                        && Objects.nonNull(agendamento.getHorarioRealSaida()))
                .collect(Collectors.groupingBy(agendamento -> agendamento.getHorarioRealSaida().toLocalDate()))
                .entrySet()
                .stream()
                .map(entry -> {
                    double media = entry.getValue().stream()
                            .mapToDouble(agendamento -> Duration.between(
                                    agendamento.getHorarioRealChegada(),
                                    agendamento.getHorarioRealSaida()
                            ).toMinutes())
                            .average()
                            .orElse(0D);
                    return new TempoMedioPermanenciaDTO(entry.getKey(), media);
                })
                .sorted((a, b) -> a.getDia().compareTo(b.getDia()))
                .collect(Collectors.toList());
    }

    private PeriodoConsulta determinarPeriodoConsulta(DashboardFiltroDTO filtro) {
        LocalDateTime fim = filtro.getFim();
        LocalDateTime inicio = filtro.getInicio();

        if (inicio == null && fim == null) {
            fim = LocalDateTime.now();
            inicio = fim.minusDays(30);
        } else if (inicio == null) {
            inicio = fim.minusDays(30);
        } else if (fim == null) {
            fim = inicio.plusDays(30);
        }

        if (inicio.isAfter(fim)) {
            LocalDateTime temp = inicio;
            inicio = fim;
            fim = temp;
        }

        return new PeriodoConsulta(inicio, fim);
    }

    private double calcularPercentualAbandono(long total, long totalNoShow) {
        return total > 0 ? (totalNoShow * 100.0) / total : 0D;
    }

    private ComparativoAbandono calcularComparativoAbandono(DashboardFiltroDTO filtro,
                                                            PeriodoConsulta periodoAtual,
                                                            double taxaAtual) {
        PeriodoConsulta periodoAnterior = periodoAtual.periodoAnterior();

        DashboardMetricsProjection projectionAnterior = agendamentoRepository.calcularMetricasDashboard(
                periodoAnterior.getInicio(),
                periodoAnterior.getFim(),
                filtro.getTransportadoraId(),
                filtro.getTipoOperacao() != null ? filtro.getTipoOperacao().name() : null,
                TOLERANCIA_PONTUALIDADE_MINUTOS
        );

        long totalAnterior = Optional.ofNullable(projectionAnterior.getTotalAgendamentos()).orElse(0L);
        long noShowAnterior = Optional.ofNullable(projectionAnterior.getNoShow()).orElse(0L);
        double taxaAnterior = calcularPercentualAbandono(totalAnterior, noShowAnterior);

        double variacao = 0D;
        if (taxaAnterior > 0D) {
            variacao = ((taxaAnterior - taxaAtual) / taxaAnterior) * 100.0;
        } else if (taxaAtual == 0D) {
            variacao = 100D;
        }

        return new ComparativoAbandono(taxaAnterior, variacao);
    }

    private static final class PeriodoConsulta {
        private final LocalDateTime inicio;
        private final LocalDateTime fim;

        private PeriodoConsulta(LocalDateTime inicio, LocalDateTime fim) {
            this.inicio = inicio;
            this.fim = fim;
        }

        private LocalDateTime getInicio() {
            return inicio;
        }

        private LocalDateTime getFim() {
            return fim;
        }

        private PeriodoConsulta periodoAnterior() {
            Duration duracao = Duration.between(inicio, fim);
            if (duracao.isZero() || duracao.isNegative()) {
                duracao = Duration.ofDays(30);
            }
            LocalDateTime novoFim = inicio;
            LocalDateTime novoInicio = inicio.minus(duracao);
            return new PeriodoConsulta(novoInicio, novoFim);
        }
    }

    private static final class ComparativoAbandono {
        private final double taxaAnterior;
        private final double variacaoPercentual;

        private ComparativoAbandono(double taxaAnterior, double variacaoPercentual) {
            this.taxaAnterior = taxaAnterior;
            this.variacaoPercentual = variacaoPercentual;
        }

        private double getTaxaAnterior() {
            return taxaAnterior;
        }

        private double getVariacaoPercentual() {
            return variacaoPercentual;
        }
    }

    private byte[] gerarCsv(List<RelatorioAgendamentoDTO> linhas) {
        try (StringWriter out = new StringWriter(); CSVWriter writer = new CSVWriter(out)) {
            writer.writeNext(new String[]{
                    "Código",
                    "Tipo de Operação",
                    "Status",
                    "Transportadora",
                    "Previsto Chegada",
                    "Real Chegada",
                    "Previsto Saída",
                    "Real Saída"
            });

            for (RelatorioAgendamentoDTO dto : linhas) {
                writer.writeNext(new String[]{
                        dto.getCodigo(),
                        Optional.ofNullable(dto.getTipoOperacao()).map(TipoOperacao::name).orElse(""),
                        Optional.ofNullable(dto.getStatus()).map(Enum::name).orElse(""),
                        Optional.ofNullable(dto.getTransportadora()).orElse(""),
                        formatarData(dto.getHorarioPrevistoChegada()),
                        formatarData(dto.getHorarioRealChegada()),
                        formatarData(dto.getHorarioPrevistoSaida()),
                        formatarData(dto.getHorarioRealSaida())
                });
            }
            writer.flush();
            return out.toString().getBytes();
        } catch (IOException ex) {
            throw new IllegalStateException("Erro ao gerar CSV de relatórios", ex);
        }
    }

    private byte[] gerarPlanilhaExcel(List<RelatorioAgendamentoDTO> linhas) {
        try (Workbook workbook = new XSSFWorkbook()) {
            Sheet sheet = workbook.createSheet("Relatório Gate");
            int rowIndex = 0;
            Row header = sheet.createRow(rowIndex++);
            String[] cabecalho = {
                    "Código",
                    "Tipo de Operação",
                    "Status",
                    "Transportadora",
                    "Previsto Chegada",
                    "Real Chegada",
                    "Previsto Saída",
                    "Real Saída"
            };
            for (int i = 0; i < cabecalho.length; i++) {
                Cell cell = header.createCell(i);
                cell.setCellValue(cabecalho[i]);
            }

            for (RelatorioAgendamentoDTO dto : linhas) {
                Row row = sheet.createRow(rowIndex++);
                int col = 0;
                row.createCell(col++).setCellValue(dto.getCodigo());
                row.createCell(col++).setCellValue(Optional.ofNullable(dto.getTipoOperacao()).map(TipoOperacao::name).orElse(""));
                row.createCell(col++).setCellValue(Optional.ofNullable(dto.getStatus()).map(Enum::name).orElse(""));
                row.createCell(col++).setCellValue(Optional.ofNullable(dto.getTransportadora()).orElse(""));
                row.createCell(col++).setCellValue(formatarData(dto.getHorarioPrevistoChegada()));
                row.createCell(col++).setCellValue(formatarData(dto.getHorarioRealChegada()));
                row.createCell(col++).setCellValue(formatarData(dto.getHorarioPrevistoSaida()));
                row.createCell(col++).setCellValue(formatarData(dto.getHorarioRealSaida()));
            }

            for (int i = 0; i < cabecalho.length; i++) {
                sheet.autoSizeColumn(i);
            }

            try (java.io.ByteArrayOutputStream outputStream = new java.io.ByteArrayOutputStream()) {
                workbook.write(outputStream);
                return outputStream.toByteArray();
            }
        } catch (IOException ex) {
            throw new IllegalStateException("Erro ao gerar planilha Excel do relatório", ex);
        }
    }

    private String formatarData(LocalDateTime data) {
        return data != null ? data.toString() : "";
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\OcupacaoPorHoraProjection.java ----- 
package br.com.cloudport.servicogate.app.transparencia;

import java.time.LocalTime;

public interface OcupacaoPorHoraProjection {

    LocalTime getHoraInicio();

    Long getTotalAgendamentos();

    Integer getCapacidadeSlot();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\TempoMedioPermanenciaProjection.java ----- 
package br.com.cloudport.servicogate.app.transparencia;

import java.time.LocalDate;

public interface TempoMedioPermanenciaProjection {

    LocalDate getDia();

    Double getTempoMedioMinutos();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\dto\DashboardFiltroDTO.java ----- 
package br.com.cloudport.servicogate.app.transparencia.dto;

import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import java.time.LocalDateTime;

public class DashboardFiltroDTO {

    private LocalDateTime inicio;
    private LocalDateTime fim;
    private Long transportadoraId;
    private TipoOperacao tipoOperacao;

    public LocalDateTime getInicio() {
        return inicio;
    }

    public void setInicio(LocalDateTime inicio) {
        this.inicio = inicio;
    }

    public LocalDateTime getFim() {
        return fim;
    }

    public void setFim(LocalDateTime fim) {
        this.fim = fim;
    }

    public Long getTransportadoraId() {
        return transportadoraId;
    }

    public void setTransportadoraId(Long transportadoraId) {
        this.transportadoraId = transportadoraId;
    }

    public TipoOperacao getTipoOperacao() {
        return tipoOperacao;
    }

    public void setTipoOperacao(TipoOperacao tipoOperacao) {
        this.tipoOperacao = tipoOperacao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\dto\DashboardResumoDTO.java ----- 
package br.com.cloudport.servicogate.app.transparencia.dto;

import java.util.List;

public class DashboardResumoDTO {

    private long totalAgendamentos;
    private double percentualPontualidade;
    private double percentualNoShow;
    private double percentualOcupacaoSlots;
    private double tempoMedioTurnaroundMinutos;
    private List<OcupacaoPorHoraDTO> ocupacaoPorHora;
    private List<TempoMedioPermanenciaDTO> turnaroundPorDia;
    private double percentualAbandono;
    private double percentualAbandonoAnterior;
    private double variacaoAbandonoPercentual;

    public long getTotalAgendamentos() {
        return totalAgendamentos;
    }

    public void setTotalAgendamentos(long totalAgendamentos) {
        this.totalAgendamentos = totalAgendamentos;
    }

    public double getPercentualPontualidade() {
        return percentualPontualidade;
    }

    public void setPercentualPontualidade(double percentualPontualidade) {
        this.percentualPontualidade = percentualPontualidade;
    }

    public double getPercentualNoShow() {
        return percentualNoShow;
    }

    public void setPercentualNoShow(double percentualNoShow) {
        this.percentualNoShow = percentualNoShow;
    }

    public double getPercentualOcupacaoSlots() {
        return percentualOcupacaoSlots;
    }

    public void setPercentualOcupacaoSlots(double percentualOcupacaoSlots) {
        this.percentualOcupacaoSlots = percentualOcupacaoSlots;
    }

    public double getTempoMedioTurnaroundMinutos() {
        return tempoMedioTurnaroundMinutos;
    }

    public void setTempoMedioTurnaroundMinutos(double tempoMedioTurnaroundMinutos) {
        this.tempoMedioTurnaroundMinutos = tempoMedioTurnaroundMinutos;
    }

    public List<OcupacaoPorHoraDTO> getOcupacaoPorHora() {
        return ocupacaoPorHora;
    }

    public void setOcupacaoPorHora(List<OcupacaoPorHoraDTO> ocupacaoPorHora) {
        this.ocupacaoPorHora = ocupacaoPorHora;
    }

    public List<TempoMedioPermanenciaDTO> getTurnaroundPorDia() {
        return turnaroundPorDia;
    }

    public void setTurnaroundPorDia(List<TempoMedioPermanenciaDTO> turnaroundPorDia) {
        this.turnaroundPorDia = turnaroundPorDia;
    }

    public double getPercentualAbandono() {
        return percentualAbandono;
    }

    public void setPercentualAbandono(double percentualAbandono) {
        this.percentualAbandono = percentualAbandono;
    }

    public double getPercentualAbandonoAnterior() {
        return percentualAbandonoAnterior;
    }

    public void setPercentualAbandonoAnterior(double percentualAbandonoAnterior) {
        this.percentualAbandonoAnterior = percentualAbandonoAnterior;
    }

    public double getVariacaoAbandonoPercentual() {
        return variacaoAbandonoPercentual;
    }

    public void setVariacaoAbandonoPercentual(double variacaoAbandonoPercentual) {
        this.variacaoAbandonoPercentual = variacaoAbandonoPercentual;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\dto\OcupacaoPorHoraDTO.java ----- 
package br.com.cloudport.servicogate.app.transparencia.dto;

import java.time.LocalTime;

public class OcupacaoPorHoraDTO {

    private LocalTime horaInicio;
    private Long totalAgendamentos;
    private Integer capacidadeSlot;

    public OcupacaoPorHoraDTO(LocalTime horaInicio, Long totalAgendamentos, Integer capacidadeSlot) {
        this.horaInicio = horaInicio;
        this.totalAgendamentos = totalAgendamentos;
        this.capacidadeSlot = capacidadeSlot;
    }

    public LocalTime getHoraInicio() {
        return horaInicio;
    }

    public void setHoraInicio(LocalTime horaInicio) {
        this.horaInicio = horaInicio;
    }

    public Long getTotalAgendamentos() {
        return totalAgendamentos;
    }

    public void setTotalAgendamentos(Long totalAgendamentos) {
        this.totalAgendamentos = totalAgendamentos;
    }

    public Integer getCapacidadeSlot() {
        return capacidadeSlot;
    }

    public void setCapacidadeSlot(Integer capacidadeSlot) {
        this.capacidadeSlot = capacidadeSlot;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\app\transparencia\dto\TempoMedioPermanenciaDTO.java ----- 
package br.com.cloudport.servicogate.app.transparencia.dto;

import java.time.LocalDate;

public class TempoMedioPermanenciaDTO {

    private LocalDate dia;
    private Double tempoMedioMinutos;

    public TempoMedioPermanenciaDTO(LocalDate dia, Double tempoMedioMinutos) {
        this.dia = dia;
        this.tempoMedioMinutos = tempoMedioMinutos;
    }

    public LocalDate getDia() {
        return dia;
    }

    public void setDia(LocalDate dia) {
        this.dia = dia;
    }

    public Double getTempoMedioMinutos() {
        return tempoMedioMinutos;
    }

    public void setTempoMedioMinutos(Double tempoMedioMinutos) {
        this.tempoMedioMinutos = tempoMedioMinutos;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\AgendamentoRulesProperties.java ----- 
package br.com.cloudport.servicogate.config;

import java.time.Duration;
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "cloudport.gate.agendamento.rules")
public class AgendamentoRulesProperties {

    /**
     * Antecedência mínima necessária para criação de agendamentos em relação ao início da janela.
     */
    private Duration antecedenciaMinima = Duration.ofHours(2);

    /**
     * Tempo máximo após o início da janela em que ainda é permitido criar agendamentos.
     */
    private Duration atrasoMaximo = Duration.ofHours(1);

    /**
     * Período anterior ao início da janela em que edições são permitidas.
     */
    private Duration edicaoAntecedencia = Duration.ofHours(12);

    /**
     * Período posterior ao início da janela em que edições são permitidas.
     */
    private Duration edicaoAtraso = Duration.ofHours(2);

    /**
     * Antecedência para disparo de notificações de janela próxima.
     */
    private Duration notificacaoJanelaAntecedencia = Duration.ofMinutes(30);

    public Duration getAntecedenciaMinima() {
        return antecedenciaMinima;
    }

    public void setAntecedenciaMinima(Duration antecedenciaMinima) {
        this.antecedenciaMinima = antecedenciaMinima;
    }

    public Duration getAtrasoMaximo() {
        return atrasoMaximo;
    }

    public void setAtrasoMaximo(Duration atrasoMaximo) {
        this.atrasoMaximo = atrasoMaximo;
    }

    public Duration getEdicaoAntecedencia() {
        return edicaoAntecedencia;
    }

    public void setEdicaoAntecedencia(Duration edicaoAntecedencia) {
        this.edicaoAntecedencia = edicaoAntecedencia;
    }

    public Duration getEdicaoAtraso() {
        return edicaoAtraso;
    }

    public void setEdicaoAtraso(Duration edicaoAtraso) {
        this.edicaoAtraso = edicaoAtraso;
    }

    public Duration getNotificacaoJanelaAntecedencia() {
        return notificacaoJanelaAntecedencia;
    }

    public void setNotificacaoJanelaAntecedencia(Duration notificacaoJanelaAntecedencia) {
        this.notificacaoJanelaAntecedencia = notificacaoJanelaAntecedencia;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\DocumentoStorageProperties.java ----- 
package br.com.cloudport.servicogate.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "cloudport.document-storage")
public class DocumentoStorageProperties {

    private String provider = "local";

    private String basePath = "/var/lib/cloudport/documents";

    private String bucket = "cloudport-documents";

    public String getProvider() {
        return provider;
    }

    public void setProvider(String provider) {
        this.provider = provider;
    }

    public String getBasePath() {
        return basePath;
    }

    public void setBasePath(String basePath) {
        this.basePath = basePath;
    }

    public String getBucket() {
        return bucket;
    }

    public void setBucket(String bucket) {
        this.bucket = bucket;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\GateFlowProperties.java ----- 
package br.com.cloudport.servicogate.config;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "cloudport.gate.flow")
public class GateFlowProperties {

    private Duration toleranciaEntradaAntecipada = Duration.ofMinutes(30);
    private Duration toleranciaEntradaAtraso = Duration.ofMinutes(30);
    private Duration toleranciaSaidaAntecipada = Duration.ofMinutes(30);
    private Duration toleranciaSaidaAtraso = Duration.ofMinutes(30);
    private List<String> rolesLiberacaoManual = new ArrayList<>(Collections.singletonList("ROLE_OPERADOR_GATE"));

    public Duration getToleranciaEntradaAntecipada() {
        return toleranciaEntradaAntecipada;
    }

    public void setToleranciaEntradaAntecipada(Duration toleranciaEntradaAntecipada) {
        this.toleranciaEntradaAntecipada = toleranciaEntradaAntecipada;
    }

    public Duration getToleranciaEntradaAtraso() {
        return toleranciaEntradaAtraso;
    }

    public void setToleranciaEntradaAtraso(Duration toleranciaEntradaAtraso) {
        this.toleranciaEntradaAtraso = toleranciaEntradaAtraso;
    }

    public Duration getToleranciaSaidaAntecipada() {
        return toleranciaSaidaAntecipada;
    }

    public void setToleranciaSaidaAntecipada(Duration toleranciaSaidaAntecipada) {
        this.toleranciaSaidaAntecipada = toleranciaSaidaAntecipada;
    }

    public Duration getToleranciaSaidaAtraso() {
        return toleranciaSaidaAtraso;
    }

    public void setToleranciaSaidaAtraso(Duration toleranciaSaidaAtraso) {
        this.toleranciaSaidaAtraso = toleranciaSaidaAtraso;
    }

    public List<String> getRolesLiberacaoManual() {
        return rolesLiberacaoManual;
    }

    public void setRolesLiberacaoManual(List<String> rolesLiberacaoManual) {
        this.rolesLiberacaoManual = rolesLiberacaoManual;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\HardwareIntegrationProperties.java ----- 
package br.com.cloudport.servicogate.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "cloudport.gate.hardware")
public class HardwareIntegrationProperties {

    private String entradaQueue = "gate.hardware.entrada";
    private String saidaQueue = "gate.hardware.saida";
    private String decisaoExchange = "gate.hardware.decisao";
    private String decisaoRoutingEntrada = "gate.hardware.decisao.entrada";
    private String decisaoRoutingSaida = "gate.hardware.decisao.saida";

    public String getEntradaQueue() {
        return entradaQueue;
    }

    public void setEntradaQueue(String entradaQueue) {
        this.entradaQueue = entradaQueue;
    }

    public String getSaidaQueue() {
        return saidaQueue;
    }

    public void setSaidaQueue(String saidaQueue) {
        this.saidaQueue = saidaQueue;
    }

    public String getDecisaoExchange() {
        return decisaoExchange;
    }

    public void setDecisaoExchange(String decisaoExchange) {
        this.decisaoExchange = decisaoExchange;
    }

    public String getDecisaoRoutingEntrada() {
        return decisaoRoutingEntrada;
    }

    public void setDecisaoRoutingEntrada(String decisaoRoutingEntrada) {
        this.decisaoRoutingEntrada = decisaoRoutingEntrada;
    }

    public String getDecisaoRoutingSaida() {
        return decisaoRoutingSaida;
    }

    public void setDecisaoRoutingSaida(String decisaoRoutingSaida) {
        this.decisaoRoutingSaida = decisaoRoutingSaida;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\HardwareRabbitConfiguration.java ----- 
package br.com.cloudport.servicogate.config;

import org.springframework.amqp.core.Declarables;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@Configuration
@EnableConfigurationProperties(HardwareIntegrationProperties.class)
public class HardwareRabbitConfiguration {

    private final HardwareIntegrationProperties properties;

    public HardwareRabbitConfiguration(HardwareIntegrationProperties properties) {
        this.properties = properties;
    }

    @Bean
    public Declarables gateHardwareDeclarables() {
        return new Declarables(
                QueueBuilder.durable(properties.getEntradaQueue()).build(),
                QueueBuilder.durable(properties.getSaidaQueue()).build(),
                ExchangeBuilder.directExchange(properties.getDecisaoExchange()).durable(true).build()
        );
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\OcrIntegrationProperties.java ----- 
package br.com.cloudport.servicogate.config;

import java.time.Duration;
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "cloudport.gate.ocr")
public class OcrIntegrationProperties {

    private String solicitacaoQueue = "gate.ocr.solicitacoes";
    private Duration tempoMaximoProcessamento = Duration.ofSeconds(10);

    public String getSolicitacaoQueue() {
        return solicitacaoQueue;
    }

    public void setSolicitacaoQueue(String solicitacaoQueue) {
        this.solicitacaoQueue = solicitacaoQueue;
    }

    public Duration getTempoMaximoProcessamento() {
        return tempoMaximoProcessamento;
    }

    public void setTempoMaximoProcessamento(Duration tempoMaximoProcessamento) {
        this.tempoMaximoProcessamento = tempoMaximoProcessamento;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\OcrRabbitConfiguration.java ----- 
package br.com.cloudport.servicogate.config;

import org.springframework.amqp.core.Declarables;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties(OcrIntegrationProperties.class)
public class OcrRabbitConfiguration {

    private final OcrIntegrationProperties properties;

    public OcrRabbitConfiguration(OcrIntegrationProperties properties) {
        this.properties = properties;
    }

    @Bean
    public Declarables ocrDeclarables() {
        return new Declarables(
                QueueBuilder.durable(properties.getSolicitacaoQueue()).build()
        );
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\OpenApiConfig.java ----- 
package br.com.cloudport.servicogate.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@Configuration
@EnableConfigurationProperties({
        AgendamentoRulesProperties.class,
        DocumentoStorageProperties.class,
        GateFlowProperties.class
})
public class OpenApiConfig {

    @Bean
    public OpenAPI gateOpenApi() {
        return new OpenAPI()
                .components(new Components())
                .info(new Info()
                        .title("CloudPort - Serviço de Gate")
                        .description("API para gestão de agendamentos e janelas de atendimento do Gate CloudPort")
                        .version("1.0.0")
                        .contact(new Contact()
                                .name("Equipe CloudPort")
                                .email("suporte@cloudport.com.br"))
                        .license(new License()
                                .name("Proprietary")
                                .url("https://cloudport.com.br")));
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\config\SecurityConfig.java ----- 
package br.com.cloudport.servicogate.config;

import br.com.cloudport.servicogate.security.TransportadoraSynchronizationFilter;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.JwtClaimNames;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.core.convert.converter.Converter;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter;
import org.springframework.util.StringUtils;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    private final TransportadoraSynchronizationFilter transportadoraSynchronizationFilter;
    private final String jwtSecret;
    private final String allowedOrigins;

    public SecurityConfig(TransportadoraSynchronizationFilter transportadoraSynchronizationFilter,
                          @Value("${cloudport.security.jwt.secret}") String jwtSecret,
                          @Value("${cloudport.security.cors.allowed-origins:http://localhost:3000}") String allowedOrigins) {
        this.transportadoraSynchronizationFilter = transportadoraSynchronizationFilter;
        this.jwtSecret = jwtSecret;
        this.allowedOrigins = allowedOrigins;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors().configurationSource(corsConfigurationSource()).and()
                .csrf().disable()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
                .authorizeRequests(authorize -> authorize
                        .antMatchers("/actuator/health", "/actuator/info").permitAll()
                        .antMatchers("/swagger-ui.html", "/swagger-ui/**", "/api-docs/**").permitAll()
                        .antMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                        .anyRequest().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter())));

        http.addFilterAfter(transportadoraSynchronizationFilter, BearerTokenAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        SecretKey secretKey = new SecretKeySpec(jwtSecret.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
        return NimbusJwtDecoder.withSecretKey(secretKey).build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter());
        converter.setPrincipalClaimName(JwtClaimNames.SUB);
        return converter;
    }

    private Converter<Jwt, List<SimpleGrantedAuthority>> jwtGrantedAuthoritiesConverter() {
        return jwt -> {
            List<String> roles = Optional.ofNullable(jwt.getClaimAsStringList("roles"))
                    .orElseGet(() -> {
                        String role = jwt.getClaimAsString("role");
                        return StringUtils.hasText(role) ? Collections.singletonList(role) : Collections.emptyList();
                    });

            return roles.stream()
                    .filter(StringUtils::hasText)
                    .map(role -> role.startsWith("ROLE_") ? role : "ROLE_" + role.toUpperCase(Locale.ROOT))
                    .distinct()
                    .map(SimpleGrantedAuthority::new)
                    .collect(Collectors.toList());
        };
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        List<String> origins = Arrays.stream(allowedOrigins.split(","))
                .map(String::trim)
                .filter(StringUtils::hasText)
                .collect(Collectors.toList());
        if (origins.isEmpty()) {
            origins = Collections.singletonList("http://localhost:3000");
        }
        configuration.setAllowedOrigins(origins);
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "Accept"));
        configuration.setExposedHeaders(Collections.singletonList("Authorization"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(Duration.ofHours(1));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public RestTemplate securityRestTemplate(RestTemplateBuilder builder) {
        return builder
                .setConnectTimeout(Duration.ofSeconds(5))
                .setReadTimeout(Duration.ofSeconds(5))
                .build();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\exception\ApiError.java ----- 
package br.com.cloudport.servicogate.exception;

import java.time.OffsetDateTime;
import java.util.List;

public class ApiError {

    private final OffsetDateTime timestamp;
    private final int status;
    private final String message;
    private final List<String> errors;

    public ApiError(int status, String message, List<String> errors) {
        this.timestamp = OffsetDateTime.now();
        this.status = status;
        this.message = message;
        this.errors = errors;
    }

    public OffsetDateTime getTimestamp() {
        return timestamp;
    }

    public int getStatus() {
        return status;
    }

    public String getMessage() {
        return message;
    }

    public List<String> getErrors() {
        return errors;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\exception\BusinessException.java ----- 
package br.com.cloudport.servicogate.exception;

public class BusinessException extends RuntimeException {

    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\exception\GlobalExceptionHandler.java ----- 
package br.com.cloudport.servicogate.exception;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import javax.validation.ConstraintViolationException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ApiError> handleNotFound(NotFoundException ex) {
        ApiError apiError = new ApiError(HttpStatus.NOT_FOUND.value(), ex.getMessage(), Collections.emptyList());
        return new ResponseEntity<>(apiError, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusiness(BusinessException ex) {
        ApiError apiError = new ApiError(HttpStatus.UNPROCESSABLE_ENTITY.value(), ex.getMessage(), Collections.emptyList());
        return new ResponseEntity<>(apiError, HttpStatus.UNPROCESSABLE_ENTITY);
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ApiError> handleConstraintViolation(ConstraintViolationException ex) {
        List<String> errors = ex.getConstraintViolations().stream()
                .map(violation -> violation.getPropertyPath() + ": " + violation.getMessage())
                .collect(Collectors.toList());
        ApiError apiError = new ApiError(HttpStatus.BAD_REQUEST.value(), "Erro de validação", errors);
        return new ResponseEntity<>(apiError, HttpStatus.BAD_REQUEST);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
                                                                  HttpHeaders headers,
                                                                  HttpStatus status,
                                                                  WebRequest request) {
        BindingResult bindingResult = ex.getBindingResult();
        List<String> errors = bindingResult.getFieldErrors().stream()
                .map(this::formatFieldError)
                .collect(Collectors.toList());
        ApiError apiError = new ApiError(HttpStatus.BAD_REQUEST.value(), "Erro de validação", errors);
        return new ResponseEntity<>(apiError, HttpStatus.BAD_REQUEST);
    }

    private String formatFieldError(FieldError error) {
        return error.getField() + ": " + error.getDefaultMessage();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\exception\NotFoundException.java ----- 
package br.com.cloudport.servicogate.exception;

public class NotFoundException extends RuntimeException {

    public NotFoundException(String message) {
        super(message);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\hardware\GateHardwareListener.java ----- 
package br.com.cloudport.servicogate.integration.hardware;

import br.com.cloudport.servicogate.app.gestor.dto.GateDecisionDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateFlowRequest;
import br.com.cloudport.servicogate.exception.BusinessException;
import br.com.cloudport.servicogate.exception.NotFoundException;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import br.com.cloudport.servicogate.monitoring.GateMetrics;
import br.com.cloudport.servicogate.app.gestor.GateFlowService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

@Component
public class GateHardwareListener {

    private static final Logger LOGGER = LoggerFactory.getLogger(GateHardwareListener.class);

    private final GateFlowService gateFlowService;
    private final GateHardwarePublisher publisher;
    private final GateMetrics gateMetrics;
    private final ObjectMapper objectMapper;

    public GateHardwareListener(GateFlowService gateFlowService,
                                GateHardwarePublisher publisher,
                                ObjectMapper objectMapper,
                                GateMetrics gateMetrics) {
        this.gateFlowService = gateFlowService;
        this.publisher = publisher;
        this.objectMapper = objectMapper;
        this.gateMetrics = gateMetrics;
    }

    @RabbitListener(queues = "${cloudport.gate.hardware.entrada-queue}")
    public void consumirEntrada(@Payload String payload) {
        processarMensagem(payload, true);
    }

    @RabbitListener(queues = "${cloudport.gate.hardware.saida-queue}")
    public void consumirSaida(@Payload String payload) {
        processarMensagem(payload, false);
    }

    private void processarMensagem(String payload, boolean entrada) {
        if (!StringUtils.hasText(payload)) {
            return;
        }
        boolean sucesso = false;
        try {
            HardwareEventMessage event = objectMapper.readValue(payload, HardwareEventMessage.class);
            GateFlowRequest request = event.toRequest();
            GateDecisionDTO decision = entrada
                    ? gateFlowService.registrarEntrada(request)
                    : gateFlowService.registrarSaida(request);
            publicarDecisao(decision, event, entrada);
            sucesso = true;
        } catch (BusinessException | NotFoundException ex) {
            LOGGER.warn("Falha ao processar evento de hardware: {}", ex.getMessage());
            publicarDecisao(GateDecisionDTO.negado(StatusGate.RETIDO, null, null, ex.getMessage()),
                    criarFallbackEvento(payload), entrada);
        } catch (Exception ex) {
            LOGGER.error("Erro inesperado ao processar evento do hardware", ex);
        } finally {
            gateMetrics.registrarConsumoFila(entrada ? "entrada" : "saida", sucesso);
        }
    }

    private void publicarDecisao(GateDecisionDTO decision, HardwareEventMessage event, boolean entrada) {
        if (entrada) {
            publisher.publicarDecisaoEntrada(decision, event);
        } else {
            publisher.publicarDecisaoSaida(decision, event);
        }
    }

    private HardwareEventMessage criarFallbackEvento(String payload) {
        HardwareEventMessage event = new HardwareEventMessage();
        event.setQrCode(payload);
        return event;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\hardware\GateHardwarePublisher.java ----- 
package br.com.cloudport.servicogate.integration.hardware;

import br.com.cloudport.servicogate.config.HardwareIntegrationProperties;
import br.com.cloudport.servicogate.app.gestor.dto.GateDecisionDTO;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Component;

@Component
public class GateHardwarePublisher {

    private static final Logger LOGGER = LoggerFactory.getLogger(GateHardwarePublisher.class);

    private final RabbitTemplate rabbitTemplate;
    private final HardwareIntegrationProperties properties;
    private final ObjectMapper objectMapper;

    public GateHardwarePublisher(RabbitTemplate rabbitTemplate,
                                 HardwareIntegrationProperties properties,
                                 ObjectMapper objectMapper) {
        this.rabbitTemplate = rabbitTemplate;
        this.properties = properties;
        this.objectMapper = objectMapper;
    }

    public void publicarDecisaoEntrada(GateDecisionDTO decision, HardwareEventMessage event) {
        publicar(decision, event, properties.getDecisaoRoutingEntrada());
    }

    public void publicarDecisaoSaida(GateDecisionDTO decision, HardwareEventMessage event) {
        publicar(decision, event, properties.getDecisaoRoutingSaida());
    }

    private void publicar(GateDecisionDTO decision, HardwareEventMessage event, String routingKey) {
        HardwareDecisionMessage message = HardwareDecisionMessage.from(decision, event);
        try {
            String payload = objectMapper.writeValueAsString(message);
            rabbitTemplate.convertAndSend(properties.getDecisaoExchange(), routingKey, payload);
        } catch (JsonProcessingException ex) {
            LOGGER.error("Falha ao serializar decisão de gate para publicação", ex);
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\hardware\HardwareDecisionMessage.java ----- 
package br.com.cloudport.servicogate.integration.hardware;

import br.com.cloudport.servicogate.app.gestor.dto.GateDecisionDTO;
import com.fasterxml.jackson.annotation.JsonInclude;
import java.io.Serializable;
import java.time.LocalDateTime;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class HardwareDecisionMessage implements Serializable {

    private static final long serialVersionUID = 1L;

    private boolean autorizado;
    private String statusGate;
    private String statusDescricao;
    private Long agendamentoId;
    private String codigoAgendamento;
    private Long gatePassId;
    private String codigoGatePass;
    private String mensagem;
    private String placa;
    private String qrCode;
    private LocalDateTime timestamp;
    private String origem;
    private String dispositivo;

    public static HardwareDecisionMessage from(GateDecisionDTO decision, HardwareEventMessage event) {
        HardwareDecisionMessage message = new HardwareDecisionMessage();
        if (decision != null) {
            message.setAutorizado(decision.isAutorizado());
            message.setStatusGate(decision.getStatusGate());
            message.setStatusDescricao(decision.getStatusDescricao());
            message.setAgendamentoId(decision.getAgendamentoId());
            message.setCodigoAgendamento(decision.getCodigoAgendamento());
            message.setGatePassId(decision.getGatePassId());
            message.setCodigoGatePass(decision.getCodigoGatePass());
            message.setMensagem(decision.getMensagem());
        }
        if (event != null) {
            message.setPlaca(event.getPlaca());
            message.setQrCode(event.getQrCode());
            message.setTimestamp(event.getTimestamp());
            message.setOrigem(event.getOrigem());
            message.setDispositivo(event.getDispositivo());
        }
        return message;
    }

    public boolean isAutorizado() {
        return autorizado;
    }

    public void setAutorizado(boolean autorizado) {
        this.autorizado = autorizado;
    }

    public String getStatusGate() {
        return statusGate;
    }

    public void setStatusGate(String statusGate) {
        this.statusGate = statusGate;
    }

    public String getStatusDescricao() {
        return statusDescricao;
    }

    public void setStatusDescricao(String statusDescricao) {
        this.statusDescricao = statusDescricao;
    }

    public Long getAgendamentoId() {
        return agendamentoId;
    }

    public void setAgendamentoId(Long agendamentoId) {
        this.agendamentoId = agendamentoId;
    }

    public String getCodigoAgendamento() {
        return codigoAgendamento;
    }

    public void setCodigoAgendamento(String codigoAgendamento) {
        this.codigoAgendamento = codigoAgendamento;
    }

    public Long getGatePassId() {
        return gatePassId;
    }

    public void setGatePassId(Long gatePassId) {
        this.gatePassId = gatePassId;
    }

    public String getCodigoGatePass() {
        return codigoGatePass;
    }

    public void setCodigoGatePass(String codigoGatePass) {
        this.codigoGatePass = codigoGatePass;
    }

    public String getMensagem() {
        return mensagem;
    }

    public void setMensagem(String mensagem) {
        this.mensagem = mensagem;
    }

    public String getPlaca() {
        return placa;
    }

    public void setPlaca(String placa) {
        this.placa = placa;
    }

    public String getQrCode() {
        return qrCode;
    }

    public void setQrCode(String qrCode) {
        this.qrCode = qrCode;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getOrigem() {
        return origem;
    }

    public void setOrigem(String origem) {
        this.origem = origem;
    }

    public String getDispositivo() {
        return dispositivo;
    }

    public void setDispositivo(String dispositivo) {
        this.dispositivo = dispositivo;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\hardware\HardwareEventMessage.java ----- 
package br.com.cloudport.servicogate.integration.hardware;

import br.com.cloudport.servicogate.app.gestor.dto.GateFlowRequest;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import java.time.LocalDateTime;
import java.util.Optional;

@JsonIgnoreProperties(ignoreUnknown = true)
public class HardwareEventMessage {

    private String placa;
    private String qrCode;

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime timestamp;

    private String operador;
    private String origem;
    private String dispositivo;

    public GateFlowRequest toRequest() {
        GateFlowRequest request = new GateFlowRequest();
        request.setPlaca(Optional.ofNullable(placa).map(String::trim).orElse(null));
        request.setQrCode(Optional.ofNullable(qrCode).map(String::trim).orElse(null));
        request.setTimestamp(timestamp);
        request.setOperador(operador);
        return request;
    }

    public String getPlaca() {
        return placa;
    }

    public void setPlaca(String placa) {
        this.placa = placa;
    }

    public String getQrCode() {
        return qrCode;
    }

    public void setQrCode(String qrCode) {
        this.qrCode = qrCode;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getOperador() {
        return operador;
    }

    public void setOperador(String operador) {
        this.operador = operador;
    }

    public String getOrigem() {
        return origem;
    }

    public void setOrigem(String origem) {
        this.origem = origem;
    }

    public String getDispositivo() {
        return dispositivo;
    }

    public void setDispositivo(String dispositivo) {
        this.dispositivo = dispositivo;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\ocr\ProcessamentoOcrExecutor.java ----- 
package br.com.cloudport.servicogate.integration.ocr;

import br.com.cloudport.servicogate.app.cidadao.AgendamentoRealtimeService;
import br.com.cloudport.servicogate.app.cidadao.DocumentoAgendamentoRepository;
import br.com.cloudport.servicogate.config.OcrIntegrationProperties;
import br.com.cloudport.servicogate.exception.BusinessException;
import br.com.cloudport.servicogate.exception.NotFoundException;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import br.com.cloudport.servicogate.model.enums.StatusValidacaoDocumento;
import br.com.cloudport.servicogate.storage.DocumentoStorageService;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.time.LocalDateTime;
import javax.imageio.ImageIO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
public class ProcessamentoOcrExecutor {

    private static final Logger LOGGER = LoggerFactory.getLogger(ProcessamentoOcrExecutor.class);

    private final DocumentoAgendamentoRepository documentoAgendamentoRepository;
    private final DocumentoStorageService documentoStorageService;
    private final AgendamentoRealtimeService agendamentoRealtimeService;
    private final OcrIntegrationProperties properties;

    public ProcessamentoOcrExecutor(DocumentoAgendamentoRepository documentoAgendamentoRepository,
                                    DocumentoStorageService documentoStorageService,
                                    AgendamentoRealtimeService agendamentoRealtimeService,
                                    OcrIntegrationProperties properties) {
        this.documentoAgendamentoRepository = documentoAgendamentoRepository;
        this.documentoStorageService = documentoStorageService;
        this.agendamentoRealtimeService = agendamentoRealtimeService;
        this.properties = properties;
    }

    @Transactional
    public void processar(ProcessamentoOcrMensagem mensagem) {
        DocumentoAgendamento documento = documentoAgendamentoRepository.findById(mensagem.getDocumentoId())
                .orElseThrow(() -> new NotFoundException("Documento para OCR não encontrado"));
        documento.setStatusValidacao(StatusValidacaoDocumento.PROCESSANDO);
        documento.setMensagemValidacao("Documento em análise pelo OCR...");
        documentoAgendamentoRepository.save(documento);
        notificarAtualizacao(documento.getAgendamento());

        try {
            validarImagem(documento, properties.getTempoMaximoProcessamento());
            documento.setStatusValidacao(StatusValidacaoDocumento.VALIDADO);
            documento.setUltimaRevalidacao(LocalDateTime.now());
            documento.setMensagemValidacao("Documento validado automaticamente via OCR.");
            documentoAgendamentoRepository.save(documento);
            notificarAtualizacao(documento.getAgendamento());
            notificarRevalidacao(documento.getAgendamento());
            LOGGER.info("event=ocr.validado documentoId={} agendamentoId={}",
                    documento.getId(),
                    documento.getAgendamento() != null ? documento.getAgendamento().getId() : null);
        } catch (BusinessException ex) {
            LOGGER.warn("event=ocr.falha documentoId={} mensagem={}", documento.getId(), ex.getMessage());
            documento.setStatusValidacao(StatusValidacaoDocumento.FALHA);
            documento.setMensagemValidacao(ex.getMessage());
            documentoAgendamentoRepository.save(documento);
            notificarAtualizacao(documento.getAgendamento());
        } catch (IOException ex) {
            LOGGER.error("event=ocr.erro-leitura documentoId={}", documento.getId(), ex);
            documento.setStatusValidacao(StatusValidacaoDocumento.FALHA);
            documento.setMensagemValidacao("Não foi possível ler a imagem para validação.");
            documentoAgendamentoRepository.save(documento);
            notificarAtualizacao(documento.getAgendamento());
            throw new BusinessException("Falha ao acessar o arquivo para validação.", ex);
        }
    }

    private void validarImagem(DocumentoAgendamento documento, Duration timeout) throws IOException {
        Resource recurso = documentoStorageService.carregarComoResource(documento.getUrlDocumento());
        if (!recurso.exists()) {
            throw new BusinessException("Arquivo do documento não encontrado para validação.");
        }
        try (InputStream inputStream = recurso.getInputStream()) {
            long inicio = System.nanoTime();
            BufferedImage imagem = ImageIO.read(inputStream);
            long tempoProcessamento = System.nanoTime() - inicio;
            Duration duracao = Duration.ofNanos(tempoProcessamento);
            if (duracao.compareTo(timeout) > 0) {
                throw new BusinessException("Tempo limite excedido ao processar a imagem para OCR.");
            }
            if (imagem == null) {
                throw new BusinessException("O arquivo enviado não é uma imagem válida.");
            }
            if (imagem.getWidth() < 60 || imagem.getHeight() < 60) {
                throw new BusinessException("A imagem deve ter pelo menos 60x60 pixels.");
            }
        }
    }

    private void notificarAtualizacao(Agendamento agendamento) {
        if (agendamento != null) {
            agendamentoRealtimeService.notificarDocumentosAtualizados(agendamento);
        }
    }

    private void notificarRevalidacao(Agendamento agendamento) {
        if (agendamento != null) {
            agendamentoRealtimeService.notificarDocumentosRevalidados(agendamento);
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\ocr\ProcessamentoOcrListener.java ----- 
package br.com.cloudport.servicogate.integration.ocr;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.AmqpRejectAndDontRequeueException;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component
public class ProcessamentoOcrListener {

    private static final Logger LOGGER = LoggerFactory.getLogger(ProcessamentoOcrListener.class);

    private final ObjectMapper objectMapper;
    private final ProcessamentoOcrExecutor executor;

    public ProcessamentoOcrListener(ObjectMapper objectMapper, ProcessamentoOcrExecutor executor) {
        this.objectMapper = objectMapper;
        this.executor = executor;
    }

    @RabbitListener(queues = "${cloudport.gate.ocr.solicitacao-queue}")
    public void receberMensagem(String payload) {
        try {
            ProcessamentoOcrMensagem mensagem = objectMapper.readValue(payload, ProcessamentoOcrMensagem.class);
            LOGGER.debug("event=ocr.recebido documentoId={} agendamentoId={}",
                    mensagem.getDocumentoId(), mensagem.getAgendamentoId());
            executor.processar(mensagem);
        } catch (Exception ex) {
            LOGGER.error("Falha ao processar mensagem de OCR", ex);
            throw new AmqpRejectAndDontRequeueException("Falha ao processar mensagem de OCR", ex);
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\ocr\ProcessamentoOcrMensagem.java ----- 
package br.com.cloudport.servicogate.integration.ocr;

public class ProcessamentoOcrMensagem {

    private Long documentoId;
    private Long agendamentoId;
    private String chaveArmazenamento;

    public ProcessamentoOcrMensagem() {
    }

    public ProcessamentoOcrMensagem(Long documentoId, Long agendamentoId, String chaveArmazenamento) {
        this.documentoId = documentoId;
        this.agendamentoId = agendamentoId;
        this.chaveArmazenamento = chaveArmazenamento;
    }

    public static ProcessamentoOcrMensagem from(br.com.cloudport.servicogate.model.DocumentoAgendamento documento) {
        Long agendamentoId = documento.getAgendamento() != null ? documento.getAgendamento().getId() : null;
        return new ProcessamentoOcrMensagem(documento.getId(), agendamentoId, documento.getUrlDocumento());
    }

    public Long getDocumentoId() {
        return documentoId;
    }

    public void setDocumentoId(Long documentoId) {
        this.documentoId = documentoId;
    }

    public Long getAgendamentoId() {
        return agendamentoId;
    }

    public void setAgendamentoId(Long agendamentoId) {
        this.agendamentoId = agendamentoId;
    }

    public String getChaveArmazenamento() {
        return chaveArmazenamento;
    }

    public void setChaveArmazenamento(String chaveArmazenamento) {
        this.chaveArmazenamento = chaveArmazenamento;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\ocr\ProcessamentoOcrPublisher.java ----- 
package br.com.cloudport.servicogate.integration.ocr;

import br.com.cloudport.servicogate.config.OcrIntegrationProperties;
import br.com.cloudport.servicogate.exception.BusinessException;
import br.com.cloudport.servicogate.model.DocumentoAgendamento;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Component;

@Component
public class ProcessamentoOcrPublisher {

    private static final Logger LOGGER = LoggerFactory.getLogger(ProcessamentoOcrPublisher.class);

    private final RabbitTemplate rabbitTemplate;
    private final ObjectMapper objectMapper;
    private final OcrIntegrationProperties properties;

    public ProcessamentoOcrPublisher(RabbitTemplate rabbitTemplate,
                                     ObjectMapper objectMapper,
                                     OcrIntegrationProperties properties) {
        this.rabbitTemplate = rabbitTemplate;
        this.objectMapper = objectMapper;
        this.properties = properties;
    }

    public void enfileirarProcessamento(DocumentoAgendamento documento) {
        ProcessamentoOcrMensagem mensagem = ProcessamentoOcrMensagem.from(documento);
        try {
            String payload = objectMapper.writeValueAsString(mensagem);
            rabbitTemplate.convertAndSend(properties.getSolicitacaoQueue(), payload);
            LOGGER.debug("event=ocr.enfileirar documentoId={} agendamentoId={}",
                    mensagem.getDocumentoId(), mensagem.getAgendamentoId());
        } catch (JsonProcessingException ex) {
            LOGGER.error("Falha ao serializar solicitação de OCR", ex);
            throw new BusinessException("Falha ao solicitar validação automática do documento.", ex);
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\TosCacheNames.java ----- 
package br.com.cloudport.servicogate.integration.tos;

public final class TosCacheNames {

    public static final String BOOKING = "tosBookings";
    public static final String CONTAINER_STATUS = "tosContainerStatus";
    public static final String CUSTOMS_RELEASE = "tosCustomsRelease";

    private TosCacheNames() {
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\TosClient.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import br.com.cloudport.servicogate.integration.tos.model.TosBookingResponse;
import br.com.cloudport.servicogate.integration.tos.model.TosContainerStatusResponse;
import br.com.cloudport.servicogate.integration.tos.model.TosCustomsReleaseResponse;
import br.com.cloudport.servicogate.contingencia.ContingenciaProperties;
import br.com.cloudport.servicogate.monitoring.IntegracaoDegradacaoHandler;
import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.retry.Retry;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Supplier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientRequestException;
import org.springframework.web.reactive.function.client.WebClientResponseException;

@Component
public class TosClient {

    private static final Logger LOGGER = LoggerFactory.getLogger(TosClient.class);

    private final WebClient webClient;
    private final TosProperties properties;
    private final Retry retry;
    private final CircuitBreaker circuitBreaker;
    private final IntegracaoDegradacaoHandler degradacaoHandler;
    private final ContingenciaProperties contingenciaProperties;

    public TosClient(WebClient tosWebClient,
                     TosProperties properties,
                     Retry tosRetry,
                     CircuitBreaker tosCircuitBreaker,
                     IntegracaoDegradacaoHandler degradacaoHandler,
                     ContingenciaProperties contingenciaProperties) {
        this.webClient = tosWebClient;
        this.properties = properties;
        this.retry = tosRetry;
        this.circuitBreaker = tosCircuitBreaker;
        this.degradacaoHandler = degradacaoHandler;
        this.contingenciaProperties = contingenciaProperties;
    }

    public TosBookingResponse buscarBooking(String bookingNumber) {
        Supplier<TosBookingResponse> supplier = () -> webClient.get()
                .uri(uriBuilder -> uriBuilder.path(properties.getApi().getBookingPath())
                        .build(bookingNumber))
                .retrieve()
                .bodyToMono(TosBookingResponse.class)
                .block(properties.getApi().getTimeout());
        return executarComRetry(supplier, "booking", bookingNumber);
    }

    public TosContainerStatusResponse buscarStatusContainer(String containerNumber) {
        Supplier<TosContainerStatusResponse> supplier = () -> webClient.get()
                .uri(uriBuilder -> uriBuilder.path(properties.getApi().getContainerStatusPath())
                        .build(containerNumber))
                .retrieve()
                .bodyToMono(TosContainerStatusResponse.class)
                .block(properties.getApi().getTimeout());
        return executarComRetry(supplier, "container-status", containerNumber);
    }

    public TosCustomsReleaseResponse buscarLiberacaoAduaneira(String containerNumber) {
        Supplier<TosCustomsReleaseResponse> supplier = () -> webClient.get()
                .uri(uriBuilder -> uriBuilder.path(properties.getApi().getCustomsReleasePath())
                        .build(containerNumber))
                .retrieve()
                .bodyToMono(TosCustomsReleaseResponse.class)
                .block(properties.getApi().getTimeout());
        return executarComRetry(supplier, "customs-release", containerNumber);
    }

    private <T> T executarComRetry(Supplier<T> supplier, String recurso, String identificador) {
        Supplier<T> decorated = Retry.decorateSupplier(retry, supplier);
        decorated = CircuitBreaker.decorateSupplier(circuitBreaker, decorated);
        try {
            T result = decorated.get();
            LOGGER.info("event=tos.call.success resource={} identifier={}", recurso, identificador);
            return result;
        } catch (CallNotPermittedException ex) {
            String orientacao = String.format("%s Utilize as rotas de contingência /gate/contingencia/agendar e /gate/contingencia/liberar enquanto o TOS estiver indisponível.",
                    contingenciaProperties.getOrientacaoOperador());
            degradacaoHandler.registrarDegradacao("tos", "circuit-breaker", orientacao);
            throw new TosIntegrationException("Circuit breaker do TOS aberto. " + orientacao, ex);
        } catch (Exception ex) {
            throw tratarExcecao(ex, recurso, identificador);
        }
    }

    private RuntimeException tratarExcecao(Exception ex, String recurso, String identificador) {
        if (ex instanceof WebClientResponseException) {
            WebClientResponseException responseException = (WebClientResponseException) ex;
            HttpStatus status = responseException.getStatusCode();
            String body = responseException.getResponseBodyAsString();
            LOGGER.error("event=tos.call.error resource={} identifier={} status={} body={}",
                    recurso, identificador, status.value(), body);
            String detalhes = Optional.ofNullable(body)
                    .filter(value -> !value.isBlank())
                    .orElse("Corpo vazio");
            return new TosIntegrationException(String.format("TOS respondeu %s para %s %s: %s",
                    status.getReasonPhrase(), recurso, identificador, detalhes));
        }
        if (ex instanceof WebClientRequestException) {
            LOGGER.error("event=tos.call.error resource={} identifier={} cause={}",
                    recurso, identificador, Objects.toString(ex.getMessage()));
            degradacaoHandler.registrarDegradacao("tos", "request-exception",
                    "Verificar conectividade com o TOS e acionar contingência se as chamadas continuarem falhando.");
            return new TosIntegrationException(String.format("Falha de comunicação com TOS ao acessar %s %s",
                    recurso, identificador), ex);
        }
        LOGGER.error("event=tos.call.error resource={} identifier={} cause={}",
                recurso, identificador, Objects.toString(ex.getMessage()));
        degradacaoHandler.registrarDegradacao("tos", "unexpected-error",
                "Investigar erro inesperado e seguir o playbook de contingência do TOS.");
        return new TosIntegrationException(String.format("Erro inesperado ao acessar TOS para %s %s",
                recurso, identificador), ex);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\TosClientConfig.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import com.github.benmanes.caffeine.cache.Caffeine;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.retry.IntervalFunction;
import io.github.resilience4j.retry.Retry;
import io.github.resilience4j.retry.RetryConfig;
import java.util.concurrent.TimeUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cache.CacheManager;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.util.StringUtils;
import org.springframework.web.reactive.function.client.ExchangeFilterFunction;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;
import reactor.netty.http.client.HttpClient;

@Configuration
@EnableConfigurationProperties(TosProperties.class)
public class TosClientConfig {

    private static final Logger LOGGER = LoggerFactory.getLogger(TosClientConfig.class);

    @Bean
    public WebClient tosWebClient(TosProperties properties) {
        HttpClient httpClient = HttpClient.create()
                .responseTimeout(properties.getApi().getTimeout())
                .option(io.netty.channel.ChannelOption.CONNECT_TIMEOUT_MILLIS,
                        (int) properties.getApi().getTimeout().toMillis())
                .doOnConnected(conn -> conn.addHandlerLast(new io.netty.handler.timeout.ReadTimeoutHandler(
                        properties.getApi().getTimeout().toMillis(), TimeUnit.MILLISECONDS))
                        .addHandlerLast(new io.netty.handler.timeout.WriteTimeoutHandler(
                                properties.getApi().getTimeout().toMillis(), TimeUnit.MILLISECONDS)));

        WebClient.Builder builder = WebClient.builder()
                .baseUrl(properties.getApi().getBaseUrl())
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .filter(logRequest())
                .filter(logResponse());

        if (StringUtils.hasText(properties.getApi().getUsername())) {
            builder.defaultHeaders(headers -> headers.setBasicAuth(
                    properties.getApi().getUsername(),
                    properties.getApi().getPassword()));
        }

        return builder.build();
    }

    @Bean
    public Retry tosRetry(TosProperties properties) {
        TosProperties.RetryProperties retryProperties = properties.getRetry();
        IntervalFunction interval = IntervalFunction.ofExponentialBackoff(
                retryProperties.getInitialInterval().toMillis(),
                retryProperties.getMultiplier());

        RetryConfig config = RetryConfig.custom()
                .maxAttempts(retryProperties.getMaxAttempts())
                .intervalFunction(interval)
                .retryExceptions(Exception.class)
                .build();
        return Retry.of("tosClient", config);
    }

    @Bean
    public CircuitBreaker tosCircuitBreaker(CircuitBreakerRegistry registry) {
        return registry.circuitBreaker("tosApi");
    }

    @Bean
    public CacheManager cacheManager(TosProperties properties) {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager(
                TosCacheNames.BOOKING,
                TosCacheNames.CONTAINER_STATUS,
                TosCacheNames.CUSTOMS_RELEASE);
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(properties.getCache().getMaxSize())
                .expireAfterWrite(properties.getCache().getTtl()));
        cacheManager.setAllowNullValues(false);
        return cacheManager;
    }

    private ExchangeFilterFunction logRequest() {
        return ExchangeFilterFunction.ofRequestProcessor(clientRequest -> {
            LOGGER.info("event=tos.request method={} url={}", clientRequest.method(), clientRequest.url());
            return Mono.just(clientRequest);
        });
    }

    private ExchangeFilterFunction logResponse() {
        return ExchangeFilterFunction.ofResponseProcessor(clientResponse -> {
            LOGGER.info("event=tos.response status={} headers={}", clientResponse.statusCode(), clientResponse.headers().asHttpHeaders());
            return Mono.just(clientResponse);
        });
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\TosHealthIndicator.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.actuate.health.AbstractHealthIndicator;
import org.springframework.boot.actuate.health.Health;
import org.springframework.stereotype.Component;

@Component
public class TosHealthIndicator extends AbstractHealthIndicator {

    private final CircuitBreaker circuitBreaker;

    public TosHealthIndicator(@Qualifier("tosCircuitBreaker") CircuitBreaker circuitBreaker) {
        this.circuitBreaker = circuitBreaker;
    }

    @Override
    protected void doHealthCheck(Health.Builder builder) {
        CircuitBreaker.State state = circuitBreaker.getState();
        builder.withDetail("state", state.name())
                .withDetail("failureRate", circuitBreaker.getMetrics().getFailureRate())
                .withDetail("slowCallRate", circuitBreaker.getMetrics().getSlowCallRate());
        if (state == CircuitBreaker.State.CLOSED || state == CircuitBreaker.State.HALF_OPEN) {
            builder.up();
        } else {
            builder.down();
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\TosIntegrationException.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import br.com.cloudport.servicogate.exception.BusinessException;

public class TosIntegrationException extends BusinessException {

    public TosIntegrationException(String message) {
        super(message);
    }

    public TosIntegrationException(String message, Throwable cause) {
        super(message, cause);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\TosIntegrationService.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import br.com.cloudport.servicogate.app.gestor.dto.TosBookingInfo;
import br.com.cloudport.servicogate.app.gestor.dto.TosContainerStatus;
import br.com.cloudport.servicogate.app.gestor.dto.TosSyncResponse;
import br.com.cloudport.servicogate.integration.tos.model.TosCustomsReleaseResponse;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import java.util.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Service
public class TosIntegrationService {

    private static final Logger LOGGER = LoggerFactory.getLogger(TosIntegrationService.class);

    private final TosClient tosClient;
    private final TosResponseAdapter adapter;
    private final CacheManager cacheManager;

    public TosIntegrationService(TosClient tosClient,
                                 TosResponseAdapter adapter,
                                 CacheManager cacheManager) {
        this.tosClient = tosClient;
        this.adapter = adapter;
        this.cacheManager = cacheManager;
    }

    @Cacheable(cacheNames = TosCacheNames.BOOKING, key = "#bookingNumber")
    public TosBookingInfo obterBookingInfo(String bookingNumber) {
        TosBookingInfo info = adapter.toBookingInfo(tosClient.buscarBooking(bookingNumber));
        if (info != null) {
            LOGGER.info("event=tos.booking.sync booking={} liberado={} vessel={} voyage={}",
                    info.getBookingNumber(), info.isLiberado(), info.getVessel(), info.getVoyage());
        }
        return info;
    }

    @Cacheable(cacheNames = TosCacheNames.CONTAINER_STATUS, key = "#containerNumber")
    public TosContainerStatus obterStatusContainer(String containerNumber) {
        TosContainerStatus status = adapter.toContainerStatus(
                tosClient.buscarStatusContainer(containerNumber),
                obterLiberacaoAduaneira(containerNumber));
        if (status != null) {
            LOGGER.info("event=tos.container.sync container={} status={} gateLiberado={} customsLiberado={} motivo={}",
                    status.getContainerNumber(), status.getStatus(), status.isGateLiberado(),
                    status.isLiberacaoAduaneira(), status.getMotivoRestricao());
        }
        return status;
    }

    @Cacheable(cacheNames = TosCacheNames.CUSTOMS_RELEASE, key = "#containerNumber")
    public TosCustomsReleaseResponse obterLiberacaoAduaneira(String containerNumber) {
        return tosClient.buscarLiberacaoAduaneira(containerNumber);
    }

    public void limparCaches(String containerNumber) {
        if (!StringUtils.hasText(containerNumber)) {
            return;
        }
        evict(TosCacheNames.BOOKING, containerNumber);
        evict(TosCacheNames.CONTAINER_STATUS, containerNumber);
        evict(TosCacheNames.CUSTOMS_RELEASE, containerNumber);
        LOGGER.info("event=tos.cache.evict identifier={}", containerNumber);
    }

    private void evict(String cacheName, String key) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.evict(key);
        }
    }

    public void validarAgendamentoParaCriacao(String bookingNumber, TipoOperacao tipoOperacao) {
        if (!StringUtils.hasText(bookingNumber)) {
            return;
        }
        TosBookingInfo bookingInfo = obterBookingInfo(bookingNumber);
        if (bookingInfo == null) {
            throw new TosIntegrationException(String.format("Booking %s não localizado no TOS", bookingNumber));
        }
        if (!bookingInfo.isLiberado()) {
            String motivo = Optional.ofNullable(bookingInfo.getMotivoRestricao())
                    .filter(StringUtils::hasText)
                    .orElse("Motivo não informado pelo TOS");
            throw new TosIntegrationException(String.format(
                    "TOS negou criação do agendamento para booking %s (%s): %s",
                    bookingNumber, tipoOperacao, motivo));
        }
        LOGGER.info("event=tos.booking.validated booking={} tipoOperacao={} liberado={}",
                bookingInfo.getBookingNumber(), tipoOperacao, bookingInfo.isLiberado());
    }

    public TosContainerStatus validarParaEntrada(Agendamento agendamento) {
        String identificador = agendamento.getCodigo();
        if (!StringUtils.hasText(identificador)) {
            return null;
        }
        TosContainerStatus status = obterStatusContainer(identificador);
        if (status == null) {
            throw new TosIntegrationException(String.format("Status do contêiner %s não localizado no TOS",
                    identificador));
        }
        if (!status.isGateLiberado()) {
            String motivo = Optional.ofNullable(status.getMotivoRestricao())
                    .filter(StringUtils::hasText)
                    .orElse("TOS não informou motivo");
            throw new TosIntegrationException(String.format(
                    "TOS bloqueou o gate para o contêiner %s: %s", identificador, motivo));
        }
        if (!status.isLiberacaoAduaneira()) {
            String motivo = Optional.ofNullable(status.getMotivoRestricao())
                    .filter(StringUtils::hasText)
                    .orElse("Contêiner sem liberação aduaneira no TOS");
            throw new TosIntegrationException(String.format(
                    "TOS indicou pendência aduaneira para o contêiner %s: %s", identificador, motivo));
        }
        LOGGER.info("event=tos.container.validated agendamento={} container={} status={} customsLiberado={}",
                agendamento.getId(), status.getContainerNumber(), status.getStatus(), status.isLiberacaoAduaneira());
        return status;
    }

    public TosSyncResponse sincronizar(Agendamento agendamento) {
        String identificador = agendamento.getCodigo();
        boolean possuiIdentificador = StringUtils.hasText(identificador);
        if (possuiIdentificador) {
            limparCaches(identificador);
        }
        TosBookingInfo bookingInfo = possuiIdentificador ? obterBookingInfo(identificador) : null;
        TosContainerStatus containerStatus = possuiIdentificador ? obterStatusContainer(identificador) : null;
        LOGGER.info("event=tos.sync.completed agendamento={} booking={} container={}", agendamento.getId(),
                bookingInfo != null ? bookingInfo.getBookingNumber() : null,
                containerStatus != null ? containerStatus.getContainerNumber() : null);
        return new TosSyncResponse(agendamento.getId(), bookingInfo, containerStatus);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\TosProperties.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import java.time.Duration;
import java.time.temporal.ChronoUnit;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.NestedConfigurationProperty;
import org.springframework.boot.convert.DurationUnit;

@ConfigurationProperties(prefix = "cloudport.tos")
public class TosProperties {

    @NestedConfigurationProperty
    private final ApiProperties api = new ApiProperties();

    @NestedConfigurationProperty
    private final RetryProperties retry = new RetryProperties();

    @NestedConfigurationProperty
    private final CacheProperties cache = new CacheProperties();

    public ApiProperties getApi() {
        return api;
    }

    public RetryProperties getRetry() {
        return retry;
    }

    public CacheProperties getCache() {
        return cache;
    }

    public static class ApiProperties {

        private String baseUrl;

        @DurationUnit(ChronoUnit.MILLIS)
        private Duration timeout = Duration.ofSeconds(5);

        private String bookingPath = "/tos/bookings/{bookingNumber}";

        private String containerStatusPath = "/tos/containers/{containerNumber}/status";

        private String customsReleasePath = "/tos/containers/{containerNumber}/customs";

        private String username;

        private String password;

        public String getBaseUrl() {
            return baseUrl;
        }

        public void setBaseUrl(String baseUrl) {
            this.baseUrl = baseUrl;
        }

        public Duration getTimeout() {
            return timeout;
        }

        public void setTimeout(Duration timeout) {
            this.timeout = timeout;
        }

        public String getBookingPath() {
            return bookingPath;
        }

        public void setBookingPath(String bookingPath) {
            this.bookingPath = bookingPath;
        }

        public String getContainerStatusPath() {
            return containerStatusPath;
        }

        public void setContainerStatusPath(String containerStatusPath) {
            this.containerStatusPath = containerStatusPath;
        }

        public String getCustomsReleasePath() {
            return customsReleasePath;
        }

        public void setCustomsReleasePath(String customsReleasePath) {
            this.customsReleasePath = customsReleasePath;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }
    }

    public static class RetryProperties {

        private int maxAttempts = 3;

        @DurationUnit(ChronoUnit.MILLIS)
        private Duration initialInterval = Duration.ofMillis(500);

        private double multiplier = 2.0;

        public int getMaxAttempts() {
            return maxAttempts;
        }

        public void setMaxAttempts(int maxAttempts) {
            this.maxAttempts = maxAttempts;
        }

        public Duration getInitialInterval() {
            return initialInterval;
        }

        public void setInitialInterval(Duration initialInterval) {
            this.initialInterval = initialInterval;
        }

        public double getMultiplier() {
            return multiplier;
        }

        public void setMultiplier(double multiplier) {
            this.multiplier = multiplier;
        }
    }

    public static class CacheProperties {

        private long maxSize = 500L;

        private Duration ttl = Duration.ofMinutes(5);

        public long getMaxSize() {
            return maxSize;
        }

        public void setMaxSize(long maxSize) {
            this.maxSize = maxSize;
        }

        public Duration getTtl() {
            return ttl;
        }

        public void setTtl(Duration ttl) {
            this.ttl = ttl;
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\TosResponseAdapter.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import br.com.cloudport.servicogate.app.gestor.dto.TosBookingInfo;
import br.com.cloudport.servicogate.app.gestor.dto.TosContainerStatus;
import br.com.cloudport.servicogate.integration.tos.model.TosBookingResponse;
import br.com.cloudport.servicogate.integration.tos.model.TosContainerStatusResponse;
import br.com.cloudport.servicogate.integration.tos.model.TosCustomsReleaseResponse;
import java.time.LocalDateTime;
import java.util.Optional;
import org.springframework.stereotype.Component;

@Component
public class TosResponseAdapter {

    public TosBookingInfo toBookingInfo(TosBookingResponse response) {
        if (response == null) {
            return null;
        }
        LocalDateTime cutoff = Optional.ofNullable(response.getCutoff())
                .map(offsetDateTime -> offsetDateTime.toLocalDateTime())
                .orElse(null);
        return new TosBookingInfo(
                response.getBookingNumber(),
                response.getVessel(),
                response.getVoyage(),
                cutoff,
                response.isReleased(),
                response.getDenialReason()
        );
    }

    public TosContainerStatus toContainerStatus(TosContainerStatusResponse statusResponse,
                                                TosCustomsReleaseResponse customsResponse) {
        if (statusResponse == null) {
            return null;
        }
        LocalDateTime lastUpdate = Optional.ofNullable(statusResponse.getLastUpdate())
                .map(offsetDateTime -> offsetDateTime.toLocalDateTime())
                .orElse(null);
        boolean customsReleased = customsResponse == null || customsResponse.isReleased();
        String holdReason = Optional.ofNullable(customsResponse)
                .map(TosCustomsReleaseResponse::getDenialReason)
                .filter(reason -> !reason.isBlank())
                .orElse(statusResponse.getHoldReason());
        return new TosContainerStatus(
                statusResponse.getContainerNumber(),
                statusResponse.getStatus(),
                statusResponse.isGateAllowed(),
                customsReleased,
                lastUpdate,
                holdReason
        );
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\model\TosBookingResponse.java ----- 
package br.com.cloudport.servicogate.integration.tos.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.OffsetDateTime;

public class TosBookingResponse {

    @JsonProperty("bookingNumber")
    private String bookingNumber;

    @JsonProperty("released")
    private boolean released;

    @JsonProperty("denialReason")
    private String denialReason;

    @JsonProperty("vessel")
    private String vessel;

    @JsonProperty("voyage")
    private String voyage;

    @JsonProperty("cutoff")
    private OffsetDateTime cutoff;

    public String getBookingNumber() {
        return bookingNumber;
    }

    public void setBookingNumber(String bookingNumber) {
        this.bookingNumber = bookingNumber;
    }

    public boolean isReleased() {
        return released;
    }

    public void setReleased(boolean released) {
        this.released = released;
    }

    public String getDenialReason() {
        return denialReason;
    }

    public void setDenialReason(String denialReason) {
        this.denialReason = denialReason;
    }

    public String getVessel() {
        return vessel;
    }

    public void setVessel(String vessel) {
        this.vessel = vessel;
    }

    public String getVoyage() {
        return voyage;
    }

    public void setVoyage(String voyage) {
        this.voyage = voyage;
    }

    public OffsetDateTime getCutoff() {
        return cutoff;
    }

    public void setCutoff(OffsetDateTime cutoff) {
        this.cutoff = cutoff;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\model\TosContainerStatusResponse.java ----- 
package br.com.cloudport.servicogate.integration.tos.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.OffsetDateTime;

public class TosContainerStatusResponse {

    @JsonProperty("containerNumber")
    private String containerNumber;

    @JsonProperty("status")
    private String status;

    @JsonProperty("gateAllowed")
    private boolean gateAllowed;

    @JsonProperty("holdReason")
    private String holdReason;

    @JsonProperty("lastUpdate")
    private OffsetDateTime lastUpdate;

    public String getContainerNumber() {
        return containerNumber;
    }

    public void setContainerNumber(String containerNumber) {
        this.containerNumber = containerNumber;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public boolean isGateAllowed() {
        return gateAllowed;
    }

    public void setGateAllowed(boolean gateAllowed) {
        this.gateAllowed = gateAllowed;
    }

    public String getHoldReason() {
        return holdReason;
    }

    public void setHoldReason(String holdReason) {
        this.holdReason = holdReason;
    }

    public OffsetDateTime getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(OffsetDateTime lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\tos\model\TosCustomsReleaseResponse.java ----- 
package br.com.cloudport.servicogate.integration.tos.model;

import com.fasterxml.jackson.annotation.JsonProperty;

public class TosCustomsReleaseResponse {

    @JsonProperty("containerNumber")
    private String containerNumber;

    @JsonProperty("released")
    private boolean released;

    @JsonProperty("denialReason")
    private String denialReason;

    public String getContainerNumber() {
        return containerNumber;
    }

    public void setContainerNumber(String containerNumber) {
        this.containerNumber = containerNumber;
    }

    public boolean isReleased() {
        return released;
    }

    public void setReleased(boolean released) {
        this.released = released;
    }

    public String getDenialReason() {
        return denialReason;
    }

    public void setDenialReason(String denialReason) {
        this.denialReason = denialReason;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\yard\ClienteStatusPatio.java ----- 
package br.com.cloudport.servicogate.integration.yard;

import br.com.cloudport.servicogate.integration.yard.dto.StatusPatioResposta;
import br.com.cloudport.servicogate.monitoring.IntegracaoDegradacaoHandler;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import java.net.URI;
import java.util.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

@Component
public class ClienteStatusPatio {

    private static final Logger LOGGER = LoggerFactory.getLogger(ClienteStatusPatio.class);

    private final RestTemplate restTemplate;
    private final String baseUrl;
    private final String statusPath;
    private final IntegracaoDegradacaoHandler degradacaoHandler;
    private final String fallbackOrientacao;

    public ClienteStatusPatio(RestTemplate restTemplate,
                              @Value("${cloudport.integracoes.yard.base-url:http://localhost:8083}") String baseUrl,
                              @Value("${cloudport.integracoes.yard.status-path:/yard/status}") String statusPath,
                              IntegracaoDegradacaoHandler degradacaoHandler,
                              @Value("${cloudport.integracoes.yard.fallback-orientacao:Consultar equipe de pátio para orientações manuais.}")
                                      String fallbackOrientacao) {
        this.restTemplate = restTemplate;
        this.baseUrl = baseUrl;
        this.statusPath = statusPath;
        this.degradacaoHandler = degradacaoHandler;
        this.fallbackOrientacao = fallbackOrientacao;
    }

    @CircuitBreaker(name = "yardStatus", fallbackMethod = "fallbackConsultarStatus")
    public Optional<StatusPatioResposta> consultarStatus(String authorizationHeader) {
        if (!StringUtils.hasText(baseUrl)) {
            return Optional.empty();
        }
        try {
            HttpHeaders headers = new HttpHeaders();
            if (StringUtils.hasText(authorizationHeader)) {
                headers.set(HttpHeaders.AUTHORIZATION, authorizationHeader);
            }
            HttpEntity<Void> entity = new HttpEntity<>(headers);
            URI uri = UriComponentsBuilder.fromHttpUrl(baseUrl)
                    .path(statusPath)
                    .build(true)
                    .toUri();
            ResponseEntity<StatusPatioResposta> resposta = restTemplate.exchange(uri, HttpMethod.GET, entity, StatusPatioResposta.class);
            return Optional.ofNullable(resposta.getBody());
        } catch (RestClientException ex) {
            LOGGER.debug("Falha ao consultar status do pátio", ex);
            return Optional.empty();
        }
    }

    @SuppressWarnings("unused")
    private Optional<StatusPatioResposta> fallbackConsultarStatus(String authorizationHeader, Throwable throwable) {
        degradacaoHandler.registrarDegradacao("servico-yard", "circuit-breaker", fallbackOrientacao);
        LOGGER.warn("event=yard.status.fallback orientacao=\"{}\" causa={}", fallbackOrientacao,
                throwable != null ? throwable.getMessage() : "indefinida");
        return Optional.empty();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\integration\yard\dto\StatusPatioResposta.java ----- 
package br.com.cloudport.servicogate.integration.yard.dto;

public class StatusPatioResposta {

    private String status;
    private String descricao;
    private String verificadoEm;

    public StatusPatioResposta() {
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public String getVerificadoEm() {
        return verificadoEm;
    }

    public void setVerificadoEm(String verificadoEm) {
        this.verificadoEm = verificadoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\AbstractAuditableEntity.java ----- 
package br.com.cloudport.servicogate.model;

import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.MappedSuperclass;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;

@MappedSuperclass
public abstract class AbstractAuditableEntity {

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        LocalDateTime now = LocalDateTime.now();
        this.createdAt = now;
        this.updatedAt = now;
    }

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\Agendamento.java ----- 
package br.com.cloudport.servicogate.model;

import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;

@Entity
@Table(name = "agendamento")
public class Agendamento extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "codigo", nullable = false, unique = true, length = 40)
    private String codigo;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_operacao", nullable = false, length = 40)
    private TipoOperacao tipoOperacao;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 40)
    private StatusAgendamento status;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "transportadora_id", nullable = false)
    private Transportadora transportadora;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "motorista_id", nullable = false)
    private Motorista motorista;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "veiculo_id", nullable = false)
    private Veiculo veiculo;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "janela_atendimento_id", nullable = false)
    private JanelaAtendimento janelaAtendimento;

    @Column(name = "horario_previsto_chegada")
    private LocalDateTime horarioPrevistoChegada;

    @Column(name = "horario_previsto_saida")
    private LocalDateTime horarioPrevistoSaida;

    @Column(name = "horario_real_chegada")
    private LocalDateTime horarioRealChegada;

    @Column(name = "horario_real_saida")
    private LocalDateTime horarioRealSaida;

    @Column(name = "observacoes", length = 500)
    private String observacoes;

    @OneToMany(mappedBy = "agendamento", fetch = FetchType.LAZY)
    private List<DocumentoAgendamento> documentos = new ArrayList<>();

    @OneToOne(mappedBy = "agendamento", fetch = FetchType.LAZY)
    private GatePass gatePass;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public TipoOperacao getTipoOperacao() {
        return tipoOperacao;
    }

    public void setTipoOperacao(TipoOperacao tipoOperacao) {
        this.tipoOperacao = tipoOperacao;
    }

    public StatusAgendamento getStatus() {
        return status;
    }

    public void setStatus(StatusAgendamento status) {
        this.status = status;
    }

    public Transportadora getTransportadora() {
        return transportadora;
    }

    public void setTransportadora(Transportadora transportadora) {
        this.transportadora = transportadora;
    }

    public Motorista getMotorista() {
        return motorista;
    }

    public void setMotorista(Motorista motorista) {
        this.motorista = motorista;
    }

    public Veiculo getVeiculo() {
        return veiculo;
    }

    public void setVeiculo(Veiculo veiculo) {
        this.veiculo = veiculo;
    }

    public JanelaAtendimento getJanelaAtendimento() {
        return janelaAtendimento;
    }

    public void setJanelaAtendimento(JanelaAtendimento janelaAtendimento) {
        this.janelaAtendimento = janelaAtendimento;
    }

    public LocalDateTime getHorarioPrevistoChegada() {
        return horarioPrevistoChegada;
    }

    public void setHorarioPrevistoChegada(LocalDateTime horarioPrevistoChegada) {
        this.horarioPrevistoChegada = horarioPrevistoChegada;
    }

    public LocalDateTime getHorarioPrevistoSaida() {
        return horarioPrevistoSaida;
    }

    public void setHorarioPrevistoSaida(LocalDateTime horarioPrevistoSaida) {
        this.horarioPrevistoSaida = horarioPrevistoSaida;
    }

    public LocalDateTime getHorarioRealChegada() {
        return horarioRealChegada;
    }

    public void setHorarioRealChegada(LocalDateTime horarioRealChegada) {
        this.horarioRealChegada = horarioRealChegada;
    }

    public LocalDateTime getHorarioRealSaida() {
        return horarioRealSaida;
    }

    public void setHorarioRealSaida(LocalDateTime horarioRealSaida) {
        this.horarioRealSaida = horarioRealSaida;
    }

    public String getObservacoes() {
        return observacoes;
    }

    public void setObservacoes(String observacoes) {
        this.observacoes = observacoes;
    }

    public List<DocumentoAgendamento> getDocumentos() {
        return documentos;
    }

    public void setDocumentos(List<DocumentoAgendamento> documentos) {
        this.documentos = documentos;
    }

    public GatePass getGatePass() {
        return gatePass;
    }

    public void setGatePass(GatePass gatePass) {
        this.gatePass = gatePass;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\DocumentoAgendamento.java ----- 
package br.com.cloudport.servicogate.model;

import java.time.LocalDateTime;
import br.com.cloudport.servicogate.model.enums.StatusValidacaoDocumento;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "documento_agendamento")
public class DocumentoAgendamento extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "tipo_documento", nullable = false, length = 80)
    private String tipoDocumento;

    @Column(name = "numero", length = 80)
    private String numero;

    @Column(name = "url_documento", length = 255)
    private String urlDocumento;

    @Column(name = "nome_arquivo", length = 255)
    private String nomeArquivo;

    @Column(name = "content_type", length = 120)
    private String contentType;

    @Column(name = "tamanho_bytes")
    private Long tamanhoBytes;

    @Column(name = "ultima_revalidacao")
    private LocalDateTime ultimaRevalidacao;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_validacao", nullable = false, length = 30)
    private StatusValidacaoDocumento statusValidacao = StatusValidacaoDocumento.PROCESSANDO;

    @Column(name = "mensagem_validacao", length = 500)
    private String mensagemValidacao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "agendamento_id", nullable = false)
    private Agendamento agendamento;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTipoDocumento() {
        return tipoDocumento;
    }

    public void setTipoDocumento(String tipoDocumento) {
        this.tipoDocumento = tipoDocumento;
    }

    public String getNumero() {
        return numero;
    }

    public void setNumero(String numero) {
        this.numero = numero;
    }

    public String getUrlDocumento() {
        return urlDocumento;
    }

    public void setUrlDocumento(String urlDocumento) {
        this.urlDocumento = urlDocumento;
    }

    public String getNomeArquivo() {
        return nomeArquivo;
    }

    public void setNomeArquivo(String nomeArquivo) {
        this.nomeArquivo = nomeArquivo;
    }

    public String getContentType() {
        return contentType;
    }

    public void setContentType(String contentType) {
        this.contentType = contentType;
    }

    public Long getTamanhoBytes() {
        return tamanhoBytes;
    }

    public void setTamanhoBytes(Long tamanhoBytes) {
        this.tamanhoBytes = tamanhoBytes;
    }

    public LocalDateTime getUltimaRevalidacao() {
        return ultimaRevalidacao;
    }

    public void setUltimaRevalidacao(LocalDateTime ultimaRevalidacao) {
        this.ultimaRevalidacao = ultimaRevalidacao;
    }

    public StatusValidacaoDocumento getStatusValidacao() {
        return statusValidacao;
    }

    public void setStatusValidacao(StatusValidacaoDocumento statusValidacao) {
        this.statusValidacao = statusValidacao;
    }

    public String getMensagemValidacao() {
        return mensagemValidacao;
    }

    public void setMensagemValidacao(String mensagemValidacao) {
        this.mensagemValidacao = mensagemValidacao;
    }

    public Agendamento getAgendamento() {
        return agendamento;
    }

    public void setAgendamento(Agendamento agendamento) {
        this.agendamento = agendamento;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\GateEvent.java ----- 
package br.com.cloudport.servicogate.model;

import br.com.cloudport.servicogate.model.enums.MotivoExcecao;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "gate_event")
public class GateEvent extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 40)
    private StatusGate status;

    @Enumerated(EnumType.STRING)
    @Column(name = "motivo_excecao", length = 40)
    private MotivoExcecao motivoExcecao;

    @Column(name = "observacao", length = 500)
    private String observacao;

    @Column(name = "usuario_responsavel", length = 80)
    private String usuarioResponsavel;

    @Column(name = "registrado_em", nullable = false)
    private LocalDateTime registradoEm;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "gate_pass_id", nullable = false)
    private GatePass gatePass;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public StatusGate getStatus() {
        return status;
    }

    public void setStatus(StatusGate status) {
        this.status = status;
    }

    public MotivoExcecao getMotivoExcecao() {
        return motivoExcecao;
    }

    public void setMotivoExcecao(MotivoExcecao motivoExcecao) {
        this.motivoExcecao = motivoExcecao;
    }

    public String getObservacao() {
        return observacao;
    }

    public void setObservacao(String observacao) {
        this.observacao = observacao;
    }

    public String getUsuarioResponsavel() {
        return usuarioResponsavel;
    }

    public void setUsuarioResponsavel(String usuarioResponsavel) {
        this.usuarioResponsavel = usuarioResponsavel;
    }

    public LocalDateTime getRegistradoEm() {
        return registradoEm;
    }

    public void setRegistradoEm(LocalDateTime registradoEm) {
        this.registradoEm = registradoEm;
    }

    public GatePass getGatePass() {
        return gatePass;
    }

    public void setGatePass(GatePass gatePass) {
        this.gatePass = gatePass;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\GateOcorrencia.java ----- 
package br.com.cloudport.servicogate.model;

import br.com.cloudport.servicogate.model.enums.NivelEvento;
import br.com.cloudport.servicogate.model.enums.TipoOcorrenciaOperador;
import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "gate_ocorrencia")
public class GateOcorrencia extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo", nullable = false, length = 60)
    private TipoOcorrenciaOperador tipo;

    @Enumerated(EnumType.STRING)
    @Column(name = "nivel", nullable = false, length = 40)
    private NivelEvento nivel;

    @Column(name = "descricao", nullable = false, length = 500)
    private String descricao;

    @Column(name = "registrado_em", nullable = false)
    private LocalDateTime registradoEm;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "veiculo_id")
    private Veiculo veiculo;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "transportadora_id")
    private Transportadora transportadora;

    @Column(name = "usuario_responsavel", length = 80)
    private String usuarioResponsavel;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public TipoOcorrenciaOperador getTipo() {
        return tipo;
    }

    public void setTipo(TipoOcorrenciaOperador tipo) {
        this.tipo = tipo;
    }

    public NivelEvento getNivel() {
        return nivel;
    }

    public void setNivel(NivelEvento nivel) {
        this.nivel = nivel;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public LocalDateTime getRegistradoEm() {
        return registradoEm;
    }

    public void setRegistradoEm(LocalDateTime registradoEm) {
        this.registradoEm = registradoEm;
    }

    public Veiculo getVeiculo() {
        return veiculo;
    }

    public void setVeiculo(Veiculo veiculo) {
        this.veiculo = veiculo;
    }

    public Transportadora getTransportadora() {
        return transportadora;
    }

    public void setTransportadora(Transportadora transportadora) {
        this.transportadora = transportadora;
    }

    public String getUsuarioResponsavel() {
        return usuarioResponsavel;
    }

    public void setUsuarioResponsavel(String usuarioResponsavel) {
        this.usuarioResponsavel = usuarioResponsavel;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\GatePass.java ----- 
package br.com.cloudport.servicogate.model;

import br.com.cloudport.servicogate.model.enums.StatusGate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;

@Entity
@Table(name = "gate_pass")
public class GatePass extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "codigo", nullable = false, unique = true, length = 40)
    private String codigo;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 40)
    private StatusGate status;

    @Column(name = "token", nullable = false, length = 120)
    private String token;

    @Column(name = "data_entrada")
    private LocalDateTime dataEntrada;

    @Column(name = "data_saida")
    private LocalDateTime dataSaida;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "agendamento_id", nullable = false, unique = true)
    private Agendamento agendamento;

    @OneToMany(mappedBy = "gatePass", fetch = FetchType.LAZY)
    private List<GateEvent> eventos = new ArrayList<>();

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public StatusGate getStatus() {
        return status;
    }

    public void setStatus(StatusGate status) {
        this.status = status;
    }

    public String getToken() {
        return token;
    }

    public void setToken(String token) {
        this.token = token;
    }

    public LocalDateTime getDataEntrada() {
        return dataEntrada;
    }

    public void setDataEntrada(LocalDateTime dataEntrada) {
        this.dataEntrada = dataEntrada;
    }

    public LocalDateTime getDataSaida() {
        return dataSaida;
    }

    public void setDataSaida(LocalDateTime dataSaida) {
        this.dataSaida = dataSaida;
    }

    public Agendamento getAgendamento() {
        return agendamento;
    }

    public void setAgendamento(Agendamento agendamento) {
        this.agendamento = agendamento;
    }

    public List<GateEvent> getEventos() {
        return eventos;
    }

    public void setEventos(List<GateEvent> eventos) {
        this.eventos = eventos;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\JanelaAtendimento.java ----- 
package br.com.cloudport.servicogate.model;

import br.com.cloudport.servicogate.model.enums.CanalEntrada;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

@Entity
@Table(name = "janela_atendimento")
public class JanelaAtendimento extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "data", nullable = false)
    private LocalDate data;

    @Column(name = "hora_inicio", nullable = false)
    private LocalTime horaInicio;

    @Column(name = "hora_fim", nullable = false)
    private LocalTime horaFim;

    @Column(name = "capacidade", nullable = false)
    private Integer capacidade;

    @Enumerated(EnumType.STRING)
    @Column(name = "canal_entrada", nullable = false, length = 40)
    private CanalEntrada canalEntrada;

    @OneToMany(mappedBy = "janelaAtendimento", fetch = FetchType.LAZY)
    private List<Agendamento> agendamentos = new ArrayList<>();

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public LocalDate getData() {
        return data;
    }

    public void setData(LocalDate data) {
        this.data = data;
    }

    public LocalTime getHoraInicio() {
        return horaInicio;
    }

    public void setHoraInicio(LocalTime horaInicio) {
        this.horaInicio = horaInicio;
    }

    public LocalTime getHoraFim() {
        return horaFim;
    }

    public void setHoraFim(LocalTime horaFim) {
        this.horaFim = horaFim;
    }

    public Integer getCapacidade() {
        return capacidade;
    }

    public void setCapacidade(Integer capacidade) {
        this.capacidade = capacidade;
    }

    public CanalEntrada getCanalEntrada() {
        return canalEntrada;
    }

    public void setCanalEntrada(CanalEntrada canalEntrada) {
        this.canalEntrada = canalEntrada;
    }

    public List<Agendamento> getAgendamentos() {
        return agendamentos;
    }

    public void setAgendamentos(List<Agendamento> agendamentos) {
        this.agendamentos = agendamentos;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\Motorista.java ----- 
package br.com.cloudport.servicogate.model;

import java.util.ArrayList;
import java.util.List;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;

@Entity
@Table(name = "motorista")
public class Motorista extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nome", nullable = false, length = 120)
    private String nome;

    @Column(name = "documento", nullable = false, length = 20)
    private String documento;

    @Column(name = "telefone", length = 20)
    private String telefone;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "transportadora_id", nullable = false)
    private Transportadora transportadora;

    @OneToMany(mappedBy = "motorista", fetch = FetchType.LAZY)
    private List<Agendamento> agendamentos = new ArrayList<>();

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public String getTelefone() {
        return telefone;
    }

    public void setTelefone(String telefone) {
        this.telefone = telefone;
    }

    public Transportadora getTransportadora() {
        return transportadora;
    }

    public void setTransportadora(Transportadora transportadora) {
        this.transportadora = transportadora;
    }

    public List<Agendamento> getAgendamentos() {
        return agendamentos;
    }

    public void setAgendamentos(List<Agendamento> agendamentos) {
        this.agendamentos = agendamentos;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\Transportadora.java ----- 
package br.com.cloudport.servicogate.model;

import java.util.ArrayList;
import java.util.List;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

@Entity
@Table(name = "transportadora")
public class Transportadora extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nome", nullable = false, length = 120)
    private String nome;

    @Column(name = "documento", nullable = false, unique = true, length = 20)
    private String documento;

    @Column(name = "contato", length = 120)
    private String contato;

    @OneToMany(mappedBy = "transportadora", fetch = FetchType.LAZY)
    private List<Motorista> motoristas = new ArrayList<>();

    @OneToMany(mappedBy = "transportadora", fetch = FetchType.LAZY)
    private List<Veiculo> veiculos = new ArrayList<>();

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public String getContato() {
        return contato;
    }

    public void setContato(String contato) {
        this.contato = contato;
    }

    public List<Motorista> getMotoristas() {
        return motoristas;
    }

    public void setMotoristas(List<Motorista> motoristas) {
        this.motoristas = motoristas;
    }

    public List<Veiculo> getVeiculos() {
        return veiculos;
    }

    public void setVeiculos(List<Veiculo> veiculos) {
        this.veiculos = veiculos;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\Veiculo.java ----- 
package br.com.cloudport.servicogate.model;

import java.util.ArrayList;
import java.util.List;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;

@Entity
@Table(name = "veiculo")
public class Veiculo extends AbstractAuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "placa", nullable = false, unique = true, length = 10)
    private String placa;

    @Column(name = "modelo", length = 60)
    private String modelo;

    @Column(name = "tipo", length = 40)
    private String tipo;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "transportadora_id", nullable = false)
    private Transportadora transportadora;

    @OneToMany(mappedBy = "veiculo", fetch = FetchType.LAZY)
    private List<Agendamento> agendamentos = new ArrayList<>();

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getPlaca() {
        return placa;
    }

    public void setPlaca(String placa) {
        this.placa = placa;
    }

    public String getModelo() {
        return modelo;
    }

    public void setModelo(String modelo) {
        this.modelo = modelo;
    }

    public String getTipo() {
        return tipo;
    }

    public void setTipo(String tipo) {
        this.tipo = tipo;
    }

    public Transportadora getTransportadora() {
        return transportadora;
    }

    public void setTransportadora(Transportadora transportadora) {
        this.transportadora = transportadora;
    }

    public List<Agendamento> getAgendamentos() {
        return agendamentos;
    }

    public void setAgendamentos(List<Agendamento> agendamentos) {
        this.agendamentos = agendamentos;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\enums\CanalEntrada.java ----- 
package br.com.cloudport.servicogate.model.enums;

public enum CanalEntrada {
    PORTARIA_PRINCIPAL("Portaria principal"),
    BALANCA("Balança"),
    ALCANCE_REMOTO("Agendamento remoto"),
    APLICATIVO_MOTORISTA("Aplicativo do motorista"),
    INTEGRACAO_TOS("Integração TOS");

    private final String descricao;

    CanalEntrada(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\enums\MotivoExcecao.java ----- 
package br.com.cloudport.servicogate.model.enums;

public enum MotivoExcecao {
    DOCUMENTACAO_INCOMPLETA("Documentação incompleta"),
    DIVERGENCIA_CARGA("Divergência de carga"),
    ATRASO_PROGRAMADO("Atraso programado"),
    FALHA_SEGURANCA("Falha de segurança"),
    OUTROS("Outros");

    private final String descricao;

    MotivoExcecao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\enums\NivelEvento.java ----- 
package br.com.cloudport.servicogate.model.enums;

public enum NivelEvento {
    INFO("Informativo"),
    ALERTA("Alerta"),
    CRITICA("Crítica"),
    OPERACIONAL("Operacional");

    private final String descricao;

    NivelEvento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\enums\StatusAgendamento.java ----- 
package br.com.cloudport.servicogate.model.enums;

public enum StatusAgendamento {
    PENDENTE("Pendente"),
    CONFIRMADO("Confirmado"),
    EM_ATENDIMENTO("Em atendimento"),
    EM_EXECUCAO("Em execução"),
    CONCLUIDO("Concluído"),
    COMPLETO("Completo"),
    NO_SHOW("No show"),
    CANCELADO("Cancelado");

    private final String descricao;

    StatusAgendamento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\enums\StatusGate.java ----- 
package br.com.cloudport.servicogate.model.enums;

public enum StatusGate {
    AGUARDANDO_ENTRADA("Aguardando entrada"),
    EM_PROCESSAMENTO("Em processamento"),
    LIBERADO("Liberado"),
    RETIDO("Retido"),
    FINALIZADO("Finalizado");

    private final String descricao;

    StatusGate(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\enums\StatusValidacaoDocumento.java ----- 
package br.com.cloudport.servicogate.model.enums;

public enum StatusValidacaoDocumento {

    PROCESSANDO("Processando validação..."),
    VALIDADO("Validado!"),
    FALHA("Falha na validação"),
    PENDENTE("Pendente de validação");

    private final String descricao;

    StatusValidacaoDocumento(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\enums\TipoOcorrenciaOperador.java ----- 
package br.com.cloudport.servicogate.model.enums;

import java.util.Locale;

public enum TipoOcorrenciaOperador {
    ATRASO_EM_FILAS("Atraso em filas", NivelEvento.ALERTA),
    DOCUMENTACAO_PENDENTE("Documentação pendente", NivelEvento.ALERTA),
    INCIDENTE_SEGURANCA("Incidente de segurança", NivelEvento.CRITICA),
    MANUTENCAO_EQUIPAMENTO("Manutenção de equipamento", NivelEvento.OPERACIONAL),
    OPERACAO_NORMAL("Ocorrência operacional", NivelEvento.INFO);

    private final String descricao;
    private final NivelEvento nivelPadrao;

    TipoOcorrenciaOperador(String descricao, NivelEvento nivelPadrao) {
        this.descricao = descricao;
        this.nivelPadrao = nivelPadrao;
    }

    public String getDescricao() {
        return descricao;
    }

    public NivelEvento getNivelPadrao() {
        return nivelPadrao;
    }

    public static TipoOcorrenciaOperador fromCodigo(String codigo) {
        if (codigo == null) {
            throw new IllegalArgumentException("Tipo de ocorrência não informado");
        }
        String normalizado = codigo.trim().toUpperCase(Locale.ROOT)
                .replace('-', '_')
                .replace(' ', '_');
        return TipoOcorrenciaOperador.valueOf(normalizado);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\model\enums\TipoOperacao.java ----- 
package br.com.cloudport.servicogate.model.enums;

public enum TipoOperacao {
    ENTRADA("Entrada"),
    SAIDA("Saída"),
    DEVOLUCAO("Devolução"),
    TRANSFERENCIA("Transferência");

    private final String descricao;

    TipoOperacao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\monitoring\GateMetrics.java ----- 
package br.com.cloudport.servicogate.monitoring;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import java.time.Duration;
import org.springframework.stereotype.Component;

@Component
public class GateMetrics {

    private final MeterRegistry meterRegistry;

    public GateMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }

    public void registrarTempoValidacao(Duration duracao, boolean sucesso) {
        Timer timer = meterRegistry.timer("gate.validacao.tempo", "resultado", sucesso ? "sucesso" : "falha");
        timer.record(duracao);
    }

    public void registrarConsumoFila(String fila, boolean sucesso) {
        Counter counter = meterRegistry.counter("gate.hardware.mensagens.processadas",
                "fila", fila,
                "resultado", sucesso ? "sucesso" : "falha");
        counter.increment();
    }

    public void registrarEventoDegradacao(String sistema, String origem) {
        Counter counter = meterRegistry.counter("gate.integracoes.degradacao.total",
                "sistema", sistema,
                "origem", origem);
        counter.increment();
    }

    public void registrarContingenciaAcionada(String acao) {
        Counter counter = meterRegistry.counter("gate.contingencia.eventos",
                "acao", acao);
        counter.increment();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\monitoring\IntegracaoDegradacaoHandler.java ----- 
package br.com.cloudport.servicogate.monitoring;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class IntegracaoDegradacaoHandler {

    private static final Logger LOGGER = LoggerFactory.getLogger(IntegracaoDegradacaoHandler.class);

    private final GateMetrics gateMetrics;

    public IntegracaoDegradacaoHandler(GateMetrics gateMetrics) {
        this.gateMetrics = gateMetrics;
    }

    public void registrarDegradacao(String sistema, String origem, String orientacaoOperador) {
        gateMetrics.registrarEventoDegradacao(sistema, origem);
        LOGGER.warn("event=integracao.degradada sistema={} origem={} orientacao=\"{}\"", sistema, origem, orientacaoOperador);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\security\AutenticacaoClient.java ----- 
package br.com.cloudport.servicogate.security;

import br.com.cloudport.servicogate.monitoring.IntegracaoDegradacaoHandler;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import java.net.URI;
import java.util.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

@Component
public class AutenticacaoClient {

    private static final Logger LOGGER = LoggerFactory.getLogger(AutenticacaoClient.class);

    private final RestTemplate restTemplate;
    private final String autenticacaoBaseUrl;
    private final IntegracaoDegradacaoHandler degradacaoHandler;
    private final String fallbackOrientacao;

    public AutenticacaoClient(RestTemplate restTemplate,
                              @Value("${cloudport.security.autenticacao.base-url}") String autenticacaoBaseUrl,
                              IntegracaoDegradacaoHandler degradacaoHandler,
                              @Value("${cloudport.security.autenticacao.fallback-orientacao:Validar credenciais manualmente com a equipe de segurança e registrar acessos temporários.}")
                                      String fallbackOrientacao) {
        this.restTemplate = restTemplate;
        this.autenticacaoBaseUrl = autenticacaoBaseUrl;
        this.degradacaoHandler = degradacaoHandler;
        this.fallbackOrientacao = fallbackOrientacao;
    }

    @CircuitBreaker(name = "autenticacao", fallbackMethod = "fallbackBuscarUsuario")
    public Optional<UserInfoResponse> buscarUsuario(String login, String authorizationHeader) {
        if (!StringUtils.hasText(autenticacaoBaseUrl) || !StringUtils.hasText(login)) {
            return Optional.empty();
        }
        try {
            HttpHeaders headers = new HttpHeaders();
            if (StringUtils.hasText(authorizationHeader)) {
                headers.set(HttpHeaders.AUTHORIZATION, authorizationHeader);
            }
            HttpEntity<Void> entity = new HttpEntity<>(headers);
            URI uri = URI.create(String.format("%s/auth/usuarios/%s", autenticacaoBaseUrl, login));
            ResponseEntity<UserInfoResponse> response = restTemplate.exchange(uri, HttpMethod.GET, entity, UserInfoResponse.class);
            return Optional.ofNullable(response.getBody());
        } catch (RestClientException ex) {
            LOGGER.debug("Falha ao buscar usuário {} no serviço de autenticação", login, ex);
            return Optional.empty();
        }
    }

    @SuppressWarnings("unused")
    private Optional<UserInfoResponse> fallbackBuscarUsuario(String login, String authorizationHeader, Throwable throwable) {
        degradacaoHandler.registrarDegradacao("autenticacao", "circuit-breaker", fallbackOrientacao);
        LOGGER.warn("event=autenticacao.fallback login={} orientacao=\"{}\" causa={}",
                login, fallbackOrientacao, throwable != null ? throwable.getMessage() : "desconhecida");
        return Optional.empty();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\security\TransportadoraSynchronizationFilter.java ----- 
package br.com.cloudport.servicogate.security;

import java.io.IOException;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.http.HttpHeaders;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

@Component
public class TransportadoraSynchronizationFilter extends OncePerRequestFilter {

    private final TransportadoraSyncService transportadoraSyncService;
    private final AutenticacaoClient autenticacaoClient;

    public TransportadoraSynchronizationFilter(TransportadoraSyncService transportadoraSyncService,
                                               AutenticacaoClient autenticacaoClient) {
        this.transportadoraSyncService = transportadoraSyncService;
        this.autenticacaoClient = autenticacaoClient;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication instanceof JwtAuthenticationToken) {
            JwtAuthenticationToken jwtAuthentication = (JwtAuthenticationToken) authentication;
            Jwt token = jwtAuthentication.getToken();
            String documento = token.getClaimAsString("transportadoraDocumento");
            if (!StringUtils.hasText(documento)) {
                documento = token.getClaimAsString("transportadoraCnpj");
            }
            String nome = token.getClaimAsString("transportadoraNome");

            if (!StringUtils.hasText(documento) || !StringUtils.hasText(nome)) {
                var info = autenticacaoClient.buscarUsuario(token.getSubject(), request.getHeader(HttpHeaders.AUTHORIZATION));
                if (!StringUtils.hasText(documento)) {
                    documento = info.map(UserInfoResponse::getTransportadoraDocumento).orElse(null);
                }
                if (!StringUtils.hasText(nome)) {
                    nome = info.map(UserInfoResponse::getTransportadoraNome).orElse(null);
                }
            }

            if (StringUtils.hasText(documento)) {
                transportadoraSyncService.sincronizarTransportadora(documento, nome);
            }
        }
        filterChain.doFilter(request, response);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\security\TransportadoraSyncService.java ----- 
package br.com.cloudport.servicogate.security;

import br.com.cloudport.servicogate.model.Transportadora;
import br.com.cloudport.servicogate.app.configuracoes.TransportadoraRepository;
import java.util.Locale;
import java.util.Optional;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

@Service
public class TransportadoraSyncService {

    private final TransportadoraRepository transportadoraRepository;

    public TransportadoraSyncService(TransportadoraRepository transportadoraRepository) {
        this.transportadoraRepository = transportadoraRepository;
    }

    @Transactional
    public void sincronizarTransportadora(String documento, String nome) {
        if (!StringUtils.hasText(documento)) {
            return;
        }

        String normalizedDocumento = documento.replaceAll("[^0-9A-Za-z]", "").toUpperCase(Locale.ROOT);
        Optional<Transportadora> existente = transportadoraRepository.findByDocumento(normalizedDocumento);
        if (existente.isPresent()) {
            Transportadora transportadora = existente.get();
            if (StringUtils.hasText(nome) && !nome.equals(transportadora.getNome())) {
                transportadora.setNome(nome);
                transportadoraRepository.save(transportadora);
            }
            return;
        }

        Transportadora nova = new Transportadora();
        nova.setDocumento(normalizedDocumento);
        nova.setNome(StringUtils.hasText(nome) ? nome : normalizedDocumento);
        transportadoraRepository.save(nova);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\security\UserInfoResponse.java ----- 
package br.com.cloudport.servicogate.security;

import java.util.Set;

public class UserInfoResponse {

    private String id;
    private String login;
    private String nome;
    private String perfil;
    private Set<String> roles;
    private String transportadoraDocumento;
    private String transportadoraNome;

    public UserInfoResponse() {
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getLogin() {
        return login;
    }

    public void setLogin(String login) {
        this.login = login;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getPerfil() {
        return perfil;
    }

    public void setPerfil(String perfil) {
        this.perfil = perfil;
    }

    public Set<String> getRoles() {
        return roles;
    }

    public void setRoles(Set<String> roles) {
        this.roles = roles;
    }

    public String getTransportadoraDocumento() {
        return transportadoraDocumento;
    }

    public void setTransportadoraDocumento(String transportadoraDocumento) {
        this.transportadoraDocumento = transportadoraDocumento;
    }

    public String getTransportadoraNome() {
        return transportadoraNome;
    }

    public void setTransportadoraNome(String transportadoraNome) {
        this.transportadoraNome = transportadoraNome;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\storage\DocumentoStorageService.java ----- 
package br.com.cloudport.servicogate.storage;

import org.springframework.core.io.Resource;
import org.springframework.web.multipart.MultipartFile;

public interface DocumentoStorageService {

    StoredDocumento armazenar(Long agendamentoId, MultipartFile arquivo);

    Resource carregarComoResource(String storageKey);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\storage\LocalDocumentoStorageService.java ----- 
package br.com.cloudport.servicogate.storage;

import br.com.cloudport.servicogate.config.DocumentoStorageProperties;
import br.com.cloudport.servicogate.exception.BusinessException;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Locale;
import java.util.UUID;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

@Service
public class LocalDocumentoStorageService implements DocumentoStorageService {

    private final DocumentoStorageProperties properties;

    public LocalDocumentoStorageService(DocumentoStorageProperties properties) {
        this.properties = properties;
        if (!"local".equalsIgnoreCase(properties.getProvider())) {
            throw new BusinessException("Provedor de armazenamento não suportado: " + properties.getProvider());
        }
    }

    @Override
    public StoredDocumento armazenar(Long agendamentoId, MultipartFile arquivo) {
        try {
            Path baseDirectory = Paths.get(properties.getBasePath()).toAbsolutePath().normalize();
            Files.createDirectories(baseDirectory);
            Path agendamentoDirectory = baseDirectory.resolve(String.valueOf(agendamentoId));
            Files.createDirectories(agendamentoDirectory);

            String originalFilename = arquivo.getOriginalFilename();
            String sanitizedExtension = extrairExtensao(originalFilename);
            String generatedName = UUID.randomUUID() + (sanitizedExtension.isEmpty() ? "" : "." + sanitizedExtension);
            Path destino = agendamentoDirectory.resolve(generatedName);

            try {
                Files.copy(arquivo.getInputStream(), destino, StandardCopyOption.REPLACE_EXISTING);
            } catch (IOException ioException) {
                throw new UncheckedIOException(ioException);
            }

            String storageKey = agendamentoId + "/" + generatedName;
            String nomeOriginal = StringUtils.hasText(originalFilename) ? originalFilename : generatedName;
            return new StoredDocumento(storageKey, nomeOriginal, arquivo.getContentType(), arquivo.getSize());
        } catch (IOException e) {
            throw new BusinessException("Erro ao armazenar documento de agendamento", e);
        }
    }

    @Override
    public Resource carregarComoResource(String storageKey) {
        Path baseDirectory = Paths.get(properties.getBasePath()).toAbsolutePath().normalize();
        Path arquivo = baseDirectory.resolve(storageKey).normalize();
        if (!arquivo.startsWith(baseDirectory)) {
            throw new BusinessException("Caminho de documento inválido");
        }
        return new FileSystemResource(arquivo);
    }

    private String extrairExtensao(String originalFilename) {
        if (!StringUtils.hasText(originalFilename)) {
            return "";
        }
        String sanitized = originalFilename.toLowerCase(Locale.ROOT).replaceAll("[^a-z0-9.]+", "-");
        int lastDot = sanitized.lastIndexOf('.');
        if (lastDot < 0) {
            return "";
        }
        return sanitized.substring(lastDot + 1);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\java\br\com\cloudport\servicogate\storage\StoredDocumento.java ----- 
package br.com.cloudport.servicogate.storage;

public class StoredDocumento {

    private final String storageKey;
    private final String nomeOriginal;
    private final String contentType;
    private final long tamanho;

    public StoredDocumento(String storageKey, String nomeOriginal, String contentType, long tamanho) {
        this.storageKey = storageKey;
        this.nomeOriginal = nomeOriginal;
        this.contentType = contentType;
        this.tamanho = tamanho;
    }

    public String getStorageKey() {
        return storageKey;
    }

    public String getNomeOriginal() {
        return nomeOriginal;
    }

    public String getContentType() {
        return contentType;
    }

    public long getTamanho() {
        return tamanho;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\resources\application.properties ----- 
server.port=${GATE_SERVER_PORT:8082}

spring.application.name=servico-gate

spring.datasource.url=${GATE_DB_URL:jdbc:postgresql://localhost:5432/servico_gate}
spring.datasource.username=${GATE_DB_USERNAME:postgres}
spring.datasource.password=${GATE_DB_PASSWORD:postgres}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=none
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.default-schema=${GATE_FLYWAY_SCHEMA:cloudport}
spring.flyway.schemas=${GATE_FLYWAY_SCHEMA:cloudport}

spring.rabbitmq.host=${GATE_RABBIT_HOST:localhost}
spring.rabbitmq.port=${GATE_RABBIT_PORT:5672}
spring.rabbitmq.username=${GATE_RABBIT_USERNAME:guest}
spring.rabbitmq.password=${GATE_RABBIT_PASSWORD:guest}

cloudport.security.jwt.secret=${GATE_SECURITY_JWT_SECRET:change-me}
cloudport.security.cors.allowed-origins=${GATE_SECURITY_CORS_ALLOWED_ORIGINS:http://localhost:3000}
cloudport.security.autenticacao.base-url=${GATE_SECURITY_AUTENTICACAO_BASE_URL:http://localhost:8081}
cloudport.integracoes.yard.base-url=${GATE_INTEGRACAO_YARD_BASE_URL:http://localhost:8081}
cloudport.integracoes.yard.status-path=${GATE_INTEGRACAO_YARD_STATUS_PATH:/yard/status}
cloudport.integracoes.yard.fallback-orientacao=${GATE_INTEGRACAO_YARD_FALLBACK:Consultar equipe de pátio para orientações manuais.}

management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.probes.enabled=true
management.endpoint.health.group.liveness.include=livenessState
management.endpoint.health.group.readiness.include=readinessState,db,rabbit,tos
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always
management.endpoint.prometheus.enabled=true
management.metrics.export.prometheus.enabled=true
management.metrics.tags.application=${spring.application.name}
management.metrics.distribution.percentiles-histogram.gate.validacao.tempo=true
otel.exporter.otlp.endpoint=${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4317}
otel.metrics.exporter=otlp
otel.traces.exporter=otlp
otel.logs.exporter=none
otel.resource.attributes=service.name=${spring.application.name}
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html

# Configurações de integração com o TOS
cloudport.tos.api.base-url=${TOS_API_BASE_URL:http://localhost:8080}
cloudport.tos.api.timeout=${TOS_API_TIMEOUT_MS:5000}
cloudport.tos.api.booking-path=${TOS_API_BOOKING_PATH:/tos/bookings/{bookingNumber}}
cloudport.tos.api.container-status-path=${TOS_API_CONTAINER_STATUS_PATH:/tos/containers/{containerNumber}/status}
cloudport.tos.api.customs-release-path=${TOS_API_CUSTOMS_RELEASE_PATH:/tos/containers/{containerNumber}/customs}
cloudport.tos.api.username=${TOS_API_USERNAME:}
cloudport.tos.api.password=${TOS_API_PASSWORD:}
cloudport.tos.retry.max-attempts=${TOS_API_RETRY_ATTEMPTS:3}
cloudport.tos.retry.initial-interval=${TOS_API_RETRY_INTERVAL_MS:500}
cloudport.tos.retry.multiplier=${TOS_API_RETRY_MULTIPLIER:2.0}
cloudport.tos.cache.max-size=${TOS_API_CACHE_MAX_SIZE:500}
cloudport.tos.cache.ttl=${TOS_API_CACHE_TTL:PT5M}

# Fluxo de gate e integrações de hardware
cloudport.gate.flow.tolerancia-entrada-antecipada=${GATE_TOL_ENTRADA_ANTEC:PT30M}
cloudport.gate.flow.tolerancia-entrada-atraso=${GATE_TOL_ENTRADA_ATRASO:PT30M}
cloudport.gate.flow.tolerancia-saida-antecipada=${GATE_TOL_SAIDA_ANTEC:PT30M}
cloudport.gate.flow.tolerancia-saida-atraso=${GATE_TOL_SAIDA_ATRASO:PT30M}
cloudport.gate.flow.roles-liberacao-manual=${GATE_ROLES_LIBERACAO_MANUAL:ROLE_OPERADOR_GATE}

cloudport.gate.hardware.entrada-queue=${GATE_HARDWARE_ENTRADA_QUEUE:gate.hardware.entrada}
cloudport.gate.hardware.saida-queue=${GATE_HARDWARE_SAIDA_QUEUE:gate.hardware.saida}
cloudport.gate.hardware.decisao-exchange=${GATE_HARDWARE_DECISAO_EXCHANGE:gate.hardware.decisao}
cloudport.gate.hardware.decisao-routing-entrada=${GATE_HARDWARE_DECISAO_ROUTING_ENTRADA:gate.hardware.decisao.entrada}
cloudport.gate.hardware.decisao-routing-saida=${GATE_HARDWARE_DECISAO_ROUTING_SAIDA:gate.hardware.decisao.saida}
cloudport.gate.ocr.solicitacao-queue=${GATE_OCR_SOLICITACAO_QUEUE:gate.ocr.solicitacoes}
cloudport.gate.ocr.tempo-maximo-processamento=${GATE_OCR_TIMEOUT:PT5S}

# Contingência
cloudport.gate.contingencia.enabled=${GATE_CONTINGENCIA_ENABLED:false}
cloudport.gate.contingencia.orientacao-operador=${GATE_CONTINGENCIA_ORIENTACAO:Acione o playbook de contingência do gate e mantenha registros manuais até a normalização do TOS.}

# Fallback de autenticação
cloudport.security.autenticacao.fallback-orientacao=${GATE_AUTENTICACAO_FALLBACK:Validar credenciais manualmente com a equipe de segurança e registrar acessos temporários.}

# Configurações de armazenamento de documentos
cloudport.document-storage.provider=${DOCUMENT_STORAGE_PROVIDER:local}
cloudport.document-storage.base-path=${DOCUMENT_STORAGE_BASE_PATH:/var/lib/cloudport/documents}
cloudport.document-storage.bucket=${DOCUMENT_STORAGE_BUCKET:cloudport-documents}

cloudport.gate.agendamento.rules.antecedencia-minima=${AGENDAMENTO_ANTECEDENCIA_MINIMA:PT2H}
cloudport.gate.agendamento.rules.atraso-maximo=${AGENDAMENTO_ATRASO_MAXIMO:PT1H}
cloudport.gate.agendamento.rules.edicao-antecedencia=${AGENDAMENTO_EDICAO_ANTECEDENCIA:PT12H}
cloudport.gate.agendamento.rules.edicao-atraso=${AGENDAMENTO_EDICAO_ATRASO:PT2H}

# Resilience4j
resilience4j.circuitbreaker.instances.tosApi.register-health-indicator=true
resilience4j.circuitbreaker.instances.tosApi.sliding-window-size=${RESILIENCE4J_TOS_WINDOW_SIZE:10}
resilience4j.circuitbreaker.instances.tosApi.failure-rate-threshold=${RESILIENCE4J_TOS_FAILURE_THRESHOLD:50}
resilience4j.circuitbreaker.instances.tosApi.wait-duration-in-open-state=${RESILIENCE4J_TOS_WAIT_DURATION:PT30S}
resilience4j.circuitbreaker.instances.tosApi.permitted-number-of-calls-in-half-open-state=${RESILIENCE4J_TOS_PERMITTED_HALF_OPEN:3}
resilience4j.circuitbreaker.instances.autenticacao.register-health-indicator=true
resilience4j.circuitbreaker.instances.autenticacao.sliding-window-size=${RESILIENCE4J_AUTENTICACAO_WINDOW_SIZE:6}
resilience4j.circuitbreaker.instances.autenticacao.failure-rate-threshold=${RESILIENCE4J_AUTENTICACAO_FAILURE_THRESHOLD:50}
resilience4j.circuitbreaker.instances.autenticacao.wait-duration-in-open-state=${RESILIENCE4J_AUTENTICACAO_WAIT_DURATION:PT15S}
resilience4j.circuitbreaker.instances.yardStatus.register-health-indicator=true
resilience4j.circuitbreaker.instances.yardStatus.sliding-window-size=${RESILIENCE4J_YARD_WINDOW_SIZE:6}
resilience4j.circuitbreaker.instances.yardStatus.failure-rate-threshold=${RESILIENCE4J_YARD_FAILURE_THRESHOLD:50}
resilience4j.circuitbreaker.instances.yardStatus.wait-duration-in-open-state=${RESILIENCE4J_YARD_WAIT_DURATION:PT15S}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\resources\logback-spring.xml ----- 
<configuration scan="true">
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
            <providers>
                <timestamp>
                    <timeZone>UTC</timeZone>
                </timestamp>
                <pattern>
                    <pattern>
                        {
                            "level":"%level",
                            "logger":"%logger",
                            "thread":"%thread",
                            "message":"%message"
                        }
                    </pattern>
                </pattern>
                <mdc/>
                <logstashMarkers/>
                <arguments/>
                <provider class="net.logstash.logback.composite.GlobalCustomFieldsJsonProvider">
                    <customFields>{"service":"${spring.application.name:-servico-gate}"}</customFields>
                </provider>
                <stackTrace/>
            </providers>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\resources\db\migration\V1__create_gate_tables.sql ----- 
CREATE TABLE transportadora (
    id BIGSERIAL PRIMARY KEY,
    nome VARCHAR(120) NOT NULL,
    documento VARCHAR(20) NOT NULL UNIQUE,
    contato VARCHAR(120),
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_transportadora_nome ON transportadora (nome);

CREATE TABLE motorista (
    id BIGSERIAL PRIMARY KEY,
    nome VARCHAR(120) NOT NULL,
    documento VARCHAR(20) NOT NULL,
    telefone VARCHAR(20),
    transportadora_id BIGINT NOT NULL REFERENCES transportadora (id),
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT uk_motorista_documento UNIQUE (documento, transportadora_id)
);

CREATE INDEX idx_motorista_transportadora ON motorista (transportadora_id);

CREATE TABLE veiculo (
    id BIGSERIAL PRIMARY KEY,
    placa VARCHAR(10) NOT NULL UNIQUE,
    modelo VARCHAR(60),
    tipo VARCHAR(40),
    transportadora_id BIGINT NOT NULL REFERENCES transportadora (id),
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_veiculo_transportadora ON veiculo (transportadora_id);

CREATE TABLE janela_atendimento (
    id BIGSERIAL PRIMARY KEY,
    data DATE NOT NULL,
    hora_inicio TIME WITHOUT TIME ZONE NOT NULL,
    hora_fim TIME WITHOUT TIME ZONE NOT NULL,
    capacidade INTEGER NOT NULL,
    canal_entrada VARCHAR(40) NOT NULL,
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX uk_janela_atendimento_slot ON janela_atendimento (data, hora_inicio, canal_entrada);

CREATE TABLE agendamento (
    id BIGSERIAL PRIMARY KEY,
    codigo VARCHAR(40) NOT NULL UNIQUE,
    tipo_operacao VARCHAR(40) NOT NULL,
    status VARCHAR(40) NOT NULL,
    transportadora_id BIGINT NOT NULL REFERENCES transportadora (id),
    motorista_id BIGINT NOT NULL REFERENCES motorista (id),
    veiculo_id BIGINT NOT NULL REFERENCES veiculo (id),
    janela_atendimento_id BIGINT NOT NULL REFERENCES janela_atendimento (id),
    horario_previsto_chegada TIMESTAMP WITHOUT TIME ZONE,
    horario_previsto_saida TIMESTAMP WITHOUT TIME ZONE,
    horario_real_chegada TIMESTAMP WITHOUT TIME ZONE,
    horario_real_saida TIMESTAMP WITHOUT TIME ZONE,
    observacoes VARCHAR(500),
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_agendamento_status ON agendamento (status);
CREATE INDEX idx_agendamento_janela ON agendamento (janela_atendimento_id);
CREATE INDEX idx_agendamento_transportadora ON agendamento (transportadora_id);

CREATE TABLE documento_agendamento (
    id BIGSERIAL PRIMARY KEY,
    tipo_documento VARCHAR(80) NOT NULL,
    numero VARCHAR(80),
    url_documento VARCHAR(255),
    agendamento_id BIGINT NOT NULL REFERENCES agendamento (id) ON DELETE CASCADE,
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_documento_agendamento_agendamento ON documento_agendamento (agendamento_id);

CREATE TABLE gate_pass (
    id BIGSERIAL PRIMARY KEY,
    codigo VARCHAR(40) NOT NULL UNIQUE,
    status VARCHAR(40) NOT NULL,
    data_entrada TIMESTAMP WITHOUT TIME ZONE,
    data_saida TIMESTAMP WITHOUT TIME ZONE,
    agendamento_id BIGINT NOT NULL UNIQUE REFERENCES agendamento (id),
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_gate_pass_status ON gate_pass (status);

CREATE TABLE gate_event (
    id BIGSERIAL PRIMARY KEY,
    status VARCHAR(40) NOT NULL,
    motivo_excecao VARCHAR(40),
    observacao VARCHAR(500),
    usuario_responsavel VARCHAR(80),
    registrado_em TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    gate_pass_id BIGINT NOT NULL REFERENCES gate_pass (id) ON DELETE CASCADE,
    created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_gate_event_gate_pass ON gate_event (gate_pass_id);
CREATE INDEX idx_gate_event_status ON gate_event (status);
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\main\resources\db\migration\V2__adicionar_status_validacao_documento.sql ----- 
ALTER TABLE documento_agendamento ADD COLUMN status_validacao VARCHAR(30);
ALTER TABLE documento_agendamento ADD COLUMN mensagem_validacao VARCHAR(500);

UPDATE documento_agendamento
SET status_validacao = CASE
        WHEN ultima_revalidacao IS NOT NULL THEN 'VALIDADO'
        ELSE 'PENDENTE'
    END,
    mensagem_validacao = CASE
        WHEN ultima_revalidacao IS NOT NULL THEN 'Documento validado manualmente antes da automação.'
        ELSE 'Documento aguardando validação automática.'
    END;

ALTER TABLE documento_agendamento ALTER COLUMN status_validacao SET NOT NULL;
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\app\cidadao\AgendamentoControllerSecurityTest.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import br.com.cloudport.servicogate.config.SecurityConfig;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoRequest;
import br.com.cloudport.servicogate.security.TransportadoraSynchronizationFilter;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoService;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.time.LocalDateTime;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Import;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.http.MediaType;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(controllers = AgendamentoController.class)
@Import(SecurityConfig.class)
@TestPropertySource(properties = {
        "cloudport.security.jwt.secret=test-secret",
        "cloudport.security.cors.allowed-origins=http://localhost:4200"
})
class AgendamentoControllerSecurityTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private AgendamentoService agendamentoService;

    @MockBean
    private TransportadoraSynchronizationFilter transportadoraSynchronizationFilter;

    @Test
    void criarAgendamento_requerAutenticacao() throws Exception {
        mockMvc.perform(post("/gate/agendamentos")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(buildRequest())))
                .andExpect(status().isUnauthorized());
    }

    @Test
    void criarAgendamento_autorizadoParaAdmin() throws Exception {
        when(agendamentoService.criar(any())).thenReturn(new AgendamentoDTO());

        mockMvc.perform(post("/gate/agendamentos")
                        .with(jwt().authorities(new SimpleGrantedAuthority("ROLE_ADMIN_PORTO")))
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(buildRequest())))
                .andExpect(status().isCreated());
    }

    @Test
    void criarAgendamento_negadoParaTransportadora() throws Exception {
        mockMvc.perform(post("/gate/agendamentos")
                        .with(jwt().authorities(new SimpleGrantedAuthority("ROLE_TRANSPORTADORA")))
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(buildRequest())))
                .andExpect(status().isForbidden());
    }

    @Test
    void listarAgendamentos_permitidoParaTransportadora() throws Exception {
        when(agendamentoService.buscar(any(), any(), any(Pageable.class)))
                .thenReturn(new PageImpl<>(java.util.List.of()));

        mockMvc.perform(get("/gate/agendamentos")
                        .with(jwt().authorities(new SimpleGrantedAuthority("ROLE_TRANSPORTADORA"))))
                .andExpect(status().isOk());
    }

    private AgendamentoRequest buildRequest() {
        AgendamentoRequest request = new AgendamentoRequest();
        request.setCodigo("AG-001");
        request.setTipoOperacao("IMPORTACAO");
        request.setStatus("CONFIRMADO");
        request.setTransportadoraId(1L);
        request.setMotoristaId(1L);
        request.setVeiculoId(1L);
        request.setJanelaAtendimentoId(1L);
        request.setHorarioPrevistoChegada(LocalDateTime.now().plusHours(2));
        request.setHorarioPrevistoSaida(LocalDateTime.now().plusHours(4));
        request.setObservacoes("Teste");
        return request;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\app\cidadao\AgendamentoRepositoryTest.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;

import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.JanelaAtendimento;
import br.com.cloudport.servicogate.model.Motorista;
import br.com.cloudport.servicogate.model.Transportadora;
import br.com.cloudport.servicogate.model.Veiculo;
import br.com.cloudport.servicogate.model.enums.CanalEntrada;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.model.enums.TipoOperacao;
import br.com.cloudport.servicogate.app.transparencia.DashboardMetricsProjection;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
import org.springframework.test.context.TestPropertySource;

@DataJpaTest
@TestPropertySource(properties = {
        "spring.jpa.hibernate.ddl-auto=create-drop",
        "spring.flyway.enabled=false"
})
class AgendamentoRepositoryTest {

    @Autowired
    private AgendamentoRepository agendamentoRepository;

    @Autowired
    private TestEntityManager entityManager;

    private Transportadora transportadoraA;
    private Transportadora transportadoraB;

    @BeforeEach
    void setUp() {
        transportadoraA = criarTransportadora("TransA", "001");
        transportadoraB = criarTransportadora("TransB", "002");

        Motorista motoristaA = criarMotorista("João", "123", transportadoraA);
        Motorista motoristaB = criarMotorista("Maria", "456", transportadoraB);

        Veiculo veiculoA = criarVeiculo("AAA1234", transportadoraA);
        Veiculo veiculoB = criarVeiculo("BBB5678", transportadoraB);

        JanelaAtendimento janela1 = criarJanela(LocalDate.of(2024, 1, 10), LocalTime.of(8, 0), LocalTime.of(9, 0), 2);
        JanelaAtendimento janela2 = criarJanela(LocalDate.of(2024, 1, 10), LocalTime.of(10, 0), LocalTime.of(11, 0), 1);
        JanelaAtendimento janela3 = criarJanela(LocalDate.of(2024, 1, 10), LocalTime.of(12, 0), LocalTime.of(13, 0), 1);
        JanelaAtendimento janela4 = criarJanela(LocalDate.of(2024, 1, 10), LocalTime.of(14, 0), LocalTime.of(15, 0), 1);
        JanelaAtendimento janela5 = criarJanela(LocalDate.of(2024, 1, 11), LocalTime.of(9, 0), LocalTime.of(10, 0), 1);

        criarAgendamento("AG001", transportadoraA, motoristaA, veiculoA, janela1,
                TipoOperacao.ENTRADA, StatusAgendamento.COMPLETO,
                LocalDateTime.of(2024, 1, 10, 8, 0), LocalDateTime.of(2024, 1, 10, 9, 0),
                LocalDateTime.of(2024, 1, 10, 8, 5), LocalDateTime.of(2024, 1, 10, 8, 55));

        criarAgendamento("AG002", transportadoraA, motoristaA, veiculoA, janela2,
                TipoOperacao.ENTRADA, StatusAgendamento.COMPLETO,
                LocalDateTime.of(2024, 1, 10, 10, 0), LocalDateTime.of(2024, 1, 10, 11, 30),
                LocalDateTime.of(2024, 1, 10, 10, 30), LocalDateTime.of(2024, 1, 10, 11, 45));

        criarAgendamento("AG003", transportadoraA, motoristaA, veiculoA, janela3,
                TipoOperacao.ENTRADA, StatusAgendamento.NO_SHOW,
                LocalDateTime.of(2024, 1, 10, 12, 0), LocalDateTime.of(2024, 1, 10, 13, 0),
                null, null);

        criarAgendamento("AG004", transportadoraA, motoristaA, veiculoA, janela4,
                TipoOperacao.ENTRADA, StatusAgendamento.CANCELADO,
                LocalDateTime.of(2024, 1, 10, 14, 0), LocalDateTime.of(2024, 1, 10, 15, 0),
                null, null);

        criarAgendamento("AG005", transportadoraB, motoristaB, veiculoB, janela5,
                TipoOperacao.SAIDA, StatusAgendamento.COMPLETO,
                LocalDateTime.of(2024, 1, 11, 9, 0), LocalDateTime.of(2024, 1, 11, 10, 0),
                LocalDateTime.of(2024, 1, 11, 9, 5), LocalDateTime.of(2024, 1, 11, 9, 50));

        entityManager.flush();
        entityManager.clear();
    }

    @Test
    void deveCalcularMetricasDashboard() {
        LocalDateTime inicio = LocalDateTime.of(2024, 1, 10, 0, 0);
        LocalDateTime fim = LocalDateTime.of(2024, 1, 10, 23, 59);

        DashboardMetricsProjection projection = agendamentoRepository.calcularMetricasDashboard(
                inicio,
                fim,
                transportadoraA.getId(),
                TipoOperacao.ENTRADA.name(),
                15
        );

        assertThat(projection.getTotalAgendamentos()).isEqualTo(3);
        assertThat(projection.getPontuais()).isEqualTo(1);
        assertThat(projection.getNoShow()).isEqualTo(1);
        assertThat(projection.getTurnaroundMedio()).isCloseTo(62.5, within(0.1));
        assertThat(projection.getOcupacaoSlots()).isCloseTo(0.75, within(0.0001));
    }

    @Test
    void deveBuscarAgendamentosParaRelatorioComFiltros() {
        LocalDateTime inicio = LocalDateTime.of(2024, 1, 10, 0, 0);
        LocalDateTime fim = LocalDateTime.of(2024, 1, 10, 23, 59);

        List<Agendamento> resultados = agendamentoRepository.buscarRelatorio(
                inicio,
                fim,
                transportadoraA.getId(),
                TipoOperacao.ENTRADA
        );

        assertThat(resultados)
                .extracting(Agendamento::getCodigo)
                .containsExactly("AG001", "AG002", "AG003");
        assertThat(resultados)
                .allMatch(agendamento -> agendamento.getTransportadora().getId().equals(transportadoraA.getId()));
        assertThat(resultados)
                .allMatch(agendamento -> agendamento.getTipoOperacao() == TipoOperacao.ENTRADA);
    }

    private Transportadora criarTransportadora(String nome, String documento) {
        Transportadora transportadora = new Transportadora();
        transportadora.setNome(nome);
        transportadora.setDocumento(documento);
        return entityManager.persist(transportadora);
    }

    private Motorista criarMotorista(String nome, String documento, Transportadora transportadora) {
        Motorista motorista = new Motorista();
        motorista.setNome(nome);
        motorista.setDocumento(documento);
        motorista.setTransportadora(transportadora);
        return entityManager.persist(motorista);
    }

    private Veiculo criarVeiculo(String placa, Transportadora transportadora) {
        Veiculo veiculo = new Veiculo();
        veiculo.setPlaca(placa);
        veiculo.setTransportadora(transportadora);
        return entityManager.persist(veiculo);
    }

    private JanelaAtendimento criarJanela(LocalDate data, LocalTime inicio, LocalTime fim, int capacidade) {
        JanelaAtendimento janela = new JanelaAtendimento();
        janela.setData(data);
        janela.setHoraInicio(inicio);
        janela.setHoraFim(fim);
        janela.setCapacidade(capacidade);
        janela.setCanalEntrada(CanalEntrada.PORTARIA_PRINCIPAL);
        return entityManager.persist(janela);
    }

    private Agendamento criarAgendamento(String codigo,
                                         Transportadora transportadora,
                                         Motorista motorista,
                                         Veiculo veiculo,
                                         JanelaAtendimento janela,
                                         TipoOperacao tipoOperacao,
                                         StatusAgendamento status,
                                         LocalDateTime previstoChegada,
                                         LocalDateTime previstoSaida,
                                         LocalDateTime realChegada,
                                         LocalDateTime realSaida) {
        Agendamento agendamento = new Agendamento();
        agendamento.setCodigo(codigo);
        agendamento.setTransportadora(transportadora);
        agendamento.setMotorista(motorista);
        agendamento.setVeiculo(veiculo);
        agendamento.setJanelaAtendimento(janela);
        agendamento.setTipoOperacao(tipoOperacao);
        agendamento.setStatus(status);
        agendamento.setHorarioPrevistoChegada(previstoChegada);
        agendamento.setHorarioPrevistoSaida(previstoSaida);
        agendamento.setHorarioRealChegada(realChegada);
        agendamento.setHorarioRealSaida(realSaida);
        return entityManager.persist(agendamento);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\app\cidadao\AgendamentoServiceTest.java ----- 
package br.com.cloudport.servicogate.app.cidadao;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import br.com.cloudport.servicogate.config.AgendamentoRulesProperties;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoDTO;
import br.com.cloudport.servicogate.app.cidadao.dto.AgendamentoRequest;
import br.com.cloudport.servicogate.exception.BusinessException;
import br.com.cloudport.servicogate.integration.tos.TosIntegrationService;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.JanelaAtendimento;
import br.com.cloudport.servicogate.model.Motorista;
import br.com.cloudport.servicogate.model.Transportadora;
import br.com.cloudport.servicogate.model.Veiculo;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRepository;
import br.com.cloudport.servicogate.app.cidadao.DocumentoAgendamentoRepository;
import br.com.cloudport.servicogate.app.cidadao.JanelaAtendimentoRepository;
import br.com.cloudport.servicogate.app.cidadao.MotoristaRepository;
import br.com.cloudport.servicogate.app.configuracoes.TransportadoraRepository;
import br.com.cloudport.servicogate.app.cidadao.VeiculoRepository;
import br.com.cloudport.servicogate.storage.DocumentoStorageService;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AgendamentoServiceTest {

    @Mock
    private AgendamentoRepository agendamentoRepository;
    @Mock
    private JanelaAtendimentoRepository janelaAtendimentoRepository;
    @Mock
    private TransportadoraRepository transportadoraRepository;
    @Mock
    private MotoristaRepository motoristaRepository;
    @Mock
    private VeiculoRepository veiculoRepository;
    @Mock
    private DocumentoAgendamentoRepository documentoAgendamentoRepository;
    @Mock
    private DocumentoStorageService documentoStorageService;
    @Mock
    private TosIntegrationService tosIntegrationService;
    @Mock
    private DashboardService dashboardService;
    @Mock
    private AgendamentoRealtimeService agendamentoRealtimeService;

    private AgendamentoRulesProperties rulesProperties;
    private AgendamentoService agendamentoService;

    @BeforeEach
    void setUp() {
        rulesProperties = new AgendamentoRulesProperties();
        agendamentoService = new AgendamentoService(
                agendamentoRepository,
                janelaAtendimentoRepository,
                transportadoraRepository,
                motoristaRepository,
                veiculoRepository,
                documentoAgendamentoRepository,
                documentoStorageService,
                rulesProperties,
                tosIntegrationService,
                dashboardService,
                agendamentoRealtimeService
        );
    }

    @Test
    @DisplayName("Deve impedir criação quando capacidade da janela é excedida")
    void deveImpedirCriacaoQuandoCapacidadeAtingida() {
        JanelaAtendimento janela = criarJanelaComCapacidade(1);
        when(janelaAtendimentoRepository.findById(1L)).thenReturn(Optional.of(janela));
        when(agendamentoRepository.countByJanelaAtendimentoIdAndStatusNot(janela.getId(), StatusAgendamento.CANCELADO))
                .thenReturn(1L);

        AgendamentoRequest request = criarRequestBasico();

        assertThatThrownBy(() -> agendamentoService.criar(request))
                .isInstanceOf(BusinessException.class)
                .hasMessageContaining("Capacidade da janela atingida");

        verify(agendamentoRepository, never()).save(any());
        verify(tosIntegrationService, never()).validarAgendamentoParaCriacao(any(), any());
    }

    @Test
    @DisplayName("Deve criar agendamento respeitando regras de agendamento e notificações")
    void deveCriarAgendamento() {
        JanelaAtendimento janela = criarJanelaComCapacidade(5);
        when(janelaAtendimentoRepository.findById(1L)).thenReturn(Optional.of(janela));
        when(transportadoraRepository.findById(2L)).thenReturn(Optional.of(new Transportadora()));
        when(motoristaRepository.findById(3L)).thenReturn(Optional.of(new Motorista()));
        when(veiculoRepository.findById(4L)).thenReturn(Optional.of(new Veiculo()));
        when(agendamentoRepository.countByJanelaAtendimentoIdAndStatusNot(janela.getId(), StatusAgendamento.CANCELADO))
                .thenReturn(0L);
        when(agendamentoRepository.save(any())).thenAnswer(invocation -> {
            Agendamento entity = invocation.getArgument(0);
            entity.setId(99L);
            return entity;
        });

        AgendamentoRequest request = criarRequestBasico();

        AgendamentoDTO dto = agendamentoService.criar(request);

        ArgumentCaptor<Agendamento> captor = ArgumentCaptor.forClass(Agendamento.class);
        verify(agendamentoRepository).save(captor.capture());
        verify(tosIntegrationService).validarAgendamentoParaCriacao("AG001", any());
        verify(dashboardService).publicarResumoGeral();
        verify(agendamentoRealtimeService).notificarStatus(any());

        Agendamento salvo = captor.getValue();
        assertThat(salvo.getCodigo()).isEqualTo("AG001");
        assertThat(salvo.getJanelaAtendimento()).isEqualTo(janela);
        assertThat(dto.getId()).isEqualTo(99L);
    }

    private JanelaAtendimento criarJanelaComCapacidade(int capacidade) {
        JanelaAtendimento janela = new JanelaAtendimento();
        janela.setId(1L);
        janela.setCapacidade(capacidade);
        janela.setData(LocalDate.now().plusDays(1));
        janela.setHoraInicio(LocalTime.of(10, 0));
        janela.setHoraFim(LocalTime.of(14, 0));
        return janela;
    }

    private AgendamentoRequest criarRequestBasico() {
        LocalDateTime inicio = LocalDateTime.now().plusHours(6);
        AgendamentoRequest request = new AgendamentoRequest();
        request.setCodigo("AG001");
        request.setTipoOperacao("ENTRADA");
        request.setStatus("PENDENTE");
        request.setTransportadoraId(2L);
        request.setMotoristaId(3L);
        request.setVeiculoId(4L);
        request.setJanelaAtendimentoId(1L);
        request.setHorarioPrevistoChegada(inicio);
        request.setHorarioPrevistoSaida(inicio.plusHours(1));
        request.setObservacoes("Teste automatizado");
        return request;
    }
}

 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\app\gestor\GateFlowControllerSecurityTest.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import br.com.cloudport.servicogate.config.SecurityConfig;
import br.com.cloudport.servicogate.app.gestor.dto.GateEventDTO;
import br.com.cloudport.servicogate.app.gestor.dto.ManualReleaseAction;
import br.com.cloudport.servicogate.app.gestor.dto.ManualReleaseRequest;
import br.com.cloudport.servicogate.security.TransportadoraSynchronizationFilter;
import br.com.cloudport.servicogate.app.gestor.GateFlowService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(controllers = GateFlowController.class)
@Import(SecurityConfig.class)
@TestPropertySource(properties = {
        "cloudport.security.jwt.secret=test-secret",
        "cloudport.security.cors.allowed-origins=http://localhost:4200"
})
class GateFlowControllerSecurityTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private GateFlowService gateFlowService;

    @MockBean
    private TransportadoraSynchronizationFilter transportadoraSynchronizationFilter;

    @Test
    void liberarManual_retornaUnauthorized_semToken() throws Exception {
        ManualReleaseRequest request = new ManualReleaseRequest();
        request.setAcao(ManualReleaseAction.LIBERAR);
        String payload = objectMapper.writeValueAsString(request);

        mockMvc.perform(post("/gate/agendamentos/1/liberacao-manual")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(payload))
                .andExpect(status().isUnauthorized());
    }

    @Test
    void liberarManual_permitidoParaOperador() throws Exception {
        ManualReleaseRequest request = new ManualReleaseRequest();
        request.setAcao(ManualReleaseAction.LIBERAR);
        request.setObservacao("Liberado");

        when(gateFlowService.liberarManual(eq(1L), any())).thenReturn(new GateEventDTO());

        mockMvc.perform(post("/gate/agendamentos/1/liberacao-manual")
                        .with(jwt().authorities(new SimpleGrantedAuthority("ROLE_OPERADOR_GATE")))
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk());
    }

    @Test
    void liberarManual_negadoParaPlanejador() throws Exception {
        ManualReleaseRequest request = new ManualReleaseRequest();
        request.setAcao(ManualReleaseAction.LIBERAR);

        mockMvc.perform(post("/gate/agendamentos/1/liberacao-manual")
                        .with(jwt().authorities(new SimpleGrantedAuthority("ROLE_PLANEJADOR")))
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isForbidden());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\app\gestor\GateFlowControllerTest.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import br.com.cloudport.servicogate.app.gestor.dto.GateDecisionDTO;
import br.com.cloudport.servicogate.app.gestor.dto.GateFlowRequest;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import br.com.cloudport.servicogate.app.gestor.GateFlowService;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.time.LocalDateTime;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

@WebMvcTest(GateFlowController.class)
class GateFlowControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private GateFlowService gateFlowService;

    @Test
    @DisplayName("Deve bloquear chamadas sem autenticação no fluxo de entrada")
    void deveRetornar401QuandoNaoAutenticado() throws Exception {
        GateFlowRequest request = new GateFlowRequest();
        request.setPlaca("ABC1234");
        request.setTimestamp(LocalDateTime.now());

        mockMvc.perform(post("/gate/entrada")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("Deve aceitar eventos de entrada para usuário com perfil de operador")
    @WithMockUser(roles = "OPERADOR_GATE")
    void devePermitirEntradaParaOperador() throws Exception {
        Agendamento agendamento = new Agendamento();
        agendamento.setId(10L);
        agendamento.setCodigo("AG-100");
        GateDecisionDTO decision = GateDecisionDTO.autorizado(StatusGate.LIBERADO, agendamento, null,
                "Entrada liberada");
        when(gateFlowService.registrarEntrada(any())).thenReturn(decision);

        GateFlowRequest request = new GateFlowRequest();
        request.setPlaca("ABC1234");
        request.setTimestamp(LocalDateTime.now());
        request.setOperador("joao");

        mockMvc.perform(post("/gate/entrada")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.autorizado").value(true))
                .andExpect(jsonPath("$.agendamentoId").value(10L))
                .andExpect(jsonPath("$.mensagem").value("Entrada liberada"));
    }
}

 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\app\gestor\GateFlowIntegrationTest.java ----- 
package br.com.cloudport.servicogate.app.gestor;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import br.com.cloudport.servicogate.app.gestor.dto.GateDecisionDTO;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.enums.StatusGate;
import br.com.cloudport.servicogate.app.gestor.GateFlowService;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.time.LocalDateTime;
import java.util.Map;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
@TestPropertySource(properties = {
        "spring.flyway.enabled=false",
        "spring.datasource.url=jdbc:h2:mem:gate-test;MODE=PostgreSQL;DB_CLOSE_DELAY=-1",
        "spring.datasource.driver-class-name=org.h2.Driver",
        "spring.datasource.username=sa",
        "spring.datasource.password=",
        "spring.jpa.hibernate.ddl-auto=none"
})
class GateFlowIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private GateFlowService gateFlowService;

    @Test
    @DisplayName("Fluxo de saída deve exigir autenticação com perfis válidos")
    void saidaDeveExigirAutenticacao() throws Exception {
        mockMvc.perform(post("/gate/saida")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(Map.of("placa", "DEF5678"))))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("Fluxo de saída com usuário autenticado deve responder 200")
    @WithMockUser(roles = {"ADMIN_PORTO"})
    void saidaAutenticada() throws Exception {
        Agendamento agendamento = new Agendamento();
        agendamento.setId(22L);
        agendamento.setCodigo("AG-200");
        when(gateFlowService.registrarSaida(any())).thenReturn(
                GateDecisionDTO.autorizado(StatusGate.FINALIZADO, agendamento, null, "Saída registrada"));

        Map<String, Object> payload = Map.of(
                "placa", "DEF5678",
                "timestamp", LocalDateTime.now().toString(),
                "operador", "maria"
        );

        mockMvc.perform(post("/gate/saida")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(payload)))
                .andExpect(status().isOk());
    }
}

 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\app\transparencia\DashboardServiceTest.java ----- 
package br.com.cloudport.servicogate.app.transparencia;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

import br.com.cloudport.servicogate.app.transparencia.dto.DashboardFiltroDTO;
import br.com.cloudport.servicogate.model.Agendamento;
import br.com.cloudport.servicogate.model.JanelaAtendimento;
import br.com.cloudport.servicogate.model.enums.StatusAgendamento;
import br.com.cloudport.servicogate.app.cidadao.AgendamentoRepository;
import br.com.cloudport.servicogate.app.transparencia.DashboardMetricsProjection;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(MockitoExtension.class)
class DashboardServiceTest {

    @Mock
    private AgendamentoRepository agendamentoRepository;

    private DashboardService dashboardService;

    @BeforeEach
    void setUp() {
        dashboardService = new DashboardService(agendamentoRepository);
    }

    @Test
    @DisplayName("Deve calcular ocupação por hora respeitando capacidade e cancelamentos")
    void deveCalcularOcupacaoPorHora() {
        DashboardMetricsProjection projection = Mockito.mock(DashboardMetricsProjection.class);
        when(projection.getTotalAgendamentos()).thenReturn(2L);
        when(projection.getPontuais()).thenReturn(2L);
        when(projection.getNoShow()).thenReturn(0L);
        when(projection.getOcupacaoSlots()).thenReturn(0.5D);
        when(agendamentoRepository.calcularMetricasDashboard(any(), any(), any(), any(), any()))
                .thenReturn(projection);

        JanelaAtendimento janela = new JanelaAtendimento();
        janela.setCapacidade(3);
        janela.setData(LocalDate.now().plusDays(1));
        janela.setHoraInicio(LocalTime.of(10, 0));
        janela.setHoraFim(LocalTime.of(12, 0));

        Agendamento confirmado = new Agendamento();
        confirmado.setStatus(StatusAgendamento.CONFIRMADO);
        confirmado.setJanelaAtendimento(janela);

        Agendamento cancelado = new Agendamento();
        cancelado.setStatus(StatusAgendamento.CANCELADO);
        cancelado.setJanelaAtendimento(janela);

        when(agendamentoRepository.buscarRelatorio(any(), any(), any(), any()))
                .thenReturn(List.of(confirmado, cancelado));

        var resumo = dashboardService.obterResumo(new DashboardFiltroDTO());

        assertThat(resumo.getOcupacaoPorHora()).hasSize(1);
        assertThat(resumo.getOcupacaoPorHora().get(0).getTotalAgendamentos()).isEqualTo(1L);
        assertThat(resumo.getOcupacaoPorHora().get(0).getCapacidadeSlot()).isEqualTo(3);
        assertThat(resumo.getPercentualOcupacaoSlots()).isEqualTo(50.0d);
        assertThat(resumo.getPercentualPontualidade()).isEqualTo(100.0d);
    }
}

 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\config\AgendamentoRulesPropertiesTest.java ----- 
package br.com.cloudport.servicogate.config;

import static org.assertj.core.api.Assertions.assertThat;

import java.time.Duration;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class AgendamentoRulesPropertiesTest {

    @Test
    @DisplayName("Deve expor valores padrão coerentes para as regras de agendamento")
    void deveAplicarValoresPadrao() {
        AgendamentoRulesProperties properties = new AgendamentoRulesProperties();

        assertThat(properties.getAntecedenciaMinima()).isEqualTo(Duration.ofHours(2));
        assertThat(properties.getAtrasoMaximo()).isEqualTo(Duration.ofHours(1));
        assertThat(properties.getEdicaoAntecedencia()).isEqualTo(Duration.ofHours(12));
        assertThat(properties.getEdicaoAtraso()).isEqualTo(Duration.ofHours(2));
        assertThat(properties.getNotificacaoJanelaAntecedencia()).isEqualTo(Duration.ofMinutes(30));
    }
}

 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\integration\tos\TosConsumerContractTest.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import static org.assertj.core.api.Assertions.assertThat;

import br.com.cloudport.servicogate.contingencia.ContingenciaProperties;
import br.com.cloudport.servicogate.monitoring.GateMetrics;
import br.com.cloudport.servicogate.monitoring.IntegracaoDegradacaoHandler;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.cloud.contract.wiremock.AutoConfigureWireMock;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;

@SpringBootTest(classes = TosConsumerContractTest.TestConfig.class)
@AutoConfigureWireMock(port = 0, stubs = "classpath:/contracts/tos")
class TosConsumerContractTest {

    @DynamicPropertySource
    static void overrideBaseUrl(DynamicPropertyRegistry registry) {
        registry.add("cloudport.tos.api.base-url", () -> "http://localhost:" + Integer.getInteger("wiremock.server.port", 0));
    }

    @Autowired
    private TosIntegrationService integrationService;

    @Test
    @DisplayName("Contrato: deve mapear booking liberado vindo do TOS")
    void deveRespeitarContratoBookingLiberado() {
        var info = integrationService.obterBookingInfo("BK999");

        assertThat(info).isNotNull();
        assertThat(info.getBookingNumber()).isEqualTo("BK999");
        assertThat(info.isLiberado()).isTrue();
        assertThat(info.getVessel()).isEqualTo("Cloud Express");
    }

    @TestConfiguration
    @Import(TosClientConfig.class)
    static class TestConfig {

        @Bean
        TosProperties tosProperties() {
            TosProperties properties = new TosProperties();
            properties.getApi().setBaseUrl("http://localhost:" + Integer.getInteger("wiremock.server.port", 0));
            return properties;
        }

        @Bean
        IntegracaoDegradacaoHandler integracaoDegradacaoHandler() {
            return new IntegracaoDegradacaoHandler(new GateMetrics(new SimpleMeterRegistry()));
        }

        @Bean
        ContingenciaProperties contingenciaProperties() {
            return new ContingenciaProperties();
        }

        @Bean
        TosClient tosClient(TosClientConfig config,
                            TosProperties properties,
                            IntegracaoDegradacaoHandler degradacaoHandler,
                            ContingenciaProperties contingenciaProperties) {
            return new TosClient(
                    config.tosWebClient(properties),
                    properties,
                    config.tosRetry(properties),
                    config.tosCircuitBreaker(CircuitBreakerRegistry.ofDefaults()),
                    degradacaoHandler,
                    contingenciaProperties
            );
        }

        @Bean
        TosIntegrationService tosIntegrationService(TosClient client,
                                                     TosClientConfig config,
                                                     TosProperties properties) {
            return new TosIntegrationService(
                    client,
                    new TosResponseAdapter(),
                    config.cacheManager(properties)
            );
        }
    }
}

 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\integration\tos\TosIntegrationServiceTest.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import br.com.cloudport.servicogate.contingencia.ContingenciaProperties;
import br.com.cloudport.servicogate.integration.tos.TosIntegrationException;
import br.com.cloudport.servicogate.monitoring.GateMetrics;
import br.com.cloudport.servicogate.monitoring.IntegracaoDegradacaoHandler;
import com.squareup.okhttp.mockwebserver.MockResponse;
import com.squareup.okhttp.mockwebserver.MockWebServer;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import java.io.IOException;
import java.time.Duration;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.cache.CacheManager;
import org.springframework.web.reactive.function.client.WebClient;

class TosIntegrationServiceTest {

    private MockWebServer mockWebServer;
    private TosIntegrationService integrationService;

    @BeforeEach
    void setUp() throws IOException {
        mockWebServer = new MockWebServer();
        mockWebServer.start();

        TosProperties properties = new TosProperties();
        properties.getApi().setBaseUrl(mockWebServer.url("/").toString());
        properties.getApi().setTimeout(Duration.ofSeconds(5));
        properties.getCache().setMaxSize(10);
        properties.getCache().setTtl(Duration.ofSeconds(30));

        TosClientConfig config = new TosClientConfig();
        WebClient webClient = config.tosWebClient(properties);
        CacheManager cacheManager = config.cacheManager(properties);

        IntegracaoDegradacaoHandler degradacaoHandler = new IntegracaoDegradacaoHandler(
                new GateMetrics(new SimpleMeterRegistry()));
        TosClient client = new TosClient(
                webClient,
                properties,
                config.tosRetry(properties),
                config.tosCircuitBreaker(CircuitBreakerRegistry.ofDefaults()),
                degradacaoHandler,
                new ContingenciaProperties()
        );

        integrationService = new TosIntegrationService(
                client,
                new TosResponseAdapter(),
                cacheManager
        );
    }

    @AfterEach
    void tearDown() throws IOException {
        mockWebServer.shutdown();
    }

    @Test
    @DisplayName("Deve validar criação de agendamento quando booking está liberado no TOS")
    void deveValidarAgendamentoQuandoBookingLiberado() {
        mockWebServer.enqueue(new MockResponse()
                .setBody("{\"bookingNumber\":\"BK001\",\"released\":true,\"denialReason\":null}")
                .addHeader("Content-Type", "application/json"));

        integrationService.validarAgendamentoParaCriacao("BK001", br.com.cloudport.servicogate.model.enums.TipoOperacao.ENTRADA);

        var recorded = mockWebServer.getRequestCount();
        assertThat(recorded).isEqualTo(1);
    }

    @Test
    @DisplayName("Deve lançar exceção quando TOS sinalizar bloqueio do booking")
    void deveLancarExcecaoQuandoBookingNegado() {
        mockWebServer.enqueue(new MockResponse()
                .setBody("{\"bookingNumber\":\"BK002\",\"released\":false,\"denialReason\":\"Pendência\"}")
                .addHeader("Content-Type", "application/json"));

        assertThatThrownBy(() -> integrationService.validarAgendamentoParaCriacao("BK002",
                br.com.cloudport.servicogate.model.enums.TipoOperacao.SAIDA))
                .isInstanceOf(TosIntegrationException.class)
                .hasMessageContaining("BK002")
                .hasMessageContaining("Pendência");
    }
}

 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\java\br\com\cloudport\servicogate\integration\tos\TosResponseAdapterTest.java ----- 
package br.com.cloudport.servicogate.integration.tos;

import static org.assertj.core.api.Assertions.assertThat;

import br.com.cloudport.servicogate.app.gestor.dto.TosBookingInfo;
import br.com.cloudport.servicogate.app.gestor.dto.TosContainerStatus;
import br.com.cloudport.servicogate.integration.tos.model.TosBookingResponse;
import br.com.cloudport.servicogate.integration.tos.model.TosContainerStatusResponse;
import br.com.cloudport.servicogate.integration.tos.model.TosCustomsReleaseResponse;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class TosResponseAdapterTest {

    private TosResponseAdapter adapter;

    @BeforeEach
    void setUp() {
        adapter = new TosResponseAdapter();
    }

    @Test
    void deveConverterBookingResponseParaInfoInterna() {
        TosBookingResponse response = new TosBookingResponse();
        response.setBookingNumber("BK123");
        response.setReleased(true);
        response.setDenialReason("Nenhuma");
        response.setVessel("Evergreen");
        response.setVoyage("EVG-01");
        response.setCutoff(OffsetDateTime.of(2023, 12, 10, 15, 30, 0, 0, ZoneOffset.UTC));

        TosBookingInfo info = adapter.toBookingInfo(response);

        assertThat(info).isNotNull();
        assertThat(info.getBookingNumber()).isEqualTo("BK123");
        assertThat(info.getVessel()).isEqualTo("Evergreen");
        assertThat(info.getVoyage()).isEqualTo("EVG-01");
        assertThat(info.getCutoff()).isEqualTo(response.getCutoff().toLocalDateTime());
        assertThat(info.isLiberado()).isTrue();
        assertThat(info.getMotivoRestricao()).isEqualTo("Nenhuma");
    }

    @Test
    void deveConverterStatusEIntegrarComLiberacaoAduaneira() {
        TosContainerStatusResponse statusResponse = new TosContainerStatusResponse();
        statusResponse.setContainerNumber("CONT1");
        statusResponse.setStatus("HOLD");
        statusResponse.setGateAllowed(false);
        statusResponse.setHoldReason("Documentos pendentes");
        statusResponse.setLastUpdate(OffsetDateTime.now(ZoneOffset.UTC));

        TosCustomsReleaseResponse customsResponse = new TosCustomsReleaseResponse();
        customsResponse.setReleased(true);
        customsResponse.setDenialReason("Sem restrições");

        TosContainerStatus status = adapter.toContainerStatus(statusResponse, customsResponse);

        assertThat(status).isNotNull();
        assertThat(status.getContainerNumber()).isEqualTo("CONT1");
        assertThat(status.getStatus()).isEqualTo("HOLD");
        assertThat(status.isGateLiberado()).isFalse();
        assertThat(status.isLiberacaoAduaneira()).isTrue();
        assertThat(status.getMotivoRestricao()).isEqualTo("Documentos pendentes");
        assertThat(status.getUltimaAtualizacao()).isEqualTo(statusResponse.getLastUpdate().toLocalDateTime());
    }

    @Test
    void devePreservarMotivoDoTosQuandoLiberacaoAduaneiraNegada() {
        TosContainerStatusResponse statusResponse = new TosContainerStatusResponse();
        statusResponse.setContainerNumber("CONT2");
        statusResponse.setStatus("CUSTOMS_HOLD");
        statusResponse.setGateAllowed(true);
        statusResponse.setHoldReason("Sem motivo informado");
        statusResponse.setLastUpdate(OffsetDateTime.now(ZoneOffset.UTC));

        TosCustomsReleaseResponse customsResponse = new TosCustomsReleaseResponse();
        customsResponse.setReleased(false);
        customsResponse.setDenialReason("Aguardando Receita Federal");

        TosContainerStatus status = adapter.toContainerStatus(statusResponse, customsResponse);

        assertThat(status).isNotNull();
        assertThat(status.isLiberacaoAduaneira()).isFalse();
        assertThat(status.getMotivoRestricao()).isEqualTo("Aguardando Receita Federal");
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\resources\application-test.properties ----- 
server.port=${GATE_SERVER_PORT:0}

spring.application.name=servico-gate-test

spring.datasource.url=${GATE_DB_URL:jdbc:postgresql://localhost:5432/servico_gate_test}
spring.datasource.username=${GATE_DB_USERNAME:postgres}
spring.datasource.password=${GATE_DB_PASSWORD:postgres}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=none
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.default-schema=${GATE_FLYWAY_SCHEMA:cloudport}
spring.flyway.schemas=${GATE_FLYWAY_SCHEMA:cloudport}

spring.rabbitmq.host=${GATE_RABBIT_HOST:localhost}
spring.rabbitmq.port=${GATE_RABBIT_PORT:5672}
spring.rabbitmq.username=${GATE_RABBIT_USERNAME:guest}
spring.rabbitmq.password=${GATE_RABBIT_PASSWORD:guest}

management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.probes.enabled=true
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html

cloudport.tos.api.base-url=${TOS_API_BASE_URL:http://localhost:8080}
cloudport.tos.api.timeout=${TOS_API_TIMEOUT_MS:5000}

cloudport.document-storage.provider=${DOCUMENT_STORAGE_PROVIDER:local}
cloudport.document-storage.base-path=${DOCUMENT_STORAGE_BASE_PATH:/var/lib/cloudport/documents/test}
cloudport.document-storage.bucket=${DOCUMENT_STORAGE_BUCKET:cloudport-documents-test}

resilience4j.circuitbreaker.instances.tosApi.register-health-indicator=true
resilience4j.circuitbreaker.instances.tosApi.sliding-window-size=${RESILIENCE4J_TOS_WINDOW_SIZE:10}
resilience4j.circuitbreaker.instances.tosApi.failure-rate-threshold=${RESILIENCE4J_TOS_FAILURE_THRESHOLD:50}
resilience4j.circuitbreaker.instances.tosApi.wait-duration-in-open-state=${RESILIENCE4J_TOS_WAIT_DURATION:PT30S}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-gate\src\test\resources\contracts\tos\booking-liberado.json ----- 
{
  "request": {
    "method": "GET",
    "urlPattern": "/tos/bookings/([A-Z0-9-]+)"
  },
  "response": {
    "status": 200,
    "headers": {
      "Content-Type": "application/json"
    },
    "jsonBody": {
      "bookingNumber": "BK999",
      "released": true,
      "denialReason": null,
      "vessel": "Cloud Express",
      "voyage": "CP-01"
    }
  }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\pom.xml ----- 
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.4</version>
        <relativePath/>
    </parent>
    <groupId>br.com.cloudport</groupId>
    <artifactId>servico-rail</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>servico-rail</name>
    <description>Serviço de planejamento ferroviário</description>
    <properties>
        <java.version>11</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.jsoup</groupId>
            <artifactId>jsoup</artifactId>
            <version>1.17.2</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ServicoRailApplication.java ----- 
package br.com.cloudport.servicorail;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServicoRailApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServicoRailApplication.class, args);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\comum\sanitizacao\SanitizadorEntrada.java ----- 
package br.com.cloudport.servicorail.comum.sanitizacao;

import org.jsoup.Jsoup;
import org.jsoup.safety.Safelist;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

@Component
public class SanitizadorEntrada {
    public String limparTexto(String valor) {
        if (!StringUtils.hasText(valor)) {
            return null;
        }
        String limpo = Jsoup.clean(valor, Safelist.none());
        return StringUtils.hasText(limpo) ? limpo.trim() : null;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\comum\validacao\ValidacaoEntradaUtil.java ----- 
package br.com.cloudport.servicorail.comum.validacao;

import java.util.List;
import java.util.Objects;
import java.util.regex.Pattern;

public final class ValidacaoEntradaUtil {

    private static final Pattern PADRAO_TEXTO_SEGURO = Pattern.compile("^[\\p{L}0-9\\s\\-_/.:]*$");

    private ValidacaoEntradaUtil() {
    }

    public static String limparTexto(String valor) {
        if (valor == null) {
            return null;
        }
        String ajustado = valor.trim();
        validarConteudo(ajustado);
        return ajustado;
    }

    public static List<String> limparLista(List<String> valores) {
        if (valores == null) {
            return List.of();
        }
        return valores.stream()
                .filter(Objects::nonNull)
                .map(String::trim)
                .filter(valor -> !valor.isEmpty())
                .peek(ValidacaoEntradaUtil::validarConteudo)
                .distinct()
                .collect(java.util.stream.Collectors.toList());
    }

    private static void validarConteudo(String valor) {
        if (valor.isEmpty()) {
            return;
        }
        if (valor.contains("<") || valor.contains(">")) {
            throw new IllegalArgumentException("Valor contém caracteres não permitidos.");
        }
        if (!PADRAO_TEXTO_SEGURO.matcher(valor).matches()) {
            throw new IllegalArgumentException("Valor contém caracteres inválidos.");
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\configuracao\RabbitConfiguracao.java ----- 
package br.com.cloudport.servicorail.configuracao;

import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfiguracao {

    @Bean
    public MessageConverter conversorMensagemJson() {
        return new Jackson2JsonMessageConverter();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\controlador\ImportacaoManifestoVisitaControlador.java ----- 
package br.com.cloudport.servicorail.ferrovia.controlador;

import br.com.cloudport.servicorail.ferrovia.dto.VisitaTremRespostaDto;
import br.com.cloudport.servicorail.ferrovia.servico.ImportacaoManifestoVisitaServico;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/rail/ferrovia/visitas/importacoes")
public class ImportacaoManifestoVisitaControlador {

    private final ImportacaoManifestoVisitaServico importacaoManifestoVisitaServico;

    public ImportacaoManifestoVisitaControlador(ImportacaoManifestoVisitaServico importacaoManifestoVisitaServico) {
        this.importacaoManifestoVisitaServico = importacaoManifestoVisitaServico;
    }

    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @ResponseStatus(HttpStatus.OK)
    public VisitaTremRespostaDto importar(@RequestPart("arquivo") MultipartFile arquivo) {
        return importacaoManifestoVisitaServico.importarManifesto(arquivo);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\controlador\VisitaTremControlador.java ----- 
package br.com.cloudport.servicorail.ferrovia.controlador;

import br.com.cloudport.servicorail.ferrovia.dto.AtualizacaoStatusOperacaoConteinerDto;
import br.com.cloudport.servicorail.ferrovia.dto.OperacaoConteinerVisitaRequisicaoDto;
import br.com.cloudport.servicorail.ferrovia.dto.VisitaTremRequisicaoDto;
import br.com.cloudport.servicorail.ferrovia.dto.VisitaTremRespostaDto;
import br.com.cloudport.servicorail.ferrovia.servico.VisitaTremServico;
import java.util.List;
import javax.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/rail/ferrovia/visitas")
public class VisitaTremControlador {

    private final VisitaTremServico visitaTremServico;

    public VisitaTremControlador(VisitaTremServico visitaTremServico) {
        this.visitaTremServico = visitaTremServico;
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public VisitaTremRespostaDto registrar(@Valid @RequestBody VisitaTremRequisicaoDto dto) {
        return visitaTremServico.registrarVisita(dto);
    }

    @PutMapping("/{id}")
    public VisitaTremRespostaDto atualizar(@PathVariable("id") Long id,
                                           @Valid @RequestBody VisitaTremRequisicaoDto dto) {
        return visitaTremServico.atualizarVisita(id, dto);
    }

    @GetMapping("/{id}")
    public VisitaTremRespostaDto consultar(@PathVariable("id") Long id) {
        return visitaTremServico.consultarVisita(id);
    }

    @GetMapping
    public List<VisitaTremRespostaDto> listar(@RequestParam(name = "dias", defaultValue = "7") int dias) {
        return visitaTremServico.listarVisitasProximosDias(dias);
    }

    @PostMapping("/{id}/descarga")
    public VisitaTremRespostaDto adicionarConteinerDescarga(@PathVariable("id") Long id,
                                                            @Valid @RequestBody OperacaoConteinerVisitaRequisicaoDto dto) {
        return visitaTremServico.adicionarConteinerDescarga(id, dto);
    }

    @PostMapping("/{id}/carga")
    public VisitaTremRespostaDto adicionarConteinerCarga(@PathVariable("id") Long id,
                                                         @Valid @RequestBody OperacaoConteinerVisitaRequisicaoDto dto) {
        return visitaTremServico.adicionarConteinerCarga(id, dto);
    }

    @DeleteMapping("/{id}/descarga/{codigoConteiner}")
    public VisitaTremRespostaDto removerConteinerDescarga(@PathVariable("id") Long id,
                                                          @PathVariable("codigoConteiner") String codigoConteiner) {
        return visitaTremServico.removerConteinerDescarga(id, codigoConteiner);
    }

    @DeleteMapping("/{id}/carga/{codigoConteiner}")
    public VisitaTremRespostaDto removerConteinerCarga(@PathVariable("id") Long id,
                                                       @PathVariable("codigoConteiner") String codigoConteiner) {
        return visitaTremServico.removerConteinerCarga(id, codigoConteiner);
    }

    @PatchMapping("/{id}/descarga/{codigoConteiner}/status")
    public VisitaTremRespostaDto atualizarStatusDescarga(@PathVariable("id") Long id,
                                                         @PathVariable("codigoConteiner") String codigoConteiner,
                                                         @Valid @RequestBody AtualizacaoStatusOperacaoConteinerDto dto) {
        return visitaTremServico.atualizarStatusDescarga(id, codigoConteiner, dto.getStatusOperacao());
    }

    @PatchMapping("/{id}/carga/{codigoConteiner}/status")
    public VisitaTremRespostaDto atualizarStatusCarga(@PathVariable("id") Long id,
                                                      @PathVariable("codigoConteiner") String codigoConteiner,
                                                      @Valid @RequestBody AtualizacaoStatusOperacaoConteinerDto dto) {
        return visitaTremServico.atualizarStatusCarga(id, codigoConteiner, dto.getStatusOperacao());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\dto\AtualizacaoStatusOperacaoConteinerDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.dto;

import br.com.cloudport.servicorail.ferrovia.modelo.StatusOperacaoConteinerVisita;
import javax.validation.constraints.NotNull;

public class AtualizacaoStatusOperacaoConteinerDto {

    @NotNull
    private StatusOperacaoConteinerVisita statusOperacao;

    public StatusOperacaoConteinerVisita getStatusOperacao() {
        return statusOperacao;
    }

    public void setStatusOperacao(StatusOperacaoConteinerVisita statusOperacao) {
        this.statusOperacao = statusOperacao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\dto\EventoMovimentacaoTremConcluidaDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.dto;

import java.time.OffsetDateTime;

public class EventoMovimentacaoTremConcluidaDto {

    private Long idVisitaTrem;
    private Long idOrdemMovimentacao;
    private String codigoConteiner;
    private String tipoMovimentacao;
    private OffsetDateTime concluidoEm;
    private String statusEvento;

    public EventoMovimentacaoTremConcluidaDto() {
    }

    public EventoMovimentacaoTremConcluidaDto(Long idVisitaTrem,
                                              Long idOrdemMovimentacao,
                                              String codigoConteiner,
                                              String tipoMovimentacao,
                                              OffsetDateTime concluidoEm,
                                              String statusEvento) {
        this.idVisitaTrem = idVisitaTrem;
        this.idOrdemMovimentacao = idOrdemMovimentacao;
        this.codigoConteiner = codigoConteiner;
        this.tipoMovimentacao = tipoMovimentacao;
        this.concluidoEm = concluidoEm;
        this.statusEvento = statusEvento;
    }

    public Long getIdVisitaTrem() {
        return idVisitaTrem;
    }

    public void setIdVisitaTrem(Long idVisitaTrem) {
        this.idVisitaTrem = idVisitaTrem;
    }

    public Long getIdOrdemMovimentacao() {
        return idOrdemMovimentacao;
    }

    public void setIdOrdemMovimentacao(Long idOrdemMovimentacao) {
        this.idOrdemMovimentacao = idOrdemMovimentacao;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public String getTipoMovimentacao() {
        return tipoMovimentacao;
    }

    public void setTipoMovimentacao(String tipoMovimentacao) {
        this.tipoMovimentacao = tipoMovimentacao;
    }

    public OffsetDateTime getConcluidoEm() {
        return concluidoEm;
    }

    public void setConcluidoEm(OffsetDateTime concluidoEm) {
        this.concluidoEm = concluidoEm;
    }

    public String getStatusEvento() {
        return statusEvento;
    }

    public void setStatusEvento(String statusEvento) {
        this.statusEvento = statusEvento;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\dto\OperacaoConteinerVisitaRequisicaoDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.dto;

import br.com.cloudport.servicorail.ferrovia.modelo.StatusOperacaoConteinerVisita;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public class OperacaoConteinerVisitaRequisicaoDto {

    @NotBlank
    @Size(max = 20)
    private String codigoConteiner;

    private StatusOperacaoConteinerVisita statusOperacao = StatusOperacaoConteinerVisita.PENDENTE;

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public StatusOperacaoConteinerVisita getStatusOperacao() {
        return statusOperacao;
    }

    public void setStatusOperacao(StatusOperacaoConteinerVisita statusOperacao) {
        if (statusOperacao != null) {
            this.statusOperacao = statusOperacao;
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\dto\OperacaoConteinerVisitaRespostaDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.dto;

import br.com.cloudport.servicorail.ferrovia.modelo.OperacaoConteinerVisita;
import br.com.cloudport.servicorail.ferrovia.modelo.StatusOperacaoConteinerVisita;
import org.springframework.web.util.HtmlUtils;

public class OperacaoConteinerVisitaRespostaDto {

    private final String codigoConteiner;
    private final StatusOperacaoConteinerVisita statusOperacao;

    public OperacaoConteinerVisitaRespostaDto(String codigoConteiner,
                                              StatusOperacaoConteinerVisita statusOperacao) {
        this.codigoConteiner = codigoConteiner;
        this.statusOperacao = statusOperacao;
    }

    public static OperacaoConteinerVisitaRespostaDto deEmbeddable(OperacaoConteinerVisita operacao) {
        return new OperacaoConteinerVisitaRespostaDto(
                HtmlUtils.htmlEscape(operacao.getCodigoConteiner()),
                operacao.getStatusOperacao()
        );
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public StatusOperacaoConteinerVisita getStatusOperacao() {
        return statusOperacao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\dto\VagaoVisitaRequisicaoDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.dto;

import br.com.cloudport.servicorail.comum.validacao.ValidacaoEntradaUtil;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class VagaoVisitaRequisicaoDto {

    @NotNull
    @Min(1)
    private Integer posicaoNoTrem;

    @NotBlank
    @Size(max = 35)
    private String identificadorVagao;

    @Size(max = 40)
    private String tipoVagao;

    public Integer getPosicaoNoTrem() {
        return posicaoNoTrem;
    }

    public void setPosicaoNoTrem(Integer posicaoNoTrem) {
        this.posicaoNoTrem = posicaoNoTrem;
    }

    public String getIdentificadorVagao() {
        return identificadorVagao;
    }

    public void setIdentificadorVagao(String identificadorVagao) {
        this.identificadorVagao = ValidacaoEntradaUtil.limparTexto(identificadorVagao);
    }

    public String getTipoVagao() {
        return tipoVagao;
    }

    public void setTipoVagao(String tipoVagao) {
        this.tipoVagao = ValidacaoEntradaUtil.limparTexto(tipoVagao);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\dto\VagaoVisitaRespostaDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.dto;

import br.com.cloudport.servicorail.ferrovia.modelo.VagaoVisita;
import org.springframework.web.util.HtmlUtils;

public class VagaoVisitaRespostaDto {

    private final Integer posicaoNoTrem;
    private final String identificadorVagao;
    private final String tipoVagao;

    public VagaoVisitaRespostaDto(Integer posicaoNoTrem, String identificadorVagao, String tipoVagao) {
        this.posicaoNoTrem = posicaoNoTrem;
        this.identificadorVagao = identificadorVagao;
        this.tipoVagao = tipoVagao;
    }

    public static VagaoVisitaRespostaDto deEmbeddable(VagaoVisita vagao) {
        return new VagaoVisitaRespostaDto(
                vagao.getPosicaoNoTrem(),
                HtmlUtils.htmlEscape(vagao.getIdentificadorVagao()),
                HtmlUtils.htmlEscape(vagao.getTipoVagao())
        );
    }

    public Integer getPosicaoNoTrem() {
        return posicaoNoTrem;
    }

    public String getIdentificadorVagao() {
        return identificadorVagao;
    }

    public String getTipoVagao() {
        return tipoVagao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\dto\VisitaTremRequisicaoDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.dto;

import br.com.cloudport.servicorail.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.validation.Valid;

public class VisitaTremRequisicaoDto {

    @NotBlank
    @Size(max = 40)
    private String identificadorTrem;

    @NotBlank
    @Size(max = 80)
    private String operadoraFerroviaria;

    @NotNull
    private LocalDateTime horaChegadaPrevista;

    @NotNull
    private LocalDateTime horaPartidaPrevista;

    @NotNull
    private StatusVisitaTrem statusVisita;

    @Valid
    private List<OperacaoConteinerVisitaRequisicaoDto> listaDescarga = new ArrayList<>();

    @Valid
    private List<OperacaoConteinerVisitaRequisicaoDto> listaCarga = new ArrayList<>();

    @Valid
    private List<VagaoVisitaRequisicaoDto> listaVagoes = new ArrayList<>();

    public String getIdentificadorTrem() {
        return identificadorTrem;
    }

    public void setIdentificadorTrem(String identificadorTrem) {
        this.identificadorTrem = ValidacaoEntradaUtil.limparTexto(identificadorTrem);
    }

    public String getOperadoraFerroviaria() {
        return operadoraFerroviaria;
    }

    public void setOperadoraFerroviaria(String operadoraFerroviaria) {
        this.operadoraFerroviaria = ValidacaoEntradaUtil.limparTexto(operadoraFerroviaria);
    }

    public LocalDateTime getHoraChegadaPrevista() {
        return horaChegadaPrevista;
    }

    public void setHoraChegadaPrevista(LocalDateTime horaChegadaPrevista) {
        this.horaChegadaPrevista = horaChegadaPrevista;
    }

    public LocalDateTime getHoraPartidaPrevista() {
        return horaPartidaPrevista;
    }

    public void setHoraPartidaPrevista(LocalDateTime horaPartidaPrevista) {
        this.horaPartidaPrevista = horaPartidaPrevista;
    }

    public StatusVisitaTrem getStatusVisita() {
        return statusVisita;
    }

    public void setStatusVisita(StatusVisitaTrem statusVisita) {
        this.statusVisita = statusVisita;
    }

    public List<OperacaoConteinerVisitaRequisicaoDto> getListaDescarga() {
        return listaDescarga;
    }

    public void setListaDescarga(List<OperacaoConteinerVisitaRequisicaoDto> listaDescarga) {
        this.listaDescarga = listaDescarga != null ? new ArrayList<>(listaDescarga) : new ArrayList<>();
    }

    public List<OperacaoConteinerVisitaRequisicaoDto> getListaCarga() {
        return listaCarga;
    }

    public void setListaCarga(List<OperacaoConteinerVisitaRequisicaoDto> listaCarga) {
        this.listaCarga = listaCarga != null ? new ArrayList<>(listaCarga) : new ArrayList<>();
    }

    public List<VagaoVisitaRequisicaoDto> getListaVagoes() {
        return listaVagoes;
    }

    public void setListaVagoes(List<VagaoVisitaRequisicaoDto> listaVagoes) {
        this.listaVagoes = listaVagoes != null ? new ArrayList<>(listaVagoes) : new ArrayList<>();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\dto\VisitaTremRespostaDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.dto;

import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import br.com.cloudport.servicorail.ferrovia.modelo.VisitaTrem;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.web.util.HtmlUtils;

public class VisitaTremRespostaDto {

    private final Long id;
    private final String identificadorTrem;
    private final String operadoraFerroviaria;
    private final LocalDateTime horaChegadaPrevista;
    private final LocalDateTime horaPartidaPrevista;
    private final StatusVisitaTrem statusVisita;
    private final List<OperacaoConteinerVisitaRespostaDto> listaDescarga;
    private final List<OperacaoConteinerVisitaRespostaDto> listaCarga;
    private final List<VagaoVisitaRespostaDto> listaVagoes;

    public VisitaTremRespostaDto(Long id,
                                 String identificadorTrem,
                                 String operadoraFerroviaria,
                                 LocalDateTime horaChegadaPrevista,
                                 LocalDateTime horaPartidaPrevista,
                                 StatusVisitaTrem statusVisita,
                                 List<OperacaoConteinerVisitaRespostaDto> listaDescarga,
                                 List<OperacaoConteinerVisitaRespostaDto> listaCarga,
                                 List<VagaoVisitaRespostaDto> listaVagoes) {
        this.id = id;
        this.identificadorTrem = identificadorTrem;
        this.operadoraFerroviaria = operadoraFerroviaria;
        this.horaChegadaPrevista = horaChegadaPrevista;
        this.horaPartidaPrevista = horaPartidaPrevista;
        this.statusVisita = statusVisita;
        this.listaDescarga = listaDescarga;
        this.listaCarga = listaCarga;
        this.listaVagoes = listaVagoes;
    }

    public static VisitaTremRespostaDto deEntidade(VisitaTrem entidade) {
        return new VisitaTremRespostaDto(
                entidade.getId(),
                HtmlUtils.htmlEscape(entidade.getIdentificadorTrem()),
                HtmlUtils.htmlEscape(entidade.getOperadoraFerroviaria()),
                entidade.getHoraChegadaPrevista(),
                entidade.getHoraPartidaPrevista(),
                entidade.getStatusVisita(),
                entidade.getListaDescarga()
                        .stream()
                        .map(OperacaoConteinerVisitaRespostaDto::deEmbeddable)
                        .collect(Collectors.toList()),
                entidade.getListaCarga()
                        .stream()
                        .map(OperacaoConteinerVisitaRespostaDto::deEmbeddable)
                        .collect(Collectors.toList()),
                entidade.getListaVagoes()
                        .stream()
                        .map(VagaoVisitaRespostaDto::deEmbeddable)
                        .collect(Collectors.toList())
        );
    }

    public static VisitaTremRespostaDto deEntidadeSemListas(VisitaTrem entidade) {
        return new VisitaTremRespostaDto(
                entidade.getId(),
                HtmlUtils.htmlEscape(entidade.getIdentificadorTrem()),
                HtmlUtils.htmlEscape(entidade.getOperadoraFerroviaria()),
                entidade.getHoraChegadaPrevista(),
                entidade.getHoraPartidaPrevista(),
                entidade.getStatusVisita(),
                Collections.emptyList(),
                Collections.emptyList(),
                Collections.emptyList()
        );
    }

    public Long getId() {
        return id;
    }

    public String getIdentificadorTrem() {
        return identificadorTrem;
    }

    public String getOperadoraFerroviaria() {
        return operadoraFerroviaria;
    }

    public LocalDateTime getHoraChegadaPrevista() {
        return horaChegadaPrevista;
    }

    public LocalDateTime getHoraPartidaPrevista() {
        return horaPartidaPrevista;
    }

    public StatusVisitaTrem getStatusVisita() {
        return statusVisita;
    }

    public List<OperacaoConteinerVisitaRespostaDto> getListaDescarga() {
        return listaDescarga;
    }

    public List<OperacaoConteinerVisitaRespostaDto> getListaCarga() {
        return listaCarga;
    }

    public List<VagaoVisitaRespostaDto> getListaVagoes() {
        return listaVagoes;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\evento\PublicadorEventoMovimentacaoTrem.java ----- 
package br.com.cloudport.servicorail.ferrovia.evento;

import br.com.cloudport.servicorail.ferrovia.dto.EventoMovimentacaoTremConcluidaDto;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.util.Assert;

@Component
public class PublicadorEventoMovimentacaoTrem {

    private static final Logger LOGGER = LoggerFactory.getLogger(PublicadorEventoMovimentacaoTrem.class);

    private final RabbitTemplate rabbitTemplate;
    private final String exchange;
    private final String routingKey;

    public PublicadorEventoMovimentacaoTrem(RabbitTemplate rabbitTemplate,
                                            @Value("${cloudport.rail.eventos.exchange}") String exchange,
                                            @Value("${cloudport.rail.eventos.routing-movimentacao}") String routingKey) {
        this.rabbitTemplate = rabbitTemplate;
        this.exchange = exchange;
        this.routingKey = routingKey;
    }

    public void publicar(EventoMovimentacaoTremConcluidaDto evento) {
        Assert.notNull(evento, "Evento da movimentação do trem não pode ser nulo");
        LOGGER.info("event=movimentacao_trem.publicada ordem={} visita={} conteiner={} tipo={}",
                evento.getIdOrdemMovimentacao(), evento.getIdVisitaTrem(), evento.getCodigoConteiner(),
                evento.getTipoMovimentacao());
        rabbitTemplate.convertAndSend(exchange, routingKey, evento);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\importacao\ArquivoManifestoVisitaParser.java ----- 
package br.com.cloudport.servicorail.ferrovia.importacao;

public interface ArquivoManifestoVisitaParser {

    boolean suporta(String nomeArquivo, byte[] conteudo);

    ResultadoManifestoVisita parse(String nomeArquivo, byte[] conteudo);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\importacao\CoparnManifestoVisitaParser.java ----- 
package br.com.cloudport.servicorail.ferrovia.importacao;

import br.com.cloudport.servicorail.comum.sanitizacao.SanitizadorEntrada;
import br.com.cloudport.servicorail.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Locale;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ResponseStatusException;

@Component
public class CoparnManifestoVisitaParser implements ArquivoManifestoVisitaParser {

    private static final DateTimeFormatter FORMATO_CCYMMDDHHMM = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
    private static final DateTimeFormatter FORMATO_CCYMMDDHH = DateTimeFormatter.ofPattern("yyyyMMddHH");

    private final SanitizadorEntrada sanitizadorEntrada;

    public CoparnManifestoVisitaParser(SanitizadorEntrada sanitizadorEntrada) {
        this.sanitizadorEntrada = sanitizadorEntrada;
    }

    @Override
    public boolean suporta(String nomeArquivo, byte[] conteudo) {
        if (nomeArquivo != null) {
            String nome = nomeArquivo.toLowerCase(Locale.ROOT);
            if (nome.endsWith(".edi") || nome.endsWith(".edifact") || nome.endsWith(".ifc")) {
                return true;
            }
        }
        if (conteudo == null || conteudo.length == 0) {
            return false;
        }
        String texto = new String(conteudo, StandardCharsets.UTF_8);
        String textoNormalizado = texto.toUpperCase(Locale.ROOT);
        return textoNormalizado.contains("UNH+") && textoNormalizado.contains("COPARN");
    }

    @Override
    public ResultadoManifestoVisita parse(String nomeArquivo, byte[] conteudo) {
        if (conteudo == null || conteudo.length == 0) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo COPARN está vazio.");
        }
        String mensagem = new String(conteudo, StandardCharsets.UTF_8);
        String[] segmentos = mensagem.split("'");
        ResultadoManifestoVisita resultado = new ResultadoManifestoVisita();

        String ultimoConteiner = null;
        TipoOperacaoManifesto ultimaOperacao = TipoOperacaoManifesto.DESCARGA;
        int contadorVagao = 0;

        for (String segmentoBruto : segmentos) {
            String segmento = segmentoBruto.trim();
            if (!StringUtils.hasText(segmento)) {
                continue;
            }
            String[] partes = segmento.split("\\+");
            String codigo = partes[0].toUpperCase(Locale.ROOT);
            switch (codigo) {
                case "TDT":
                    tratarSegmentoTdt(resultado, partes);
                    break;
                case "NAD":
                    tratarSegmentoNad(resultado, partes);
                    break;
                case "DTM":
                    tratarSegmentoDtm(resultado, partes);
                    break;
                case "EQD":
                    if (ultimoConteiner != null) {
                        adicionarConteiner(resultado, ultimoConteiner, ultimaOperacao);
                    }
                    ultimoConteiner = extrairIdentificador(partes, 2);
                    ultimaOperacao = TipoOperacaoManifesto.DESCARGA;
                    break;
                case "FTX":
                    if (ultimoConteiner != null) {
                        ultimaOperacao = identificarOperacao(segmento, ultimaOperacao);
                    }
                    break;
                case "LOC":
                    if (partes.length > 1 && "147".equals(partes[1])) {
                        contadorVagao++;
                        String identificadorVagao = extrairIdentificador(partes, 2);
                        String tipoVagao = extrairIdentificador(partes, 3);
                        if (StringUtils.hasText(identificadorVagao)) {
                            resultado.adicionarVagao(contadorVagao, identificadorVagao, tipoVagao);
                        }
                    }
                    break;
                default:
                    break;
            }
        }

        if (ultimoConteiner != null) {
            adicionarConteiner(resultado, ultimoConteiner, ultimaOperacao);
        }

        validarObrigatorios(resultado);
        return resultado;
    }

    private void tratarSegmentoTdt(ResultadoManifestoVisita resultado, String[] partes) {
        if (partes.length > 2 && "20".equals(partes[1])) {
            String identificador = extrairIdentificador(partes, 2);
            if (StringUtils.hasText(identificador)) {
                resultado.setIdentificadorTrem(identificador);
            }
        }
    }

    private void tratarSegmentoNad(ResultadoManifestoVisita resultado, String[] partes) {
        if (partes.length > 2) {
            String papel = partes[1].toUpperCase(Locale.ROOT);
            if (("MS".equals(papel) || "CA".equals(papel)) && !StringUtils.hasText(resultado.getOperadoraFerroviaria())) {
                resultado.setOperadoraFerroviaria(extrairIdentificador(partes, 2));
            }
        }
    }

    private void tratarSegmentoDtm(ResultadoManifestoVisita resultado, String[] partes) {
        if (partes.length < 2) {
            return;
        }
        String[] componentes = partes[1].split(":");
        if (componentes.length < 2) {
            return;
        }
        String codigo = componentes[0];
        String valorData = componentes[1];
        LocalDateTime data = interpretarData(valorData);
        if (data == null) {
            return;
        }
        switch (codigo) {
            case "132":
                resultado.setHoraChegadaPrevista(data);
                break;
            case "133":
                resultado.setHoraPartidaPrevista(data);
                break;
            case "137":
                resultado.setStatusVisita(StatusVisitaTrem.PROCESSANDO);
                break;
            default:
                break;
        }
    }

    private void adicionarConteiner(ResultadoManifestoVisita resultado,
                                    String identificador,
                                    TipoOperacaoManifesto operacao) {
        if (!StringUtils.hasText(identificador)) {
            return;
        }
        if (operacao == TipoOperacaoManifesto.CARGA) {
            resultado.adicionarConteinerCarga(identificador);
        } else {
            resultado.adicionarConteinerDescarga(identificador);
        }
    }

    private TipoOperacaoManifesto identificarOperacao(String segmento, TipoOperacaoManifesto atual) {
        String texto = segmento.toUpperCase(Locale.ROOT);
        if (texto.contains("EXP") || texto.contains("LOAD") || texto.contains("EXPORT")) {
            return TipoOperacaoManifesto.CARGA;
        }
        if (texto.contains("IMP") || texto.contains("DIS") || texto.contains("UNLOAD") || texto.contains("IMPORT")) {
            return TipoOperacaoManifesto.DESCARGA;
        }
        return atual;
    }

    private void validarObrigatorios(ResultadoManifestoVisita resultado) {
        if (!StringUtils.hasText(resultado.getIdentificadorTrem())) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo COPARN não informa o identificador do trem.");
        }
        if (!StringUtils.hasText(resultado.getOperadoraFerroviaria())) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo COPARN não informa a operadora ferroviária.");
        }
        if (resultado.getHoraChegadaPrevista() == null) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo COPARN não informa a hora prevista de chegada.");
        }
    }

    private String extrairIdentificador(String[] partes, int indice) {
        if (partes.length <= indice) {
            return null;
        }
        String valor = partes[indice];
        int separador = valor.indexOf(':');
        String semSufixo = separador >= 0 ? valor.substring(0, separador) : valor;
        String limpo = sanitizadorEntrada.limparTexto(semSufixo);
        limpo = ValidacaoEntradaUtil.limparTexto(limpo);
        if (!StringUtils.hasText(limpo)) {
            return null;
        }
        return limpo.trim().toUpperCase(Locale.ROOT);
    }

    private LocalDateTime interpretarData(String valor) {
        String texto = sanitizadorEntrada.limparTexto(valor);
        texto = ValidacaoEntradaUtil.limparTexto(texto);
        if (!StringUtils.hasText(texto)) {
            return null;
        }
        String normalizado = texto.trim();
        try {
            if (normalizado.length() == 12) {
                return LocalDateTime.parse(normalizado, FORMATO_CCYMMDDHHMM);
            }
            if (normalizado.length() == 10) {
                return LocalDateTime.parse(normalizado, FORMATO_CCYMMDDHH);
            }
        } catch (DateTimeParseException ex) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    String.format(Locale.ROOT, "Não foi possível interpretar a data '%s'.", normalizado));
        }
        return null;
    }

    private enum TipoOperacaoManifesto {
        DESCARGA,
        CARGA
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\importacao\CsvManifestoVisitaParser.java ----- 
package br.com.cloudport.servicorail.ferrovia.importacao;

import br.com.cloudport.servicorail.comum.sanitizacao.SanitizadorEntrada;
import br.com.cloudport.servicorail.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ResponseStatusException;

@Component
public class CsvManifestoVisitaParser implements ArquivoManifestoVisitaParser {

    private static final DateTimeFormatter FORMATO_ISO = DateTimeFormatter.ISO_DATE_TIME;
    private static final DateTimeFormatter FORMATO_PADRAO = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

    private final SanitizadorEntrada sanitizadorEntrada;

    public CsvManifestoVisitaParser(SanitizadorEntrada sanitizadorEntrada) {
        this.sanitizadorEntrada = sanitizadorEntrada;
    }

    @Override
    public boolean suporta(String nomeArquivo, byte[] conteudo) {
        if (nomeArquivo != null && nomeArquivo.toLowerCase(Locale.ROOT).endsWith(".csv")) {
            return true;
        }
        if (conteudo == null || conteudo.length == 0) {
            return false;
        }
        String linhaInicial = obterPrimeiraLinha(conteudo);
        return linhaInicial.contains(";") || linhaInicial.contains(",");
    }

    @Override
    public ResultadoManifestoVisita parse(String nomeArquivo, byte[] conteudo) {
        ResultadoManifestoVisita resultado = new ResultadoManifestoVisita();
        List<String> linhas = lerLinhas(conteudo);
        if (linhas.isEmpty()) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo CSV está vazio.");
        }
        String delimitador = linhas.get(0).contains(";") ? ";" : ",";
        Pattern separador = Pattern.compile(Pattern.quote(delimitador));
        int indiceVagao = 0;

        for (String linha : linhas) {
            if (!StringUtils.hasText(linha) || linha.trim().startsWith("#")) {
                continue;
            }
            String[] colunas = separador.split(linha, -1);
            if (colunas.length == 0) {
                continue;
            }
            String tipoRegistro = normalizarTexto(colunas[0]);
            if (!StringUtils.hasText(tipoRegistro)) {
                continue;
            }
            if ("TIPO".equals(tipoRegistro) || "REGISTRO".equals(tipoRegistro)) {
                continue;
            }
            switch (tipoRegistro) {
                case "VISITA":
                    preencherDadosVisita(resultado, colunas);
                    break;
                case "CONTEINER_DESCARGA":
                case "MANIFESTO_DESCARGA":
                    adicionarConteineres(resultado::adicionarConteinerDescarga, colunas);
                    break;
                case "CONTEINER_CARGA":
                case "MANIFESTO_CARGA":
                    adicionarConteineres(resultado::adicionarConteinerCarga, colunas);
                    break;
                case "VAGAO":
                    indiceVagao = adicionarVagao(resultado, colunas, indiceVagao);
                    break;
                default:
                    break;
            }
        }

        validarObrigatorios(resultado);
        return resultado;
    }

    private String obterPrimeiraLinha(byte[] conteudo) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(
                new ByteArrayInputStream(conteudo), StandardCharsets.UTF_8))) {
            String linha = reader.readLine();
            return linha != null ? linha : "";
        } catch (Exception ex) {
            return "";
        }
    }

    private List<String> lerLinhas(byte[] conteudo) {
        List<String> linhas = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(
                new ByteArrayInputStream(conteudo), StandardCharsets.UTF_8))) {
            String linha;
            while ((linha = reader.readLine()) != null) {
                linhas.add(linha.trim());
            }
        } catch (Exception ex) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "Não foi possível ler o arquivo CSV informado.");
        }
        return linhas;
    }

    private void preencherDadosVisita(ResultadoManifestoVisita resultado, String[] colunas) {
        if (colunas.length > 1) {
            resultado.setIdentificadorTrem(normalizarTexto(colunas[1]));
        }
        if (colunas.length > 2) {
            resultado.setOperadoraFerroviaria(normalizarTexto(colunas[2]));
        }
        if (colunas.length > 3) {
            resultado.setHoraChegadaPrevista(converterData(colunas[3]));
        }
        if (colunas.length > 4) {
            resultado.setHoraPartidaPrevista(converterData(colunas[4]));
        }
        if (colunas.length > 5) {
            String statusTexto = normalizarTexto(colunas[5]);
            if (StringUtils.hasText(statusTexto)) {
                try {
                    resultado.setStatusVisita(StatusVisitaTrem.valueOf(statusTexto.toUpperCase(Locale.ROOT)));
                } catch (IllegalArgumentException ex) {
                    resultado.setStatusVisita(StatusVisitaTrem.PLANEJADO);
                }
            }
        }
    }

    private void adicionarConteineres(java.util.function.Consumer<String> consumidor, String[] colunas) {
        for (int i = 1; i < colunas.length; i++) {
            String identificacao = normalizarTexto(colunas[i]);
            if (StringUtils.hasText(identificacao)) {
                consumidor.accept(identificacao);
            }
        }
    }

    private int adicionarVagao(ResultadoManifestoVisita resultado, String[] colunas, int indiceAtual) {
        int proximaPosicao = indiceAtual + 1;
        Integer posicaoInformada = null;
        if (colunas.length > 1) {
            try {
                posicaoInformada = Integer.parseInt(colunas[1].trim());
            } catch (NumberFormatException ex) {
                posicaoInformada = null;
            }
        }
        Integer posicaoFinal = posicaoInformada != null && posicaoInformada > 0 ? posicaoInformada : proximaPosicao;
        String identificador = colunas.length > 2 ? normalizarTexto(colunas[2]) : null;
        String tipo = colunas.length > 3 ? normalizarTexto(colunas[3]) : null;
        if (StringUtils.hasText(identificador)) {
            resultado.adicionarVagao(posicaoFinal, identificador, tipo);
            if (posicaoInformada == null || posicaoInformada <= 0) {
                return posicaoFinal;
            }
        }
        return indiceAtual;
    }

    private void validarObrigatorios(ResultadoManifestoVisita resultado) {
        if (!StringUtils.hasText(resultado.getIdentificadorTrem())) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo CSV não informa o identificador do trem.");
        }
        if (!StringUtils.hasText(resultado.getOperadoraFerroviaria())) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo CSV não informa a operadora ferroviária.");
        }
        if (resultado.getHoraChegadaPrevista() == null) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo CSV não informa a hora prevista de chegada do trem.");
        }
    }

    private LocalDateTime converterData(String valor) {
        String textoLimpo = normalizarTexto(valor);
        if (!StringUtils.hasText(textoLimpo)) {
            return null;
        }
        try {
            return LocalDateTime.parse(textoLimpo, FORMATO_ISO);
        } catch (DateTimeParseException ignored) {
        }
        try {
            return LocalDateTime.parse(textoLimpo, FORMATO_PADRAO);
        } catch (DateTimeParseException ex) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    String.format(Locale.ROOT, "Não foi possível interpretar a data '%s'.", textoLimpo));
        }
    }

    private String normalizarTexto(String valor) {
        String limpo = sanitizadorEntrada.limparTexto(valor);
        limpo = ValidacaoEntradaUtil.limparTexto(limpo);
        if (!StringUtils.hasText(limpo)) {
            return null;
        }
        return limpo.trim();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\importacao\ResultadoManifestoVisita.java ----- 
package br.com.cloudport.servicorail.ferrovia.importacao;

import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ResultadoManifestoVisita {

    private String identificadorTrem;
    private String operadoraFerroviaria;
    private LocalDateTime horaChegadaPrevista;
    private LocalDateTime horaPartidaPrevista;
    private StatusVisitaTrem statusVisita = StatusVisitaTrem.PLANEJADO;
    private final List<String> identificacoesDescarga = new ArrayList<>();
    private final List<String> identificacoesCarga = new ArrayList<>();
    private final List<VagaoManifestoImportado> vagoes = new ArrayList<>();

    public String getIdentificadorTrem() {
        return identificadorTrem;
    }

    public void setIdentificadorTrem(String identificadorTrem) {
        this.identificadorTrem = identificadorTrem;
    }

    public String getOperadoraFerroviaria() {
        return operadoraFerroviaria;
    }

    public void setOperadoraFerroviaria(String operadoraFerroviaria) {
        this.operadoraFerroviaria = operadoraFerroviaria;
    }

    public LocalDateTime getHoraChegadaPrevista() {
        return horaChegadaPrevista;
    }

    public void setHoraChegadaPrevista(LocalDateTime horaChegadaPrevista) {
        this.horaChegadaPrevista = horaChegadaPrevista;
    }

    public LocalDateTime getHoraPartidaPrevista() {
        return horaPartidaPrevista;
    }

    public void setHoraPartidaPrevista(LocalDateTime horaPartidaPrevista) {
        this.horaPartidaPrevista = horaPartidaPrevista;
    }

    public StatusVisitaTrem getStatusVisita() {
        return statusVisita;
    }

    public void setStatusVisita(StatusVisitaTrem statusVisita) {
        this.statusVisita = statusVisita;
    }

    public List<String> getIdentificacoesDescarga() {
        return Collections.unmodifiableList(identificacoesDescarga);
    }

    public void adicionarConteinerDescarga(String identificacao) {
        if (identificacao != null) {
            identificacoesDescarga.add(identificacao);
        }
    }

    public List<String> getIdentificacoesCarga() {
        return Collections.unmodifiableList(identificacoesCarga);
    }

    public void adicionarConteinerCarga(String identificacao) {
        if (identificacao != null) {
            identificacoesCarga.add(identificacao);
        }
    }

    public List<VagaoManifestoImportado> getVagoes() {
        return Collections.unmodifiableList(vagoes);
    }

    public void adicionarVagao(Integer posicaoNoTrem, String identificadorVagao, String tipoVagao) {
        if (posicaoNoTrem != null && identificadorVagao != null) {
            vagoes.add(new VagaoManifestoImportado(posicaoNoTrem, identificadorVagao, tipoVagao));
        }
    }

    public static class VagaoManifestoImportado {
        private final Integer posicaoNoTrem;
        private final String identificadorVagao;
        private final String tipoVagao;

        public VagaoManifestoImportado(Integer posicaoNoTrem, String identificadorVagao, String tipoVagao) {
            this.posicaoNoTrem = posicaoNoTrem;
            this.identificadorVagao = identificadorVagao;
            this.tipoVagao = tipoVagao;
        }

        public Integer getPosicaoNoTrem() {
            return posicaoNoTrem;
        }

        public String getIdentificadorVagao() {
            return identificadorVagao;
        }

        public String getTipoVagao() {
            return tipoVagao;
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\listatrabalho\controlador\ListaTrabalhoTremControlador.java ----- 
package br.com.cloudport.servicorail.ferrovia.listatrabalho.controlador;

import br.com.cloudport.servicorail.ferrovia.listatrabalho.dto.AtualizacaoStatusOrdemMovimentacaoDto;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.dto.OrdemMovimentacaoRespostaDto;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.StatusOrdemMovimentacao;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.servico.OrdemMovimentacaoServico;
import java.util.List;
import javax.validation.Valid;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/rail/ferrovia/lista-trabalho")
public class ListaTrabalhoTremControlador {

    private final OrdemMovimentacaoServico ordemMovimentacaoServico;

    public ListaTrabalhoTremControlador(OrdemMovimentacaoServico ordemMovimentacaoServico) {
        this.ordemMovimentacaoServico = ordemMovimentacaoServico;
    }

    @GetMapping("/visitas/{idVisita}/ordens")
    public List<OrdemMovimentacaoRespostaDto> listarOrdens(@PathVariable("idVisita") Long idVisita,
                                                           @RequestParam(name = "status", required = false)
                                                           StatusOrdemMovimentacao status) {
        return ordemMovimentacaoServico.listarOrdensParaExecucao(idVisita, status);
    }

    @PatchMapping("/visitas/{idVisita}/ordens/{idOrdem}/status")
    public OrdemMovimentacaoRespostaDto atualizarStatus(@PathVariable("idVisita") Long idVisita,
                                                         @PathVariable("idOrdem") Long idOrdem,
                                                         @Valid @RequestBody AtualizacaoStatusOrdemMovimentacaoDto dto) {
        return ordemMovimentacaoServico.atualizarStatus(idVisita, idOrdem, dto.getStatusMovimentacao());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\listatrabalho\dto\AtualizacaoStatusOrdemMovimentacaoDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.listatrabalho.dto;

import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.StatusOrdemMovimentacao;
import javax.validation.constraints.NotNull;

public class AtualizacaoStatusOrdemMovimentacaoDto {

    @NotNull
    private StatusOrdemMovimentacao statusMovimentacao;

    public StatusOrdemMovimentacao getStatusMovimentacao() {
        return statusMovimentacao;
    }

    public void setStatusMovimentacao(StatusOrdemMovimentacao statusMovimentacao) {
        this.statusMovimentacao = statusMovimentacao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\listatrabalho\dto\OrdemMovimentacaoRespostaDto.java ----- 
package br.com.cloudport.servicorail.ferrovia.listatrabalho.dto;

import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.OrdemMovimentacao;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.StatusOrdemMovimentacao;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.TipoMovimentacaoOrdem;
import java.time.LocalDateTime;
import org.springframework.web.util.HtmlUtils;

public class OrdemMovimentacaoRespostaDto {

    private final Long id;
    private final Long idVisitaTrem;
    private final String codigoConteiner;
    private final TipoMovimentacaoOrdem tipoMovimentacao;
    private final StatusOrdemMovimentacao statusMovimentacao;
    private final LocalDateTime criadoEm;
    private final LocalDateTime atualizadoEm;

    public OrdemMovimentacaoRespostaDto(Long id,
                                        Long idVisitaTrem,
                                        String codigoConteiner,
                                        TipoMovimentacaoOrdem tipoMovimentacao,
                                        StatusOrdemMovimentacao statusMovimentacao,
                                        LocalDateTime criadoEm,
                                        LocalDateTime atualizadoEm) {
        this.id = id;
        this.idVisitaTrem = idVisitaTrem;
        this.codigoConteiner = codigoConteiner;
        this.tipoMovimentacao = tipoMovimentacao;
        this.statusMovimentacao = statusMovimentacao;
        this.criadoEm = criadoEm;
        this.atualizadoEm = atualizadoEm;
    }

    public static OrdemMovimentacaoRespostaDto deEntidade(OrdemMovimentacao entidade) {
        return new OrdemMovimentacaoRespostaDto(
                entidade.getId(),
                entidade.getVisitaTrem() != null ? entidade.getVisitaTrem().getId() : null,
                HtmlUtils.htmlEscape(entidade.getCodigoConteiner()),
                entidade.getTipoMovimentacao(),
                entidade.getStatusMovimentacao(),
                entidade.getCriadoEm(),
                entidade.getAtualizadoEm()
        );
    }

    public Long getId() {
        return id;
    }

    public Long getIdVisitaTrem() {
        return idVisitaTrem;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public TipoMovimentacaoOrdem getTipoMovimentacao() {
        return tipoMovimentacao;
    }

    public StatusOrdemMovimentacao getStatusMovimentacao() {
        return statusMovimentacao;
    }

    public LocalDateTime getCriadoEm() {
        return criadoEm;
    }

    public LocalDateTime getAtualizadoEm() {
        return atualizadoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\listatrabalho\modelo\OrdemMovimentacao.java ----- 
package br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo;

import br.com.cloudport.servicorail.ferrovia.modelo.VisitaTrem;
import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

@Entity
@Table(name = "ordem_movimentacao",
        uniqueConstraints = @UniqueConstraint(name = "uk_ordem_visita_conteiner_tipo",
                columnNames = {"visita_trem_id", "codigo_conteiner", "tipo_movimentacao"}))
public class OrdemMovimentacao {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "visita_trem_id", nullable = false)
    private VisitaTrem visitaTrem;

    @Column(name = "codigo_conteiner", nullable = false, length = 20)
    private String codigoConteiner;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_movimentacao", nullable = false, length = 20)
    private TipoMovimentacaoOrdem tipoMovimentacao;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_movimentacao", nullable = false, length = 20)
    private StatusOrdemMovimentacao statusMovimentacao = StatusOrdemMovimentacao.PENDENTE;

    @Column(name = "criado_em", nullable = false)
    private LocalDateTime criadoEm;

    @Column(name = "atualizado_em", nullable = false)
    private LocalDateTime atualizadoEm;

    public OrdemMovimentacao() {
    }

    public OrdemMovimentacao(VisitaTrem visitaTrem,
                             String codigoConteiner,
                             TipoMovimentacaoOrdem tipoMovimentacao,
                             StatusOrdemMovimentacao statusMovimentacao) {
        this.visitaTrem = visitaTrem;
        definirCodigoConteiner(codigoConteiner);
        this.tipoMovimentacao = tipoMovimentacao;
        this.statusMovimentacao = statusMovimentacao;
    }

    @PrePersist
    public void aoCriar() {
        LocalDateTime agora = LocalDateTime.now();
        this.criadoEm = agora;
        this.atualizadoEm = agora;
    }

    @PreUpdate
    public void aoAtualizar() {
        this.atualizadoEm = LocalDateTime.now();
    }

    public Long getId() {
        return id;
    }

    public VisitaTrem getVisitaTrem() {
        return visitaTrem;
    }

    public void setVisitaTrem(VisitaTrem visitaTrem) {
        this.visitaTrem = visitaTrem;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        definirCodigoConteiner(codigoConteiner);
    }

    public TipoMovimentacaoOrdem getTipoMovimentacao() {
        return tipoMovimentacao;
    }

    public void setTipoMovimentacao(TipoMovimentacaoOrdem tipoMovimentacao) {
        this.tipoMovimentacao = tipoMovimentacao;
    }

    public StatusOrdemMovimentacao getStatusMovimentacao() {
        return statusMovimentacao;
    }

    public void setStatusMovimentacao(StatusOrdemMovimentacao statusMovimentacao) {
        this.statusMovimentacao = statusMovimentacao;
    }

    public LocalDateTime getCriadoEm() {
        return criadoEm;
    }

    public LocalDateTime getAtualizadoEm() {
        return atualizadoEm;
    }

    private void definirCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner != null ? codigoConteiner.trim().toUpperCase() : null;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\listatrabalho\modelo\StatusOrdemMovimentacao.java ----- 
package br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo;

public enum StatusOrdemMovimentacao {
    PENDENTE,
    EM_EXECUCAO,
    CONCLUIDA
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\listatrabalho\modelo\TipoMovimentacaoOrdem.java ----- 
package br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo;

public enum TipoMovimentacaoOrdem {
    DESCARGA_TREM,
    CARGA_TREM
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\listatrabalho\repositorio\OrdemMovimentacaoRepositorio.java ----- 
package br.com.cloudport.servicorail.ferrovia.listatrabalho.repositorio;

import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.OrdemMovimentacao;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.StatusOrdemMovimentacao;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.TipoMovimentacaoOrdem;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrdemMovimentacaoRepositorio extends JpaRepository<OrdemMovimentacao, Long> {

    List<OrdemMovimentacao> findByVisitaTremIdAndStatusMovimentacaoInOrderByCriadoEmAsc(Long idVisita,
                                                                                        Collection<StatusOrdemMovimentacao> status);

    List<OrdemMovimentacao> findByVisitaTremId(Long idVisita);

    Optional<OrdemMovimentacao> findByVisitaTremIdAndCodigoConteinerIgnoreCaseAndTipoMovimentacao(Long idVisita,
                                                                                                  String codigoConteiner,
                                                                                                  TipoMovimentacaoOrdem tipoMovimentacao);

    Optional<OrdemMovimentacao> findByIdAndVisitaTremId(Long idOrdem, Long idVisita);

    boolean existsByVisitaTremIdAndCodigoConteinerIgnoreCaseAndTipoMovimentacao(Long idVisita,
                                                                                String codigoConteiner,
                                                                                TipoMovimentacaoOrdem tipoMovimentacao);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\listatrabalho\servico\OrdemMovimentacaoServico.java ----- 
package br.com.cloudport.servicorail.ferrovia.listatrabalho.servico;

import br.com.cloudport.servicorail.ferrovia.dto.EventoMovimentacaoTremConcluidaDto;
import br.com.cloudport.servicorail.ferrovia.evento.PublicadorEventoMovimentacaoTrem;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.dto.OrdemMovimentacaoRespostaDto;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.OrdemMovimentacao;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.StatusOrdemMovimentacao;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.TipoMovimentacaoOrdem;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.repositorio.OrdemMovimentacaoRepositorio;
import br.com.cloudport.servicorail.ferrovia.modelo.OperacaoConteinerVisita;
import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import br.com.cloudport.servicorail.ferrovia.modelo.VisitaTrem;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ResponseStatusException;

@Service
public class OrdemMovimentacaoServico {

    private final OrdemMovimentacaoRepositorio ordemMovimentacaoRepositorio;
    private final PublicadorEventoMovimentacaoTrem publicadorEventoMovimentacaoTrem;

    public OrdemMovimentacaoServico(OrdemMovimentacaoRepositorio ordemMovimentacaoRepositorio,
                                    PublicadorEventoMovimentacaoTrem publicadorEventoMovimentacaoTrem) {
        this.ordemMovimentacaoRepositorio = ordemMovimentacaoRepositorio;
        this.publicadorEventoMovimentacaoTrem = publicadorEventoMovimentacaoTrem;
    }

    @Transactional(readOnly = true)
    public List<OrdemMovimentacaoRespostaDto> listarOrdensParaExecucao(Long idVisita,
                                                                       StatusOrdemMovimentacao statusFiltro) {
        if (idVisita == null || idVisita <= 0) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Identificador da visita inválido.");
        }
        List<StatusOrdemMovimentacao> filtros = statusFiltro != null
                ? List.of(statusFiltro)
                : new ArrayList<>(EnumSet.of(StatusOrdemMovimentacao.PENDENTE, StatusOrdemMovimentacao.EM_EXECUCAO));
        List<OrdemMovimentacao> ordens = ordemMovimentacaoRepositorio
                .findByVisitaTremIdAndStatusMovimentacaoInOrderByCriadoEmAsc(idVisita, filtros);
        return ordens.stream()
                .map(OrdemMovimentacaoRespostaDto::deEntidade)
                .collect(Collectors.toList());
    }

    @Transactional
    public OrdemMovimentacaoRespostaDto atualizarStatus(Long idVisita,
                                                         Long idOrdem,
                                                         StatusOrdemMovimentacao novoStatus) {
        if (idVisita == null || idVisita <= 0 || idOrdem == null || idOrdem <= 0) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Identificador informado é inválido.");
        }
        StatusOrdemMovimentacao statusValidado = Optional.ofNullable(novoStatus)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST,
                        "O status da movimentação deve ser informado."));
        OrdemMovimentacao ordem = ordemMovimentacaoRepositorio.findByIdAndVisitaTremId(idOrdem, idVisita)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Ordem de movimentação não encontrada para a visita informada."));
        StatusOrdemMovimentacao statusAnterior = ordem.getStatusMovimentacao();
        validarTransicaoStatus(ordem.getStatusMovimentacao(), statusValidado);
        ordem.setStatusMovimentacao(statusValidado);
        OrdemMovimentacao atualizada = ordemMovimentacaoRepositorio.save(ordem);
        if (statusValidado == StatusOrdemMovimentacao.CONCLUIDA
                && statusAnterior != StatusOrdemMovimentacao.CONCLUIDA) {
            publicarEventoConclusao(atualizada);
        }
        return OrdemMovimentacaoRespostaDto.deEntidade(atualizada);
    }

    @Transactional
    public void gerarOrdensPendentesParaVisita(VisitaTrem visita) {
        if (visita == null || visita.getId() == null) {
            return;
        }
        if (visita.getStatusVisita() != StatusVisitaTrem.CHEGOU) {
            return;
        }
        List<OperacaoConteinerVisita> descarga = Optional.ofNullable(visita.getListaDescarga())
                .orElseGet(List::of);
        List<OperacaoConteinerVisita> carga = Optional.ofNullable(visita.getListaCarga())
                .orElseGet(List::of);

        Set<ChaveOrdem> chavesExistentes = ordemMovimentacaoRepositorio.findByVisitaTremId(visita.getId())
                .stream()
                .map(ordem -> new ChaveOrdem(ordem.getCodigoConteiner(), ordem.getTipoMovimentacao()))
                .collect(Collectors.toCollection(HashSet::new));

        List<OrdemMovimentacao> novasOrdens = new ArrayList<>();
        adicionarOrdensParaOperacoes(visita, descarga, TipoMovimentacaoOrdem.DESCARGA_TREM, chavesExistentes, novasOrdens);
        adicionarOrdensParaOperacoes(visita, carga, TipoMovimentacaoOrdem.CARGA_TREM, chavesExistentes, novasOrdens);

        if (!novasOrdens.isEmpty()) {
            ordemMovimentacaoRepositorio.saveAll(novasOrdens);
        }
    }

    @Transactional
    public void registrarOrdemParaOperacaoSeNecessario(VisitaTrem visita,
                                                        String codigoConteiner,
                                                        TipoMovimentacaoOrdem tipoMovimentacao) {
        if (visita == null || visita.getId() == null) {
            return;
        }
        if (visita.getStatusVisita() != StatusVisitaTrem.CHEGOU) {
            return;
        }
        if (!StringUtils.hasText(codigoConteiner)) {
            return;
        }
        boolean existe = ordemMovimentacaoRepositorio
                .existsByVisitaTremIdAndCodigoConteinerIgnoreCaseAndTipoMovimentacao(visita.getId(),
                        codigoConteiner, tipoMovimentacao);
        if (!existe) {
            OrdemMovimentacao ordem = new OrdemMovimentacao(visita, codigoConteiner, tipoMovimentacao,
                    StatusOrdemMovimentacao.PENDENTE);
            ordemMovimentacaoRepositorio.save(ordem);
        }
    }

    @Transactional
    public void removerOrdemSeExistir(Long idVisita,
                                      String codigoConteiner,
                                      TipoMovimentacaoOrdem tipoMovimentacao) {
        if (idVisita == null || idVisita <= 0) {
            return;
        }
        if (!StringUtils.hasText(codigoConteiner)) {
            return;
        }
        ordemMovimentacaoRepositorio
                .findByVisitaTremIdAndCodigoConteinerIgnoreCaseAndTipoMovimentacao(idVisita, codigoConteiner,
                        tipoMovimentacao)
                .filter(ordem -> ordem.getStatusMovimentacao() != StatusOrdemMovimentacao.CONCLUIDA)
                .ifPresent(ordemMovimentacaoRepositorio::delete);
    }

    private void adicionarOrdensParaOperacoes(VisitaTrem visita,
                                              List<OperacaoConteinerVisita> operacoes,
                                              TipoMovimentacaoOrdem tipoMovimentacao,
                                              Set<ChaveOrdem> chavesExistentes,
                                              List<OrdemMovimentacao> novasOrdens) {
        if (CollectionUtils.isEmpty(operacoes)) {
            return;
        }
        for (OperacaoConteinerVisita operacao : operacoes) {
            if (operacao == null || !StringUtils.hasText(operacao.getCodigoConteiner())) {
                continue;
            }
            ChaveOrdem chave = new ChaveOrdem(operacao.getCodigoConteiner(), tipoMovimentacao);
            if (chavesExistentes.contains(chave)) {
                continue;
            }
            chavesExistentes.add(chave);
            novasOrdens.add(new OrdemMovimentacao(visita, operacao.getCodigoConteiner(), tipoMovimentacao,
                    StatusOrdemMovimentacao.PENDENTE));
        }
    }

    private void validarTransicaoStatus(StatusOrdemMovimentacao statusAtual,
                                        StatusOrdemMovimentacao novoStatus) {
        if (Objects.equals(statusAtual, novoStatus)) {
            return;
        }
        if (statusAtual == StatusOrdemMovimentacao.PENDENTE
                && (novoStatus == StatusOrdemMovimentacao.EM_EXECUCAO
                || novoStatus == StatusOrdemMovimentacao.CONCLUIDA)) {
            return;
        }
        if (statusAtual == StatusOrdemMovimentacao.EM_EXECUCAO
                && novoStatus == StatusOrdemMovimentacao.CONCLUIDA) {
            return;
        }
        throw new ResponseStatusException(HttpStatus.CONFLICT,
                String.format(Locale.ROOT,
                        "A transição de status de %s para %s não é permitida.",
                        statusAtual, novoStatus));
    }

    private void publicarEventoConclusao(OrdemMovimentacao ordem) {
        if (ordem == null) {
            return;
        }
        EventoMovimentacaoTremConcluidaDto evento = new EventoMovimentacaoTremConcluidaDto(
                ordem.getVisitaTrem() != null ? ordem.getVisitaTrem().getId() : null,
                ordem.getId(),
                ordem.getCodigoConteiner(),
                ordem.getTipoMovimentacao() != null ? ordem.getTipoMovimentacao().name() : null,
                OffsetDateTime.now(ZoneOffset.UTC),
                "MovimentacaoTremConcluidaEvent");
        publicadorEventoMovimentacaoTrem.publicar(evento);
    }

    private static final class ChaveOrdem {
        private final String codigoConteiner;
        private final TipoMovimentacaoOrdem tipoMovimentacao;

        private ChaveOrdem(String codigoConteiner, TipoMovimentacaoOrdem tipoMovimentacao) {
            this.codigoConteiner = codigoConteiner != null ? codigoConteiner.trim().toUpperCase() : null;
            this.tipoMovimentacao = tipoMovimentacao;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
            }
            ChaveOrdem outra = (ChaveOrdem) obj;
            return Objects.equals(codigoConteiner, outra.codigoConteiner)
                    && tipoMovimentacao == outra.tipoMovimentacao;
        }

        @Override
        public int hashCode() {
            return Objects.hash(codigoConteiner, tipoMovimentacao);
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\modelo\OperacaoConteinerVisita.java ----- 
package br.com.cloudport.servicorail.ferrovia.modelo;

import java.util.Objects;
import javax.persistence.Column;
import javax.persistence.Embeddable;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;

@Embeddable
public class OperacaoConteinerVisita {

    @Column(name = "codigo_conteiner", nullable = false, length = 20)
    private String codigoConteiner;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_operacao", nullable = false, length = 20)
    private StatusOperacaoConteinerVisita statusOperacao = StatusOperacaoConteinerVisita.PENDENTE;

    public OperacaoConteinerVisita() {
    }

    public OperacaoConteinerVisita(String codigoConteiner, StatusOperacaoConteinerVisita statusOperacao) {
        this.codigoConteiner = codigoConteiner;
        this.statusOperacao = statusOperacao;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public StatusOperacaoConteinerVisita getStatusOperacao() {
        return statusOperacao;
    }

    public void setStatusOperacao(StatusOperacaoConteinerVisita statusOperacao) {
        this.statusOperacao = statusOperacao;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        OperacaoConteinerVisita that = (OperacaoConteinerVisita) o;
        return Objects.equals(codigoConteiner, that.codigoConteiner)
                && statusOperacao == that.statusOperacao;
    }

    @Override
    public int hashCode() {
        return Objects.hash(codigoConteiner, statusOperacao);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\modelo\StatusOperacaoConteinerVisita.java ----- 
package br.com.cloudport.servicorail.ferrovia.modelo;

public enum StatusOperacaoConteinerVisita {
    PENDENTE,
    CONCLUIDO
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\modelo\StatusVisitaTrem.java ----- 
package br.com.cloudport.servicorail.ferrovia.modelo;

public enum StatusVisitaTrem {
    PLANEJADO,
    CHEGOU,
    PROCESSANDO,
    PARTIU
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\modelo\VagaoVisita.java ----- 
package br.com.cloudport.servicorail.ferrovia.modelo;

import java.util.Objects;
import javax.persistence.Column;
import javax.persistence.Embeddable;

@Embeddable
public class VagaoVisita {

    @Column(name = "posicao_no_trem", nullable = false)
    private Integer posicaoNoTrem;

    @Column(name = "identificador_vagao", nullable = false, length = 35)
    private String identificadorVagao;

    @Column(name = "tipo_vagao", length = 40)
    private String tipoVagao;

    public VagaoVisita() {
    }

    public VagaoVisita(Integer posicaoNoTrem, String identificadorVagao, String tipoVagao) {
        this.posicaoNoTrem = posicaoNoTrem;
        this.identificadorVagao = identificadorVagao;
        this.tipoVagao = tipoVagao;
    }

    public Integer getPosicaoNoTrem() {
        return posicaoNoTrem;
    }

    public void setPosicaoNoTrem(Integer posicaoNoTrem) {
        this.posicaoNoTrem = posicaoNoTrem;
    }

    public String getIdentificadorVagao() {
        return identificadorVagao;
    }

    public void setIdentificadorVagao(String identificadorVagao) {
        this.identificadorVagao = identificadorVagao;
    }

    public String getTipoVagao() {
        return tipoVagao;
    }

    public void setTipoVagao(String tipoVagao) {
        this.tipoVagao = tipoVagao;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        VagaoVisita that = (VagaoVisita) o;
        return Objects.equals(posicaoNoTrem, that.posicaoNoTrem)
                && Objects.equals(identificadorVagao, that.identificadorVagao)
                && Objects.equals(tipoVagao, that.tipoVagao);
    }

    @Override
    public int hashCode() {
        return Objects.hash(posicaoNoTrem, identificadorVagao, tipoVagao);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\modelo\VisitaTrem.java ----- 
package br.com.cloudport.servicorail.ferrovia.modelo;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OrderColumn;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Table;

@Entity
@Table(name = "visita_trem")
public class VisitaTrem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "identificador_trem", nullable = false, length = 40)
    private String identificadorTrem;

    @Column(name = "operadora_ferroviaria", nullable = false, length = 80)
    private String operadoraFerroviaria;

    @Column(name = "hora_chegada_prevista", nullable = false)
    private LocalDateTime horaChegadaPrevista;

    @Column(name = "hora_partida_prevista", nullable = false)
    private LocalDateTime horaPartidaPrevista;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_visita", nullable = false, length = 20)
    private StatusVisitaTrem statusVisita;

    @Column(name = "criado_em", nullable = false)
    private LocalDateTime criadoEm;

    @Column(name = "atualizado_em", nullable = false)
    private LocalDateTime atualizadoEm;

    @ElementCollection
    @CollectionTable(name = "visita_trem_descarga", joinColumns = @JoinColumn(name = "visita_trem_id"))
    @OrderColumn(name = "ordem_manifesto_descarga")
    private List<OperacaoConteinerVisita> listaDescarga = new ArrayList<>();

    @ElementCollection
    @CollectionTable(name = "visita_trem_carga", joinColumns = @JoinColumn(name = "visita_trem_id"))
    @OrderColumn(name = "ordem_manifesto_carga")
    private List<OperacaoConteinerVisita> listaCarga = new ArrayList<>();

    @ElementCollection
    @CollectionTable(name = "visita_trem_vagao", joinColumns = @JoinColumn(name = "visita_trem_id"))
    @OrderColumn(name = "ordem_vagao")
    private List<VagaoVisita> listaVagoes = new ArrayList<>();

    public VisitaTrem() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getIdentificadorTrem() {
        return identificadorTrem;
    }

    public void setIdentificadorTrem(String identificadorTrem) {
        this.identificadorTrem = identificadorTrem;
    }

    public String getOperadoraFerroviaria() {
        return operadoraFerroviaria;
    }

    public void setOperadoraFerroviaria(String operadoraFerroviaria) {
        this.operadoraFerroviaria = operadoraFerroviaria;
    }

    public LocalDateTime getHoraChegadaPrevista() {
        return horaChegadaPrevista;
    }

    public void setHoraChegadaPrevista(LocalDateTime horaChegadaPrevista) {
        this.horaChegadaPrevista = horaChegadaPrevista;
    }

    public LocalDateTime getHoraPartidaPrevista() {
        return horaPartidaPrevista;
    }

    public void setHoraPartidaPrevista(LocalDateTime horaPartidaPrevista) {
        this.horaPartidaPrevista = horaPartidaPrevista;
    }

    public StatusVisitaTrem getStatusVisita() {
        return statusVisita;
    }

    public void setStatusVisita(StatusVisitaTrem statusVisita) {
        this.statusVisita = statusVisita;
    }

    public LocalDateTime getCriadoEm() {
        return criadoEm;
    }

    public void setCriadoEm(LocalDateTime criadoEm) {
        this.criadoEm = criadoEm;
    }

    public LocalDateTime getAtualizadoEm() {
        return atualizadoEm;
    }

    public void setAtualizadoEm(LocalDateTime atualizadoEm) {
        this.atualizadoEm = atualizadoEm;
    }

    public List<OperacaoConteinerVisita> getListaDescarga() {
        return listaDescarga;
    }

    public void definirListaDescarga(List<OperacaoConteinerVisita> listaDescarga) {
        this.listaDescarga.clear();
        if (listaDescarga != null) {
            this.listaDescarga.addAll(listaDescarga);
        }
    }

    public List<OperacaoConteinerVisita> getListaCarga() {
        return listaCarga;
    }

    public void definirListaCarga(List<OperacaoConteinerVisita> listaCarga) {
        this.listaCarga.clear();
        if (listaCarga != null) {
            this.listaCarga.addAll(listaCarga);
        }
    }

    public List<VagaoVisita> getListaVagoes() {
        return listaVagoes;
    }

    public void definirListaVagoes(List<VagaoVisita> listaVagoes) {
        this.listaVagoes.clear();
        if (listaVagoes != null) {
            this.listaVagoes.addAll(listaVagoes);
        }
    }

    @PrePersist
    public void aoCriar() {
        LocalDateTime agora = LocalDateTime.now();
        this.criadoEm = agora;
        this.atualizadoEm = agora;
    }

    @PreUpdate
    public void aoAtualizar() {
        this.atualizadoEm = LocalDateTime.now();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\repositorio\VisitaTremRepositorio.java ----- 
package br.com.cloudport.servicorail.ferrovia.repositorio;

import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import br.com.cloudport.servicorail.ferrovia.modelo.VisitaTrem;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface VisitaTremRepositorio extends JpaRepository<VisitaTrem, Long> {

    @Query("SELECT v FROM VisitaTrem v "
            + "WHERE (v.horaChegadaPrevista BETWEEN :inicio AND :limite) "
            + "OR ((v.statusVisita <> :statusFinalizado) "
            + "AND (v.horaPartidaPrevista IS NULL OR v.horaPartidaPrevista >= :referenciaAtiva) "
            + "AND v.horaChegadaPrevista <= :limite) "
            + "ORDER BY v.horaChegadaPrevista ASC, v.id ASC")
    List<VisitaTrem> buscarVisitasPlanejadasOuAtivas(@Param("inicio") LocalDateTime inicio,
                                                     @Param("referenciaAtiva") LocalDateTime referenciaAtiva,
                                                     @Param("limite") LocalDateTime limite,
                                                     @Param("statusFinalizado") StatusVisitaTrem statusFinalizado);

    @Query("SELECT DISTINCT v FROM VisitaTrem v "
            + "LEFT JOIN FETCH v.listaDescarga "
            + "LEFT JOIN FETCH v.listaCarga "
            + "LEFT JOIN FETCH v.listaVagoes "
            + "WHERE v.id = :id")
    Optional<VisitaTrem> buscarPorIdComListas(@Param("id") Long id);

    Optional<VisitaTrem> findByIdentificadorTremIgnoreCase(String identificadorTrem);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\servico\ImportacaoManifestoVisitaServico.java ----- 
package br.com.cloudport.servicorail.ferrovia.servico;

import br.com.cloudport.servicorail.comum.sanitizacao.SanitizadorEntrada;
import br.com.cloudport.servicorail.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicorail.ferrovia.dto.OperacaoConteinerVisitaRequisicaoDto;
import br.com.cloudport.servicorail.ferrovia.dto.VagaoVisitaRequisicaoDto;
import br.com.cloudport.servicorail.ferrovia.dto.VisitaTremRequisicaoDto;
import br.com.cloudport.servicorail.ferrovia.dto.VisitaTremRespostaDto;
import br.com.cloudport.servicorail.ferrovia.importacao.ArquivoManifestoVisitaParser;
import br.com.cloudport.servicorail.ferrovia.importacao.ResultadoManifestoVisita;
import br.com.cloudport.servicorail.ferrovia.importacao.ResultadoManifestoVisita.VagaoManifestoImportado;
import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.server.ResponseStatusException;

@Service
public class ImportacaoManifestoVisitaServico {

    private final List<ArquivoManifestoVisitaParser> parsers;
    private final VisitaTremServico visitaTremServico;
    private final SanitizadorEntrada sanitizadorEntrada;

    public ImportacaoManifestoVisitaServico(List<ArquivoManifestoVisitaParser> parsers,
                                            VisitaTremServico visitaTremServico,
                                            SanitizadorEntrada sanitizadorEntrada) {
        this.parsers = parsers;
        this.visitaTremServico = visitaTremServico;
        this.sanitizadorEntrada = sanitizadorEntrada;
    }

    public VisitaTremRespostaDto importarManifesto(MultipartFile arquivo) {
        if (arquivo == null || arquivo.isEmpty()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "Nenhum arquivo foi enviado para importação.");
        }
        byte[] conteudo;
        try {
            conteudo = arquivo.getBytes();
        } catch (IOException ex) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "Não foi possível ler o arquivo enviado.");
        }
        String nomeArquivo = StringUtils.hasText(arquivo.getOriginalFilename())
                ? StringUtils.cleanPath(Objects.requireNonNull(arquivo.getOriginalFilename()))
                : "arquivo-manifesto";

        ArquivoManifestoVisitaParser parser = parsers.stream()
                .filter(item -> item.suporta(nomeArquivo, conteudo))
                .findFirst()
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.UNSUPPORTED_MEDIA_TYPE,
                        "Formato de arquivo não suportado para importação."));

        ResultadoManifestoVisita resultado = parser.parse(nomeArquivo, conteudo);
        ajustarCamposPadrao(resultado);
        VisitaTremRequisicaoDto dto = converterResultadoParaDto(resultado);
        return visitaTremServico.salvarOuAtualizarPorIdentificador(dto, true);
    }

    private void ajustarCamposPadrao(ResultadoManifestoVisita resultado) {
        if (resultado.getStatusVisita() == null) {
            resultado.setStatusVisita(StatusVisitaTrem.PLANEJADO);
        }
        if (resultado.getHoraPartidaPrevista() == null && resultado.getHoraChegadaPrevista() != null) {
            resultado.setHoraPartidaPrevista(resultado.getHoraChegadaPrevista().plusHours(4));
        }
    }

    private VisitaTremRequisicaoDto converterResultadoParaDto(ResultadoManifestoVisita resultado) {
        VisitaTremRequisicaoDto dto = new VisitaTremRequisicaoDto();
        dto.setIdentificadorTrem(resultado.getIdentificadorTrem());
        dto.setOperadoraFerroviaria(resultado.getOperadoraFerroviaria());
        dto.setHoraChegadaPrevista(resultado.getHoraChegadaPrevista());
        dto.setHoraPartidaPrevista(resultado.getHoraPartidaPrevista());
        dto.setStatusVisita(Optional.ofNullable(resultado.getStatusVisita()).orElse(StatusVisitaTrem.PLANEJADO));
        dto.setListaDescarga(converterConteineres(resultado.getIdentificacoesDescarga()));
        dto.setListaCarga(converterConteineres(resultado.getIdentificacoesCarga()));
        dto.setListaVagoes(converterVagoes(resultado.getVagoes()));
        return dto;
    }

    private List<OperacaoConteinerVisitaRequisicaoDto> converterConteineres(List<String> identificacoes) {
        if (identificacoes == null || identificacoes.isEmpty()) {
            return new ArrayList<>();
        }
        Set<String> codigosNormalizados = new LinkedHashSet<>();
        for (String identificacao : identificacoes) {
            String normalizado = normalizarIdentificacao(identificacao);
            if (StringUtils.hasText(normalizado)) {
                codigosNormalizados.add(normalizado);
            }
        }
        return codigosNormalizados.stream()
                .map(codigo -> {
                    OperacaoConteinerVisitaRequisicaoDto dto = new OperacaoConteinerVisitaRequisicaoDto();
                    dto.setCodigoConteiner(codigo);
                    return dto;
                })
                .collect(Collectors.toList());
    }

    private List<VagaoVisitaRequisicaoDto> converterVagoes(List<VagaoManifestoImportado> vagoes) {
        if (vagoes == null || vagoes.isEmpty()) {
            return new ArrayList<>();
        }
        List<VagaoVisitaRequisicaoDto> lista = new ArrayList<>();
        int posicaoSequencial = 0;
        for (VagaoManifestoImportado vagao : vagoes) {
            if (vagao == null) {
                continue;
            }
            if (!StringUtils.hasText(vagao.getIdentificadorVagao())) {
                continue;
            }
            VagaoVisitaRequisicaoDto dto = new VagaoVisitaRequisicaoDto();
            Integer posicaoInformada = Optional.ofNullable(vagao.getPosicaoNoTrem()).orElse(null);
            if (posicaoInformada == null || posicaoInformada <= 0) {
                posicaoSequencial++;
                dto.setPosicaoNoTrem(posicaoSequencial);
            } else {
                dto.setPosicaoNoTrem(posicaoInformada);
                posicaoSequencial = Math.max(posicaoSequencial, posicaoInformada);
            }
            dto.setIdentificadorVagao(vagao.getIdentificadorVagao());
            dto.setTipoVagao(vagao.getTipoVagao());
            lista.add(dto);
        }
        return lista;
    }

    private String normalizarIdentificacao(String valor) {
        String limpo = sanitizadorEntrada.limparTexto(valor);
        try {
            limpo = ValidacaoEntradaUtil.limparTexto(limpo);
        } catch (IllegalArgumentException ex) {
            throw new ResponseStatusException(HttpStatus.UNPROCESSABLE_ENTITY,
                    "O arquivo de manifesto contém identificações de contêiner com caracteres inválidos.");
        }
        if (!StringUtils.hasText(limpo)) {
            return null;
        }
        String normalizado = limpo.trim().toUpperCase(Locale.ROOT);
        if (normalizado.length() > 20) {
            return normalizado.substring(0, 20);
        }
        return normalizado;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\java\br\com\cloudport\servicorail\ferrovia\servico\VisitaTremServico.java ----- 
package br.com.cloudport.servicorail.ferrovia.servico;

import br.com.cloudport.servicorail.comum.sanitizacao.SanitizadorEntrada;
import br.com.cloudport.servicorail.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicorail.ferrovia.dto.OperacaoConteinerVisitaRequisicaoDto;
import br.com.cloudport.servicorail.ferrovia.dto.VagaoVisitaRequisicaoDto;
import br.com.cloudport.servicorail.ferrovia.dto.VisitaTremRequisicaoDto;
import br.com.cloudport.servicorail.ferrovia.dto.VisitaTremRespostaDto;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.modelo.TipoMovimentacaoOrdem;
import br.com.cloudport.servicorail.ferrovia.listatrabalho.servico.OrdemMovimentacaoServico;
import br.com.cloudport.servicorail.ferrovia.modelo.OperacaoConteinerVisita;
import br.com.cloudport.servicorail.ferrovia.modelo.StatusOperacaoConteinerVisita;
import br.com.cloudport.servicorail.ferrovia.modelo.StatusVisitaTrem;
import br.com.cloudport.servicorail.ferrovia.modelo.VagaoVisita;
import br.com.cloudport.servicorail.ferrovia.modelo.VisitaTrem;
import br.com.cloudport.servicorail.ferrovia.repositorio.VisitaTremRepositorio;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ResponseStatusException;

@Service
public class VisitaTremServico {

    private static final int DIAS_MAXIMO_CONSULTA = 30;

    private final VisitaTremRepositorio visitaTremRepositorio;
    private final SanitizadorEntrada sanitizadorEntrada;
    private final OrdemMovimentacaoServico ordemMovimentacaoServico;

    public VisitaTremServico(VisitaTremRepositorio visitaTremRepositorio,
                              SanitizadorEntrada sanitizadorEntrada,
                              OrdemMovimentacaoServico ordemMovimentacaoServico) {
        this.visitaTremRepositorio = visitaTremRepositorio;
        this.sanitizadorEntrada = sanitizadorEntrada;
        this.ordemMovimentacaoServico = ordemMovimentacaoServico;
    }

    @Transactional
    public VisitaTremRespostaDto registrarVisita(VisitaTremRequisicaoDto dto) {
        DadosVisitaSanitizados dados = sanitizarDadosBasicos(dto);
        VisitaTrem visita = new VisitaTrem();
        boolean statusAlteradoParaChegou = aplicarDados(visita, dados, dto, true);
        VisitaTrem salvo = visitaTremRepositorio.save(visita);
        if (deveGerarOrdens(statusAlteradoParaChegou, true, salvo)) {
            ordemMovimentacaoServico.gerarOrdensPendentesParaVisita(salvo);
        }
        return VisitaTremRespostaDto.deEntidade(salvo);
    }

    @Transactional
    public VisitaTremRespostaDto atualizarVisita(Long id, VisitaTremRequisicaoDto dto) {
        VisitaTrem existente = buscarVisitaComListas(id);
        DadosVisitaSanitizados dados = sanitizarDadosBasicos(dto);
        boolean statusAlteradoParaChegou = aplicarDados(existente, dados, dto, true);
        VisitaTrem atualizado = visitaTremRepositorio.save(existente);
        if (deveGerarOrdens(statusAlteradoParaChegou, true, atualizado)) {
            ordemMovimentacaoServico.gerarOrdensPendentesParaVisita(atualizado);
        }
        return VisitaTremRespostaDto.deEntidade(atualizado);
    }

    @Transactional
    public VisitaTremRespostaDto salvarOuAtualizarPorIdentificador(VisitaTremRequisicaoDto dto,
                                                                   boolean substituirListas) {
        DadosVisitaSanitizados dados = sanitizarDadosBasicos(dto);
        Optional<VisitaTrem> existente = visitaTremRepositorio
                .findByIdentificadorTremIgnoreCase(dados.identificadorTrem);
        VisitaTrem visita = existente
                .map(valor -> buscarVisitaComListas(valor.getId()))
                .orElseGet(VisitaTrem::new);
        boolean statusAlteradoParaChegou = aplicarDados(visita, dados, dto, substituirListas);
        VisitaTrem salvo = visitaTremRepositorio.save(visita);
        if (deveGerarOrdens(statusAlteradoParaChegou, substituirListas, salvo)) {
            ordemMovimentacaoServico.gerarOrdensPendentesParaVisita(salvo);
        }
        return VisitaTremRespostaDto.deEntidade(salvo);
    }

    @Transactional(readOnly = true)
    public VisitaTremRespostaDto consultarVisita(Long id) {
        VisitaTrem visita = buscarVisitaComListas(id);
        return VisitaTremRespostaDto.deEntidade(visita);
    }

    @Transactional(readOnly = true)
    public List<VisitaTremRespostaDto> listarVisitasProximosDias(int dias) {
        if (dias < 1 || dias > DIAS_MAXIMO_CONSULTA) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format(Locale.ROOT, "O intervalo de consulta deve estar entre 1 e %d dias.", DIAS_MAXIMO_CONSULTA));
        }
        LocalDateTime agora = LocalDateTime.now();
        LocalDateTime inicio = agora.minusDays(1);
        LocalDateTime limite = agora.plusDays(dias);
        return visitaTremRepositorio.buscarVisitasPlanejadasOuAtivas(inicio, agora, limite, StatusVisitaTrem.PARTIU)
                .stream()
                .distinct()
                .map(VisitaTremRespostaDto::deEntidadeSemListas)
                .collect(Collectors.toList());
    }

    @Transactional
    public VisitaTremRespostaDto adicionarConteinerDescarga(Long idVisita, OperacaoConteinerVisitaRequisicaoDto dto) {
        return adicionarOperacaoConteiner(idVisita, dto, TipoListaOperacaoVisita.DESCARGA);
    }

    @Transactional
    public VisitaTremRespostaDto adicionarConteinerCarga(Long idVisita, OperacaoConteinerVisitaRequisicaoDto dto) {
        return adicionarOperacaoConteiner(idVisita, dto, TipoListaOperacaoVisita.CARGA);
    }

    @Transactional
    public VisitaTremRespostaDto removerConteinerDescarga(Long idVisita, String codigoConteiner) {
        return removerOperacaoConteiner(idVisita, codigoConteiner, TipoListaOperacaoVisita.DESCARGA);
    }

    @Transactional
    public VisitaTremRespostaDto removerConteinerCarga(Long idVisita, String codigoConteiner) {
        return removerOperacaoConteiner(idVisita, codigoConteiner, TipoListaOperacaoVisita.CARGA);
    }

    @Transactional
    public VisitaTremRespostaDto atualizarStatusDescarga(Long idVisita,
                                                         String codigoConteiner,
                                                         StatusOperacaoConteinerVisita status) {
        return atualizarStatusOperacaoConteiner(idVisita, codigoConteiner, status, TipoListaOperacaoVisita.DESCARGA);
    }

    @Transactional
    public VisitaTremRespostaDto atualizarStatusCarga(Long idVisita,
                                                      String codigoConteiner,
                                                      StatusOperacaoConteinerVisita status) {
        return atualizarStatusOperacaoConteiner(idVisita, codigoConteiner, status, TipoListaOperacaoVisita.CARGA);
    }

    private DadosVisitaSanitizados sanitizarDadosBasicos(VisitaTremRequisicaoDto dto) {
        String identificadorLimpo = sanitizarObrigatorio(dto.getIdentificadorTrem(), "identificador do trem", 40)
                .toUpperCase(Locale.ROOT);
        String operadoraLimpa = sanitizarObrigatorio(dto.getOperadoraFerroviaria(), "operadora ferroviária", 80);

        LocalDateTime horaChegada = Objects.requireNonNull(dto.getHoraChegadaPrevista(),
                "A hora prevista de chegada deve ser informada.");
        LocalDateTime horaPartida = Objects.requireNonNull(dto.getHoraPartidaPrevista(),
                "A hora prevista de partida deve ser informada.");

        if (horaPartida.isBefore(horaChegada)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "A partida prevista não pode ser anterior à chegada prevista.");
        }

        horaChegada = horaChegada.truncatedTo(ChronoUnit.MINUTES);
        horaPartida = horaPartida.truncatedTo(ChronoUnit.MINUTES);

        StatusVisitaTrem status = Objects.requireNonNull(dto.getStatusVisita(),
                "O status da visita deve ser informado.");

        return new DadosVisitaSanitizados(identificadorLimpo, operadoraLimpa, horaChegada, horaPartida, status);
    }

    private boolean aplicarDados(VisitaTrem visita,
                                 DadosVisitaSanitizados dados,
                                 VisitaTremRequisicaoDto dto,
                                 boolean substituirListas) {
        StatusVisitaTrem statusAnterior = visita.getStatusVisita();
        visita.setIdentificadorTrem(dados.identificadorTrem);
        visita.setOperadoraFerroviaria(dados.operadoraFerroviaria);
        visita.setHoraChegadaPrevista(dados.horaChegadaPrevista);
        visita.setHoraPartidaPrevista(dados.horaPartidaPrevista);
        visita.setStatusVisita(dados.statusVisita);

        if (substituirListas) {
            List<OperacaoConteinerVisita> listaDescarga = converterListaOperacoes(dto.getListaDescarga());
            List<OperacaoConteinerVisita> listaCarga = converterListaOperacoes(dto.getListaCarga());
            validarListasOperacoes(listaDescarga, listaCarga);
            visita.definirListaDescarga(listaDescarga);
            visita.definirListaCarga(listaCarga);
            List<VagaoVisita> listaVagoes = converterListaVagoes(dto.getListaVagoes());
            visita.definirListaVagoes(listaVagoes);
        }
        return statusAnterior != StatusVisitaTrem.CHEGOU && dados.statusVisita == StatusVisitaTrem.CHEGOU;
    }

    private boolean deveGerarOrdens(boolean statusAlteradoParaChegou,
                                    boolean substituirListas,
                                    VisitaTrem visita) {
        return visita != null
                && visita.getStatusVisita() == StatusVisitaTrem.CHEGOU
                && (statusAlteradoParaChegou || substituirListas);
    }

    private String sanitizarObrigatorio(String valor, String campo, int tamanhoMaximo) {
        String limpo = sanitizadorEntrada.limparTexto(valor);
        try {
            limpo = ValidacaoEntradaUtil.limparTexto(limpo);
        } catch (IllegalArgumentException ex) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format(Locale.ROOT, "O campo %s contém caracteres inválidos.", campo));
        }
        if (!StringUtils.hasText(limpo)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format(Locale.ROOT, "O campo %s é obrigatório.", campo));
        }
        String normalizado = limpo.trim();
        if (normalizado.length() > tamanhoMaximo) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format(Locale.ROOT, "O campo %s deve ter no máximo %d caracteres.", campo, tamanhoMaximo));
        }
        return normalizado;
    }

    private String sanitizarOpcional(String valor, String campo, int tamanhoMaximo) {
        String limpo = sanitizadorEntrada.limparTexto(valor);
        try {
            limpo = ValidacaoEntradaUtil.limparTexto(limpo);
        } catch (IllegalArgumentException ex) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format(Locale.ROOT, "O campo %s contém caracteres inválidos.", campo));
        }
        if (!StringUtils.hasText(limpo)) {
            return null;
        }
        String normalizado = limpo.trim();
        if (normalizado.length() > tamanhoMaximo) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format(Locale.ROOT, "O campo %s deve ter no máximo %d caracteres.", campo, tamanhoMaximo));
        }
        return normalizado;
    }

    private VisitaTrem buscarVisitaComListas(Long id) {
        return visitaTremRepositorio.buscarPorIdComListas(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Visita de trem não encontrada."));
    }

    private List<OperacaoConteinerVisita> converterListaOperacoes(List<OperacaoConteinerVisitaRequisicaoDto> dtos) {
        if (dtos == null || dtos.isEmpty()) {
            return new ArrayList<>();
        }
        return dtos.stream()
                .filter(Objects::nonNull)
                .map(this::converterParaOperacao)
                .collect(Collectors.toCollection(ArrayList::new));
    }

    private void validarListasOperacoes(List<OperacaoConteinerVisita> listaDescarga,
                                        List<OperacaoConteinerVisita> listaCarga) {
        Set<String> codigosDescarga = new HashSet<>();
        for (OperacaoConteinerVisita item : listaDescarga) {
            if (!codigosDescarga.add(item.getCodigoConteiner())) {
                throw new ResponseStatusException(HttpStatus.CONFLICT,
                        String.format(Locale.ROOT,
                                "O contêiner %s está duplicado na lista de descarga.", item.getCodigoConteiner()));
            }
        }

        Set<String> codigosCarga = new HashSet<>();
        for (OperacaoConteinerVisita item : listaCarga) {
            if (!codigosCarga.add(item.getCodigoConteiner())) {
                throw new ResponseStatusException(HttpStatus.CONFLICT,
                        String.format(Locale.ROOT,
                                "O contêiner %s está duplicado na lista de carga.", item.getCodigoConteiner()));
            }
        }

        Set<String> codigosEmAmbasListas = new HashSet<>(codigosDescarga);
        codigosEmAmbasListas.retainAll(codigosCarga);
        if (!codigosEmAmbasListas.isEmpty()) {
            String codigoConflitante = codigosEmAmbasListas.iterator().next();
            throw new ResponseStatusException(HttpStatus.CONFLICT,
                    String.format(Locale.ROOT,
                            "O contêiner %s não pode estar nas listas de carga e descarga simultaneamente.", codigoConflitante));
        }
    }

    private List<VagaoVisita> converterListaVagoes(List<VagaoVisitaRequisicaoDto> dtos) {
        if (dtos == null || dtos.isEmpty()) {
            return new ArrayList<>();
        }
        List<VagaoVisita> vagoes = new ArrayList<>();
        Set<Integer> posicoesUtilizadas = new HashSet<>();
        Set<String> identificadoresUtilizados = new HashSet<>();
        for (VagaoVisitaRequisicaoDto dto : dtos) {
            if (dto == null) {
                continue;
            }
            Integer posicao = Optional.ofNullable(dto.getPosicaoNoTrem())
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST,
                            "A posição do vagão deve ser informada."));
            if (posicao <= 0) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                        "A posição do vagão deve ser um número positivo.");
            }
            if (!posicoesUtilizadas.add(posicao)) {
                throw new ResponseStatusException(HttpStatus.CONFLICT,
                        "Já existe um vagão cadastrado para a posição informada.");
            }
            String identificador = sanitizarObrigatorio(dto.getIdentificadorVagao(),
                    "identificador do vagão", 35).toUpperCase(Locale.ROOT);
            if (!identificadoresUtilizados.add(identificador)) {
                throw new ResponseStatusException(HttpStatus.CONFLICT,
                        "O identificador de vagão informado está duplicado.");
            }
            String tipo = sanitizarOpcional(dto.getTipoVagao(), "tipo do vagão", 40);
            vagoes.add(new VagaoVisita(posicao, identificador, tipo));
        }
        vagoes.sort((a, b) -> Integer.compare(a.getPosicaoNoTrem(), b.getPosicaoNoTrem()));
        return vagoes;
    }

    private VisitaTremRespostaDto adicionarOperacaoConteiner(Long idVisita,
                                                             OperacaoConteinerVisitaRequisicaoDto dto,
                                                             TipoListaOperacaoVisita tipoLista) {
        VisitaTrem visita = buscarVisitaComListas(idVisita);
        OperacaoConteinerVisita novaOperacao = converterParaOperacao(dto);

        List<OperacaoConteinerVisita> listaAlvo = obterListaPorTipo(visita, tipoLista);
        boolean jaExiste = listaAlvo.stream()
                .anyMatch(item -> item.getCodigoConteiner().equals(novaOperacao.getCodigoConteiner()));
        if (jaExiste) {
            throw new ResponseStatusException(HttpStatus.CONFLICT,
                    "O contêiner informado já está planejado para esta visita.");
        }

        List<OperacaoConteinerVisita> listaOposta = obterListaPorTipo(visita, tipoLista.inverso());
        boolean emListaOposta = listaOposta.stream()
                .anyMatch(item -> item.getCodigoConteiner().equals(novaOperacao.getCodigoConteiner()));
        if (emListaOposta) {
            throw new ResponseStatusException(HttpStatus.CONFLICT,
                    "O contêiner informado já está associado à outra lista desta visita.");
        }

        listaAlvo.add(novaOperacao);
        VisitaTrem atualizado = visitaTremRepositorio.save(visita);
        ordemMovimentacaoServico.registrarOrdemParaOperacaoSeNecessario(atualizado,
                novaOperacao.getCodigoConteiner(),
                converterTipoMovimentacao(tipoLista));
        return VisitaTremRespostaDto.deEntidade(atualizado);
    }

    private VisitaTremRespostaDto removerOperacaoConteiner(Long idVisita,
                                                           String codigoConteiner,
                                                           TipoListaOperacaoVisita tipoLista) {
        VisitaTrem visita = buscarVisitaComListas(idVisita);
        String codigoValidado = sanitizarCodigoConteiner(codigoConteiner);
        List<OperacaoConteinerVisita> listaAlvo = obterListaPorTipo(visita, tipoLista);
        boolean removido = listaAlvo.removeIf(item -> codigoValidado.equals(item.getCodigoConteiner()));
        if (!removido) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    "O contêiner informado não está relacionado a esta visita.");
        }
        VisitaTrem atualizado = visitaTremRepositorio.save(visita);
        ordemMovimentacaoServico.removerOrdemSeExistir(atualizado.getId(),
                codigoValidado,
                converterTipoMovimentacao(tipoLista));
        return VisitaTremRespostaDto.deEntidade(atualizado);
    }

    private VisitaTremRespostaDto atualizarStatusOperacaoConteiner(Long idVisita,
                                                                   String codigoConteiner,
                                                                   StatusOperacaoConteinerVisita status,
                                                                   TipoListaOperacaoVisita tipoLista) {
        VisitaTrem visita = buscarVisitaComListas(idVisita);
        String codigoValidado = sanitizarCodigoConteiner(codigoConteiner);
        StatusOperacaoConteinerVisita statusValidado = Optional.ofNullable(status)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST,
                        "O status da operação deve ser informado."));
        List<OperacaoConteinerVisita> listaAlvo = obterListaPorTipo(visita, tipoLista);
        OperacaoConteinerVisita operacao = listaAlvo.stream()
                .filter(item -> codigoValidado.equals(item.getCodigoConteiner()))
                .findFirst()
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "O contêiner informado não está relacionado a esta visita."));
        operacao.setStatusOperacao(statusValidado);
        visitaTremRepositorio.save(visita);
        return VisitaTremRespostaDto.deEntidade(visita);
    }

    private List<OperacaoConteinerVisita> obterListaPorTipo(VisitaTrem visita, TipoListaOperacaoVisita tipoLista) {
        if (tipoLista == TipoListaOperacaoVisita.DESCARGA) {
            return visita.getListaDescarga();
        }
        return visita.getListaCarga();
    }

    private TipoMovimentacaoOrdem converterTipoMovimentacao(TipoListaOperacaoVisita tipoLista) {
        return tipoLista == TipoListaOperacaoVisita.DESCARGA
                ? TipoMovimentacaoOrdem.DESCARGA_TREM
                : TipoMovimentacaoOrdem.CARGA_TREM;
    }

    private OperacaoConteinerVisita converterParaOperacao(OperacaoConteinerVisitaRequisicaoDto dto) {
        String codigo = sanitizarCodigoConteiner(dto.getCodigoConteiner());
        StatusOperacaoConteinerVisita status = Optional.ofNullable(dto.getStatusOperacao())
                .orElse(StatusOperacaoConteinerVisita.PENDENTE);
        return new OperacaoConteinerVisita(codigo, status);
    }

    private String sanitizarCodigoConteiner(String codigoConteiner) {
        String limpo = sanitizadorEntrada.limparTexto(codigoConteiner);
        try {
            limpo = ValidacaoEntradaUtil.limparTexto(limpo);
        } catch (IllegalArgumentException ex) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "O código do contêiner contém caracteres inválidos.");
        }
        if (!StringUtils.hasText(limpo)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "O código do contêiner deve ser informado.");
        }
        String normalizado = limpo.trim().toUpperCase(Locale.ROOT);
        if (normalizado.length() > 20) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "O código do contêiner deve ter no máximo 20 caracteres.");
        }
        return normalizado;
    }

    private enum TipoListaOperacaoVisita {
        DESCARGA,
        CARGA;

        TipoListaOperacaoVisita inverso() {
            return this == DESCARGA ? CARGA : DESCARGA;
        }
    }

    private static final class DadosVisitaSanitizados {
        private final String identificadorTrem;
        private final String operadoraFerroviaria;
        private final LocalDateTime horaChegadaPrevista;
        private final LocalDateTime horaPartidaPrevista;
        private final StatusVisitaTrem statusVisita;

        private DadosVisitaSanitizados(String identificadorTrem,
                                       String operadoraFerroviaria,
                                       LocalDateTime horaChegadaPrevista,
                                       LocalDateTime horaPartidaPrevista,
                                       StatusVisitaTrem statusVisita) {
            this.identificadorTrem = identificadorTrem;
            this.operadoraFerroviaria = operadoraFerroviaria;
            this.horaChegadaPrevista = horaChegadaPrevista;
            this.horaPartidaPrevista = horaPartidaPrevista;
            this.statusVisita = statusVisita;
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\resources\application.properties ----- 
server.port=${RAIL_SERVER_PORT:8083}

spring.application.name=servico-rail

spring.datasource.url=${RAIL_DB_URL:jdbc:postgresql://localhost:5432/servico_rail}
spring.datasource.username=${RAIL_DB_USERNAME:postgres}
spring.datasource.password=${RAIL_DB_PASSWORD:postgres}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=none
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.jpa.properties.hibernate.default_schema=${RAIL_FLYWAY_SCHEMA:cloudport_rail}

spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.default-schema=${RAIL_FLYWAY_SCHEMA:cloudport_rail}
spring.flyway.schemas=${RAIL_FLYWAY_SCHEMA:cloudport_rail}

spring.rabbitmq.host=${RAIL_RABBIT_HOST:localhost}
spring.rabbitmq.port=${RAIL_RABBIT_PORT:5672}
spring.rabbitmq.username=${RAIL_RABBIT_USERNAME:guest}
spring.rabbitmq.password=${RAIL_RABBIT_PASSWORD:guest}

cloudport.rail.eventos.exchange=${RAIL_EVENTOS_EXCHANGE:ferrovia.eventos}
cloudport.rail.eventos.routing-movimentacao=${RAIL_EVENTOS_ROUTING_MOVIMENTACAO:rail.movimentacao.concluida}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\resources\db\migration\V1__criar_tabela_visita_trem.sql ----- 
CREATE TABLE IF NOT EXISTS visita_trem (
    id BIGSERIAL PRIMARY KEY,
    identificador_trem VARCHAR(40) NOT NULL,
    operadora_ferroviaria VARCHAR(80) NOT NULL,
    hora_chegada_prevista TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    hora_partida_prevista TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    status_visita VARCHAR(20) NOT NULL,
    criado_em TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    atualizado_em TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_visita_trem_identificador ON visita_trem (identificador_trem);
CREATE INDEX IF NOT EXISTS idx_visita_trem_janela ON visita_trem (hora_chegada_prevista, hora_partida_prevista);
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\resources\db\migration\V2__criar_listas_manifesto_conteiner.sql ----- 
CREATE TABLE visita_trem_descarga (
    visita_trem_id BIGINT NOT NULL,
    codigo_conteiner VARCHAR(20) NOT NULL,
    status_operacao VARCHAR(20) NOT NULL,
    ordem_manifesto_descarga INTEGER NOT NULL,
    CONSTRAINT fk_descarga_visita FOREIGN KEY (visita_trem_id)
        REFERENCES visita_trem (id) ON DELETE CASCADE
);

CREATE TABLE visita_trem_carga (
    visita_trem_id BIGINT NOT NULL,
    codigo_conteiner VARCHAR(20) NOT NULL,
    status_operacao VARCHAR(20) NOT NULL,
    ordem_manifesto_carga INTEGER NOT NULL,
    CONSTRAINT fk_carga_visita FOREIGN KEY (visita_trem_id)
        REFERENCES visita_trem (id) ON DELETE CASCADE
);

CREATE UNIQUE INDEX uk_visita_trem_descarga_codigo
    ON visita_trem_descarga (visita_trem_id, codigo_conteiner);

CREATE UNIQUE INDEX uk_visita_trem_carga_codigo
    ON visita_trem_carga (visita_trem_id, codigo_conteiner);
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-rail\src\main\resources\db\migration\V3__criar_tabela_vagao_visita.sql ----- 
CREATE TABLE visita_trem_vagao (
    visita_trem_id BIGINT NOT NULL,
    posicao_no_trem INTEGER NOT NULL,
    identificador_vagao VARCHAR(35) NOT NULL,
    tipo_vagao VARCHAR(40),
    ordem_vagao INTEGER NOT NULL,
    CONSTRAINT fk_vagao_visita FOREIGN KEY (visita_trem_id)
        REFERENCES visita_trem (id) ON DELETE CASCADE
);

CREATE UNIQUE INDEX uk_visita_trem_vagao_identificador
    ON visita_trem_vagao (visita_trem_id, identificador_vagao);
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\pom.xml ----- 
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>br.com.cloudport</groupId>
    <artifactId>servico-yard</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>servico-yard</name>
    <description>Serviço de gestão de pátio</description>
    <properties>
        <java.version>11</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.jsoup</groupId>
            <artifactId>jsoup</artifactId>
            <version>1.17.2</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\.mvn\wrapper\maven-wrapper.properties ----- 
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.3/apache-maven-3.9.3-bin.zip
wrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\ServicoYardApplication.java ----- 
package br.com.cloudport.servicoyard;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServicoYardApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServicoYardApplication.class, args);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\comum\validacao\ValidacaoEntradaUtil.java ----- 
package br.com.cloudport.servicoyard.comum.validacao;

import java.util.List;
import java.util.Objects;
import java.util.regex.Pattern;

public final class ValidacaoEntradaUtil {

    private static final Pattern PADRAO_TEXTO_SEGURO = Pattern.compile("^[\\p{L}0-9\\s\\-_/.:]*$");

    private ValidacaoEntradaUtil() {
    }

    public static String limparTexto(String valor) {
        if (valor == null) {
            return null;
        }
        String ajustado = valor.trim();
        validarConteudo(ajustado);
        return ajustado;
    }

    public static List<String> limparLista(List<String> valores) {
        if (valores == null) {
            return List.of();
        }
        return valores.stream()
                .filter(Objects::nonNull)
                .map(String::trim)
                .filter(valor -> !valor.isEmpty())
                .peek(ValidacaoEntradaUtil::validarConteudo)
                .distinct()
                .collect(java.util.stream.Collectors.toList());
    }

    private static void validarConteudo(String valor) {
        if (valor.isEmpty()) {
            return;
        }
        if (valor.contains("<") || valor.contains(">")) {
            throw new IllegalArgumentException("Valor contém caracteres não permitidos.");
        }
        if (!PADRAO_TEXTO_SEGURO.matcher(valor).matches()) {
            throw new IllegalArgumentException("Valor contém caracteres inválidos.");
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\configuracao\IntegracaoFerroviaRabbitConfiguracao.java ----- 
package br.com.cloudport.servicoyard.configuracao;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class IntegracaoFerroviaRabbitConfiguracao {

    @Bean
    public TopicExchange exchangeMovimentacaoFerrovia(
            @Value("${cloudport.yard.integracoes.ferrovia.exchange}") String exchange) {
        return new TopicExchange(exchange, true, false);
    }

    @Bean
    public Queue filaMovimentacaoFerrovia(
            @Value("${cloudport.yard.integracoes.ferrovia.queue}") String queue) {
        return new Queue(queue, true);
    }

    @Bean
    public Binding bindingMovimentacaoFerrovia(Queue filaMovimentacaoFerrovia,
                                               TopicExchange exchangeMovimentacaoFerrovia,
                                               @Value("${cloudport.yard.integracoes.ferrovia.routing}") String routingKey) {
        return BindingBuilder.bind(filaMovimentacaoFerrovia)
                .to(exchangeMovimentacaoFerrovia)
                .with(routingKey);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\configuracao\RabbitConfiguracao.java ----- 
package br.com.cloudport.servicoyard.configuracao;

import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfiguracao {

    @Bean
    public MessageConverter conversorMensagemJson() {
        return new Jackson2JsonMessageConverter();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\configuracao\WebSocketConfiguracao.java ----- 
package br.com.cloudport.servicoyard.configuracao;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfiguracao implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/topico");
        registry.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws/patio")
                .setAllowedOriginPatterns("*");
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\controlador\ConteinerControlador.java ----- 
package br.com.cloudport.servicoyard.container.controlador;

import br.com.cloudport.servicoyard.container.dto.AtualizacaoConteinerDTO;
import br.com.cloudport.servicoyard.container.dto.ConteinerDetalheDTO;
import br.com.cloudport.servicoyard.container.dto.ConteinerResumoDTO;
import br.com.cloudport.servicoyard.container.dto.HistoricoOperacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroAlocacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroInspecaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroLiberacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroTransferenciaDTO;
import br.com.cloudport.servicoyard.container.servico.ConteinerServico;
import org.springframework.http.HttpStatus;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/yard/conteineres")
@Validated
public class ConteinerControlador {
    private final ConteinerServico conteinerServico;

    public ConteinerControlador(ConteinerServico conteinerServico) {
        this.conteinerServico = conteinerServico;
    }

    @GetMapping
    public List<ConteinerResumoDTO> listar() {
        return conteinerServico.listarResumo();
    }

    @GetMapping("/{identificador}")
    public ConteinerDetalheDTO detalhar(@PathVariable Long identificador) {
        return conteinerServico.buscarDetalhe(identificador);
    }

    @GetMapping("/por-codigo")
    public ConteinerDetalheDTO detalharPorCodigo(@RequestParam("codigo") String codigo) {
        return conteinerServico.buscarDetalhePorCodigo(codigo);
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ConteinerDetalheDTO registrar(@Valid @RequestBody RegistroAlocacaoDTO dto) {
        return conteinerServico.registrarAlocacao(dto);
    }

    @PutMapping("/{identificador}")
    public ConteinerDetalheDTO atualizar(@PathVariable Long identificador,
                                         @Valid @RequestBody AtualizacaoConteinerDTO dto) {
        return conteinerServico.atualizarCadastro(identificador, dto);
    }

    @PostMapping("/{identificador}/transferencias")
    public ConteinerDetalheDTO transferir(@PathVariable Long identificador,
                                          @Valid @RequestBody RegistroTransferenciaDTO dto) {
        return conteinerServico.registrarTransferencia(identificador, dto);
    }

    @PostMapping("/{identificador}/inspecoes")
    public ConteinerDetalheDTO inspecionar(@PathVariable Long identificador,
                                           @Valid @RequestBody RegistroInspecaoDTO dto) {
        return conteinerServico.registrarInspecao(identificador, dto);
    }

    @PostMapping("/{identificador}/liberacoes")
    public ConteinerDetalheDTO liberar(@PathVariable Long identificador,
                                       @Valid @RequestBody RegistroLiberacaoDTO dto) {
        return conteinerServico.registrarLiberacao(identificador, dto);
    }

    @GetMapping("/{identificador}/historico")
    public List<HistoricoOperacaoDTO> historico(@PathVariable Long identificador) {
        return conteinerServico.consultarHistorico(identificador);
    }

    @GetMapping("/por-codigo/historico")
    public List<HistoricoOperacaoDTO> historicoPorCodigo(@RequestParam("codigo") String codigo) {
        return conteinerServico.consultarHistoricoPorCodigo(codigo);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\AtualizacaoConteinerDTO.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import br.com.cloudport.servicoyard.container.entidade.TipoCargaConteiner;

import javax.validation.constraints.DecimalMax;
import javax.validation.constraints.DecimalMin;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.math.BigDecimal;

public class AtualizacaoConteinerDTO {
    @NotBlank(message = "Posição no pátio obrigatória")
    @Size(max = 60, message = "Posição no pátio deve ter até 60 caracteres")
    private String posicaoPatio;

    @NotNull(message = "Tipo de carga obrigatório")
    private TipoCargaConteiner tipoCarga;

    @NotNull(message = "Peso obrigatório")
    @DecimalMin(value = "0.1", message = "Peso mínimo de 0.1 tonelada")
    @DecimalMax(value = "120.0", message = "Peso máximo de 120 toneladas")
    private BigDecimal pesoToneladas;

    @Size(max = 255, message = "Restrições devem ter até 255 caracteres")
    private String restricoes;

    public AtualizacaoConteinerDTO() {
    }

    public String getPosicaoPatio() {
        return posicaoPatio;
    }

    public void setPosicaoPatio(String posicaoPatio) {
        this.posicaoPatio = posicaoPatio;
    }

    public TipoCargaConteiner getTipoCarga() {
        return tipoCarga;
    }

    public void setTipoCarga(TipoCargaConteiner tipoCarga) {
        this.tipoCarga = tipoCarga;
    }

    public BigDecimal getPesoToneladas() {
        return pesoToneladas;
    }

    public void setPesoToneladas(BigDecimal pesoToneladas) {
        this.pesoToneladas = pesoToneladas;
    }

    public String getRestricoes() {
        return restricoes;
    }

    public void setRestricoes(String restricoes) {
        this.restricoes = restricoes;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\ConteinerDetalheDTO.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import br.com.cloudport.servicoyard.container.entidade.StatusOperacionalConteiner;
import br.com.cloudport.servicoyard.container.entidade.TipoCargaConteiner;

import java.math.BigDecimal;
import java.time.OffsetDateTime;

public class ConteinerDetalheDTO {
    private Long identificador;
    private String identificacao;
    private String posicaoPatio;
    private TipoCargaConteiner tipoCarga;
    private BigDecimal pesoToneladas;
    private String restricoes;
    private StatusOperacionalConteiner statusOperacional;
    private OffsetDateTime ultimaAtualizacao;

    public ConteinerDetalheDTO(Long identificador, String identificacao, String posicaoPatio,
                               TipoCargaConteiner tipoCarga, BigDecimal pesoToneladas,
                               String restricoes, StatusOperacionalConteiner statusOperacional,
                               OffsetDateTime ultimaAtualizacao) {
        this.identificador = identificador;
        this.identificacao = identificacao;
        this.posicaoPatio = posicaoPatio;
        this.tipoCarga = tipoCarga;
        this.pesoToneladas = pesoToneladas;
        this.restricoes = restricoes;
        this.statusOperacional = statusOperacional;
        this.ultimaAtualizacao = ultimaAtualizacao;
    }

    public Long getIdentificador() {
        return identificador;
    }

    public String getIdentificacao() {
        return identificacao;
    }

    public String getPosicaoPatio() {
        return posicaoPatio;
    }

    public TipoCargaConteiner getTipoCarga() {
        return tipoCarga;
    }

    public BigDecimal getPesoToneladas() {
        return pesoToneladas;
    }

    public String getRestricoes() {
        return restricoes;
    }

    public StatusOperacionalConteiner getStatusOperacional() {
        return statusOperacional;
    }

    public OffsetDateTime getUltimaAtualizacao() {
        return ultimaAtualizacao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\ConteinerResumoDTO.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import br.com.cloudport.servicoyard.container.entidade.StatusOperacionalConteiner;

public class ConteinerResumoDTO {
    private Long identificador;
    private String identificacao;
    private String posicaoPatio;
    private StatusOperacionalConteiner statusOperacional;

    public ConteinerResumoDTO(Long identificador, String identificacao, String posicaoPatio,
                              StatusOperacionalConteiner statusOperacional) {
        this.identificador = identificador;
        this.identificacao = identificacao;
        this.posicaoPatio = posicaoPatio;
        this.statusOperacional = statusOperacional;
    }

    public Long getIdentificador() {
        return identificador;
    }

    public String getIdentificacao() {
        return identificacao;
    }

    public String getPosicaoPatio() {
        return posicaoPatio;
    }

    public StatusOperacionalConteiner getStatusOperacional() {
        return statusOperacional;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\HistoricoOperacaoDTO.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import br.com.cloudport.servicoyard.container.entidade.TipoOperacaoConteiner;

import java.time.OffsetDateTime;

public class HistoricoOperacaoDTO {
    private TipoOperacaoConteiner tipoOperacao;
    private String descricao;
    private String posicaoAnterior;
    private String posicaoAtual;
    private String responsavel;
    private OffsetDateTime dataRegistro;

    public HistoricoOperacaoDTO(TipoOperacaoConteiner tipoOperacao, String descricao,
                                String posicaoAnterior, String posicaoAtual,
                                String responsavel, OffsetDateTime dataRegistro) {
        this.tipoOperacao = tipoOperacao;
        this.descricao = descricao;
        this.posicaoAnterior = posicaoAnterior;
        this.posicaoAtual = posicaoAtual;
        this.responsavel = responsavel;
        this.dataRegistro = dataRegistro;
    }

    public TipoOperacaoConteiner getTipoOperacao() {
        return tipoOperacao;
    }

    public String getDescricao() {
        return descricao;
    }

    public String getPosicaoAnterior() {
        return posicaoAnterior;
    }

    public String getPosicaoAtual() {
        return posicaoAtual;
    }

    public String getResponsavel() {
        return responsavel;
    }

    public OffsetDateTime getDataRegistro() {
        return dataRegistro;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\MovimentacaoTremConcluidaEventoDto.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import java.time.OffsetDateTime;

public class MovimentacaoTremConcluidaEventoDto {

    private Long idVisitaTrem;
    private Long idOrdemMovimentacao;
    private String codigoConteiner;
    private String tipoMovimentacao;
    private OffsetDateTime concluidoEm;
    private String statusEvento;

    public MovimentacaoTremConcluidaEventoDto() {
    }

    public Long getIdVisitaTrem() {
        return idVisitaTrem;
    }

    public void setIdVisitaTrem(Long idVisitaTrem) {
        this.idVisitaTrem = idVisitaTrem;
    }

    public Long getIdOrdemMovimentacao() {
        return idOrdemMovimentacao;
    }

    public void setIdOrdemMovimentacao(Long idOrdemMovimentacao) {
        this.idOrdemMovimentacao = idOrdemMovimentacao;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public String getTipoMovimentacao() {
        return tipoMovimentacao;
    }

    public void setTipoMovimentacao(String tipoMovimentacao) {
        this.tipoMovimentacao = tipoMovimentacao;
    }

    public OffsetDateTime getConcluidoEm() {
        return concluidoEm;
    }

    public void setConcluidoEm(OffsetDateTime concluidoEm) {
        this.concluidoEm = concluidoEm;
    }

    public String getStatusEvento() {
        return statusEvento;
    }

    public void setStatusEvento(String statusEvento) {
        this.statusEvento = statusEvento;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\RegistroAlocacaoDTO.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import br.com.cloudport.servicoyard.container.entidade.TipoCargaConteiner;

import javax.validation.constraints.DecimalMax;
import javax.validation.constraints.DecimalMin;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.math.BigDecimal;

public class RegistroAlocacaoDTO {
    @NotBlank(message = "Identificação obrigatória")
    @Size(max = 20, message = "Identificação deve ter até 20 caracteres")
    private String identificacao;

    @NotBlank(message = "Posição no pátio obrigatória")
    @Size(max = 60, message = "Posição no pátio deve ter até 60 caracteres")
    private String posicaoPatio;

    @NotNull(message = "Tipo de carga obrigatório")
    private TipoCargaConteiner tipoCarga;

    @NotNull(message = "Peso obrigatório")
    @DecimalMin(value = "0.1", message = "Peso mínimo de 0.1 tonelada")
    @DecimalMax(value = "120.0", message = "Peso máximo de 120 toneladas")
    private BigDecimal pesoToneladas;

    @Size(max = 255, message = "Restrições devem ter até 255 caracteres")
    private String restricoes;

    public RegistroAlocacaoDTO() {
    }

    public String getIdentificacao() {
        return identificacao;
    }

    public void setIdentificacao(String identificacao) {
        this.identificacao = identificacao;
    }

    public String getPosicaoPatio() {
        return posicaoPatio;
    }

    public void setPosicaoPatio(String posicaoPatio) {
        this.posicaoPatio = posicaoPatio;
    }

    public TipoCargaConteiner getTipoCarga() {
        return tipoCarga;
    }

    public void setTipoCarga(TipoCargaConteiner tipoCarga) {
        this.tipoCarga = tipoCarga;
    }

    public BigDecimal getPesoToneladas() {
        return pesoToneladas;
    }

    public void setPesoToneladas(BigDecimal pesoToneladas) {
        this.pesoToneladas = pesoToneladas;
    }

    public String getRestricoes() {
        return restricoes;
    }

    public void setRestricoes(String restricoes) {
        this.restricoes = restricoes;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\RegistroInspecaoDTO.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public class RegistroInspecaoDTO {
    @NotBlank(message = "Resultado da inspeção obrigatório")
    @Size(max = 120, message = "Resultado deve ter até 120 caracteres")
    private String resultado;

    @Size(max = 255, message = "Observações devem ter até 255 caracteres")
    private String observacoes;

    @NotBlank(message = "Responsável obrigatório")
    @Size(max = 80, message = "Responsável deve ter até 80 caracteres")
    private String responsavel;

    public RegistroInspecaoDTO() {
    }

    public String getResultado() {
        return resultado;
    }

    public void setResultado(String resultado) {
        this.resultado = resultado;
    }

    public String getObservacoes() {
        return observacoes;
    }

    public void setObservacoes(String observacoes) {
        this.observacoes = observacoes;
    }

    public String getResponsavel() {
        return responsavel;
    }

    public void setResponsavel(String responsavel) {
        this.responsavel = responsavel;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\RegistroLiberacaoDTO.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public class RegistroLiberacaoDTO {
    @NotBlank(message = "Destino final obrigatório")
    @Size(max = 120, message = "Destino final deve ter até 120 caracteres")
    private String destinoFinal;

    @Size(max = 255, message = "Observações devem ter até 255 caracteres")
    private String observacoes;

    @NotBlank(message = "Responsável obrigatório")
    @Size(max = 80, message = "Responsável deve ter até 80 caracteres")
    private String responsavel;

    public RegistroLiberacaoDTO() {
    }

    public String getDestinoFinal() {
        return destinoFinal;
    }

    public void setDestinoFinal(String destinoFinal) {
        this.destinoFinal = destinoFinal;
    }

    public String getObservacoes() {
        return observacoes;
    }

    public void setObservacoes(String observacoes) {
        this.observacoes = observacoes;
    }

    public String getResponsavel() {
        return responsavel;
    }

    public void setResponsavel(String responsavel) {
        this.responsavel = responsavel;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\dto\RegistroTransferenciaDTO.java ----- 
package br.com.cloudport.servicoyard.container.dto;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public class RegistroTransferenciaDTO {
    @NotBlank(message = "Posição de destino obrigatória")
    @Size(max = 60, message = "Posição de destino deve ter até 60 caracteres")
    private String posicaoDestino;

    @NotBlank(message = "Motivo obrigatório")
    @Size(max = 120, message = "Motivo deve ter até 120 caracteres")
    private String motivo;

    @NotBlank(message = "Responsável obrigatório")
    @Size(max = 80, message = "Responsável deve ter até 80 caracteres")
    private String responsavel;

    public RegistroTransferenciaDTO() {
    }

    public String getPosicaoDestino() {
        return posicaoDestino;
    }

    public void setPosicaoDestino(String posicaoDestino) {
        this.posicaoDestino = posicaoDestino;
    }

    public String getMotivo() {
        return motivo;
    }

    public void setMotivo(String motivo) {
        this.motivo = motivo;
    }

    public String getResponsavel() {
        return responsavel;
    }

    public void setResponsavel(String responsavel) {
        this.responsavel = responsavel;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\entidade\Conteiner.java ----- 
package br.com.cloudport.servicoyard.container.entidade;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Table;
import javax.persistence.Version;
import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;

@Entity
@Table(name = "conteiner")
public class Conteiner {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "identificacao", nullable = false, length = 20, unique = true)
    private String identificacao;

    @Column(name = "posicao_patio", nullable = false, length = 60)
    private String posicaoPatio;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_carga", nullable = false, length = 40)
    private TipoCargaConteiner tipoCarga;

    @Column(name = "peso_toneladas", nullable = false, precision = 10, scale = 3)
    private BigDecimal pesoToneladas;

    @Column(name = "restricoes", length = 255)
    private String restricoes;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_operacional", nullable = false, length = 30)
    private StatusOperacionalConteiner statusOperacional;

    @Column(name = "ultima_atualizacao", nullable = false)
    private OffsetDateTime ultimaAtualizacao;

    @Version
    private Long versao;

    @PrePersist
    @PreUpdate
    public void atualizarUltimaAtualizacao() {
        ultimaAtualizacao = OffsetDateTime.now(ZoneOffset.UTC);
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getIdentificacao() {
        return identificacao;
    }

    public void setIdentificacao(String identificacao) {
        this.identificacao = identificacao;
    }

    public String getPosicaoPatio() {
        return posicaoPatio;
    }

    public void setPosicaoPatio(String posicaoPatio) {
        this.posicaoPatio = posicaoPatio;
    }

    public TipoCargaConteiner getTipoCarga() {
        return tipoCarga;
    }

    public void setTipoCarga(TipoCargaConteiner tipoCarga) {
        this.tipoCarga = tipoCarga;
    }

    public BigDecimal getPesoToneladas() {
        return pesoToneladas;
    }

    public void setPesoToneladas(BigDecimal pesoToneladas) {
        this.pesoToneladas = pesoToneladas;
    }

    public String getRestricoes() {
        return restricoes;
    }

    public void setRestricoes(String restricoes) {
        this.restricoes = restricoes;
    }

    public StatusOperacionalConteiner getStatusOperacional() {
        return statusOperacional;
    }

    public void setStatusOperacional(StatusOperacionalConteiner statusOperacional) {
        this.statusOperacional = statusOperacional;
    }

    public OffsetDateTime getUltimaAtualizacao() {
        return ultimaAtualizacao;
    }

    public Long getVersao() {
        return versao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\entidade\HistoricoOperacaoConteiner.java ----- 
package br.com.cloudport.servicoyard.container.entidade;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import java.time.OffsetDateTime;

@Entity
@Table(name = "historico_operacao_conteiner")
public class HistoricoOperacaoConteiner {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "conteiner_id", nullable = false)
    private Conteiner conteiner;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_operacao", nullable = false, length = 40)
    private TipoOperacaoConteiner tipoOperacao;

    @Column(name = "descricao", nullable = false, length = 255)
    private String descricao;

    @Column(name = "posicao_anterior", length = 60)
    private String posicaoAnterior;

    @Column(name = "posicao_atual", length = 60)
    private String posicaoAtual;

    @Column(name = "responsavel", length = 80)
    private String responsavel;

    @Column(name = "data_registro", nullable = false)
    private OffsetDateTime dataRegistro;

    public Long getId() {
        return id;
    }

    public Conteiner getConteiner() {
        return conteiner;
    }

    public void setConteiner(Conteiner conteiner) {
        this.conteiner = conteiner;
    }

    public TipoOperacaoConteiner getTipoOperacao() {
        return tipoOperacao;
    }

    public void setTipoOperacao(TipoOperacaoConteiner tipoOperacao) {
        this.tipoOperacao = tipoOperacao;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public String getPosicaoAnterior() {
        return posicaoAnterior;
    }

    public void setPosicaoAnterior(String posicaoAnterior) {
        this.posicaoAnterior = posicaoAnterior;
    }

    public String getPosicaoAtual() {
        return posicaoAtual;
    }

    public void setPosicaoAtual(String posicaoAtual) {
        this.posicaoAtual = posicaoAtual;
    }

    public String getResponsavel() {
        return responsavel;
    }

    public void setResponsavel(String responsavel) {
        this.responsavel = responsavel;
    }

    public OffsetDateTime getDataRegistro() {
        return dataRegistro;
    }

    public void setDataRegistro(OffsetDateTime dataRegistro) {
        this.dataRegistro = dataRegistro;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\entidade\StatusOperacionalConteiner.java ----- 
package br.com.cloudport.servicoyard.container.entidade;

public enum StatusOperacionalConteiner {
    ALOCADO,
    EM_TRANSFERENCIA,
    INSPECIONADO,
    LIBERADO
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\entidade\TipoCargaConteiner.java ----- 
package br.com.cloudport.servicoyard.container.entidade;

public enum TipoCargaConteiner {
    SECO,
    REFRIGERADO,
    PERIGOSO,
    GRANELEIRO,
    OUTRO
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\entidade\TipoOperacaoConteiner.java ----- 
package br.com.cloudport.servicoyard.container.entidade;

public enum TipoOperacaoConteiner {
    ALOCACAO,
    TRANSFERENCIA,
    INSPECAO,
    LIBERACAO,
    ATUALIZACAO_CADASTRAL,
    DESCARGA_TREM,
    CARGA_TREM
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\repositorio\ConteinerRepositorio.java ----- 
package br.com.cloudport.servicoyard.container.repositorio;

import br.com.cloudport.servicoyard.container.entidade.Conteiner;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ConteinerRepositorio extends JpaRepository<Conteiner, Long> {
    Optional<Conteiner> findByIdentificacaoIgnoreCase(String identificacao);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\repositorio\HistoricoOperacaoConteinerRepositorio.java ----- 
package br.com.cloudport.servicoyard.container.repositorio;

import br.com.cloudport.servicoyard.container.entidade.HistoricoOperacaoConteiner;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface HistoricoOperacaoConteinerRepositorio extends JpaRepository<HistoricoOperacaoConteiner, Long> {
    List<HistoricoOperacaoConteiner> findByConteinerIdOrderByDataRegistroDesc(Long conteinerId);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\servico\ConteinerServico.java ----- 
package br.com.cloudport.servicoyard.container.servico;

import br.com.cloudport.servicoyard.container.dto.AtualizacaoConteinerDTO;
import br.com.cloudport.servicoyard.container.dto.ConteinerDetalheDTO;
import br.com.cloudport.servicoyard.container.dto.ConteinerResumoDTO;
import br.com.cloudport.servicoyard.container.dto.HistoricoOperacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroAlocacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroInspecaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroLiberacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroTransferenciaDTO;
import br.com.cloudport.servicoyard.container.entidade.Conteiner;
import br.com.cloudport.servicoyard.container.entidade.HistoricoOperacaoConteiner;
import br.com.cloudport.servicoyard.container.entidade.StatusOperacionalConteiner;
import br.com.cloudport.servicoyard.container.entidade.TipoCargaConteiner;
import br.com.cloudport.servicoyard.container.entidade.TipoOperacaoConteiner;
import br.com.cloudport.servicoyard.container.repositorio.ConteinerRepositorio;
import br.com.cloudport.servicoyard.container.repositorio.HistoricoOperacaoConteinerRepositorio;
import br.com.cloudport.servicoyard.container.validacao.SanitizadorEntrada;
import java.util.Locale;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ResponseStatusException;

import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ConteinerServico {
    private final ConteinerRepositorio conteinerRepositorio;
    private final HistoricoOperacaoConteinerRepositorio historicoRepositorio;
    private final SanitizadorEntrada sanitizadorEntrada;

    public ConteinerServico(ConteinerRepositorio conteinerRepositorio,
                            HistoricoOperacaoConteinerRepositorio historicoRepositorio,
                            SanitizadorEntrada sanitizadorEntrada) {
        this.conteinerRepositorio = conteinerRepositorio;
        this.historicoRepositorio = historicoRepositorio;
        this.sanitizadorEntrada = sanitizadorEntrada;
    }

    @Transactional(readOnly = true)
    public List<ConteinerResumoDTO> listarResumo() {
        return conteinerRepositorio.findAll(Sort.by(Sort.Direction.ASC, "identificacao")).stream()
                .map(conteiner -> new ConteinerResumoDTO(
                        conteiner.getId(),
                        conteiner.getIdentificacao(),
                        conteiner.getPosicaoPatio(),
                        conteiner.getStatusOperacional()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ConteinerDetalheDTO buscarDetalhe(Long identificador) {
        Conteiner conteiner = localizarConteiner(identificador);
        return mapearDetalhe(conteiner);
    }

    @Transactional(readOnly = true)
    public ConteinerDetalheDTO buscarDetalhePorCodigo(String codigo) {
        Conteiner conteiner = localizarConteinerPorCodigo(codigo);
        return mapearDetalhe(conteiner);
    }

    @Transactional
    public ConteinerDetalheDTO registrarAlocacao(RegistroAlocacaoDTO dto) {
        String identificacao = limparObrigatorio(dto.getIdentificacao(), "Identificação inválida");
        validarIdentificacaoUnica(identificacao);
        Conteiner conteiner = new Conteiner();
        conteiner.setIdentificacao(identificacao);
        conteiner.setPosicaoPatio(limparObrigatorio(dto.getPosicaoPatio(), "Posição inválida"));
        conteiner.setTipoCarga(validarTipoCarga(dto.getTipoCarga()));
        conteiner.setPesoToneladas(validarPeso(dto.getPesoToneladas()));
        conteiner.setRestricoes(sanitizadorEntrada.limparTexto(dto.getRestricoes()));
        conteiner.setStatusOperacional(StatusOperacionalConteiner.ALOCADO);
        Conteiner salvo = conteinerRepositorio.save(conteiner);
        registrarHistorico(salvo, TipoOperacaoConteiner.ALOCACAO,
                "Alocação registrada para o contêiner", null,
                salvo.getPosicaoPatio(), null);
        return mapearDetalhe(salvo);
    }

    @Transactional
    public ConteinerDetalheDTO atualizarCadastro(Long identificador, AtualizacaoConteinerDTO dto) {
        Conteiner conteiner = localizarConteiner(identificador);
        if (conteiner.getStatusOperacional() == StatusOperacionalConteiner.LIBERADO) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "Contêiner liberado não permite atualização cadastral");
        }
        String posicao = limparObrigatorio(dto.getPosicaoPatio(), "Posição inválida");
        BigDecimal peso = validarPeso(dto.getPesoToneladas());
        conteiner.setPosicaoPatio(posicao);
        conteiner.setTipoCarga(validarTipoCarga(dto.getTipoCarga()));
        conteiner.setPesoToneladas(peso);
        conteiner.setRestricoes(sanitizadorEntrada.limparTexto(dto.getRestricoes()));
        Conteiner atualizado = conteinerRepositorio.save(conteiner);
        registrarHistorico(atualizado, TipoOperacaoConteiner.ATUALIZACAO_CADASTRAL,
                "Dados operacionais atualizados", null,
                atualizado.getPosicaoPatio(), null);
        return mapearDetalhe(atualizado);
    }

    @Transactional
    public ConteinerDetalheDTO registrarTransferencia(Long identificador, RegistroTransferenciaDTO dto) {
        Conteiner conteiner = localizarConteiner(identificador);
        garantirNaoLiberado(conteiner, "Contêiner liberado não pode ser transferido");
        String destino = limparObrigatorio(dto.getPosicaoDestino(), "Posição de destino inválida");
        String motivo = limparObrigatorio(dto.getMotivo(), "Motivo inválido");
        String posicaoAnterior = conteiner.getPosicaoPatio();
        conteiner.setPosicaoPatio(destino);
        conteiner.setStatusOperacional(StatusOperacionalConteiner.ALOCADO);
        Conteiner atualizado = conteinerRepositorio.save(conteiner);
        String descricao = "Transferência registrada: " + destino + " - " + motivo;
        registrarHistorico(atualizado, TipoOperacaoConteiner.TRANSFERENCIA, descricao,
                posicaoAnterior, destino, sanitizadorEntrada.limparTexto(dto.getResponsavel()));
        return mapearDetalhe(atualizado);
    }

    @Transactional
    public ConteinerDetalheDTO registrarInspecao(Long identificador, RegistroInspecaoDTO dto) {
        Conteiner conteiner = localizarConteiner(identificador);
        garantirNaoLiberado(conteiner, "Contêiner liberado não pode ser inspecionado");
        conteiner.setStatusOperacional(StatusOperacionalConteiner.INSPECIONADO);
        Conteiner atualizado = conteinerRepositorio.save(conteiner);
        String resultado = limparObrigatorio(dto.getResultado(), "Resultado inválido");
        String descricao = "Inspeção realizada: " + resultado;
        String observacoes = sanitizadorEntrada.limparTexto(dto.getObservacoes());
        if (observacoes != null) {
            descricao = descricao + " - Observações: " + observacoes;
        }
        registrarHistorico(atualizado, TipoOperacaoConteiner.INSPECAO, descricao,
                atualizado.getPosicaoPatio(), atualizado.getPosicaoPatio(),
                sanitizadorEntrada.limparTexto(dto.getResponsavel()));
        return mapearDetalhe(atualizado);
    }

    @Transactional
    public ConteinerDetalheDTO registrarLiberacao(Long identificador, RegistroLiberacaoDTO dto) {
        Conteiner conteiner = localizarConteiner(identificador);
        garantirNaoLiberado(conteiner, "Contêiner já está liberado");
        conteiner.setStatusOperacional(StatusOperacionalConteiner.LIBERADO);
        Conteiner atualizado = conteinerRepositorio.save(conteiner);
        String destinoFinal = limparObrigatorio(dto.getDestinoFinal(), "Destino inválido");
        String descricao = "Liberação para " + destinoFinal;
        String observacoes = sanitizadorEntrada.limparTexto(dto.getObservacoes());
        if (observacoes != null) {
            descricao = descricao + " - Observações: " + observacoes;
        }
        registrarHistorico(atualizado, TipoOperacaoConteiner.LIBERACAO, descricao,
                atualizado.getPosicaoPatio(), atualizado.getPosicaoPatio(),
                sanitizadorEntrada.limparTexto(dto.getResponsavel()));
        return mapearDetalhe(atualizado);
    }

    @Transactional(readOnly = true)
    public List<HistoricoOperacaoDTO> consultarHistorico(Long identificador) {
        Conteiner conteiner = localizarConteiner(identificador);
        return historicoRepositorio.findByConteinerIdOrderByDataRegistroDesc(conteiner.getId()).stream()
                .map(registro -> new HistoricoOperacaoDTO(
                        registro.getTipoOperacao(),
                        registro.getDescricao(),
                        registro.getPosicaoAnterior(),
                        registro.getPosicaoAtual(),
                        registro.getResponsavel(),
                        registro.getDataRegistro()))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<HistoricoOperacaoDTO> consultarHistoricoPorCodigo(String codigo) {
        Conteiner conteiner = localizarConteinerPorCodigo(codigo);
        return historicoRepositorio.findByConteinerIdOrderByDataRegistroDesc(conteiner.getId()).stream()
                .map(registro -> new HistoricoOperacaoDTO(
                        registro.getTipoOperacao(),
                        registro.getDescricao(),
                        registro.getPosicaoAnterior(),
                        registro.getPosicaoAtual(),
                        registro.getResponsavel(),
                        registro.getDataRegistro()))
                .collect(Collectors.toList());
    }

    private Conteiner localizarConteiner(Long identificador) {
        return conteinerRepositorio.findById(identificador)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Contêiner não encontrado"));
    }

    private Conteiner localizarConteinerPorCodigo(String codigo) {
        String codigoSanitizado = sanitizadorEntrada.limparTexto(codigo);
        if (!StringUtils.hasText(codigoSanitizado)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Código do contêiner inválido");
        }
        String codigoNormalizado = codigoSanitizado.toUpperCase(Locale.ROOT);
        return conteinerRepositorio.findByIdentificacaoIgnoreCase(codigoNormalizado)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Contêiner não encontrado"));
    }

    private void validarIdentificacaoUnica(String identificacao) {
        conteinerRepositorio.findByIdentificacaoIgnoreCase(identificacao)
                .ifPresent(c -> {
                    throw new ResponseStatusException(HttpStatus.CONFLICT,
                            "Identificação já cadastrada");
                });
    }

    private String limparObrigatorio(String texto, String mensagemErro) {
        String limpo = sanitizadorEntrada.limparTexto(texto);
        if (limpo == null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, mensagemErro);
        }
        return limpo;
    }

    private BigDecimal validarPeso(BigDecimal peso) {
        if (peso == null || peso.signum() <= 0) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Peso inválido");
        }
        return peso;
    }

    private TipoCargaConteiner validarTipoCarga(TipoCargaConteiner tipoCarga) {
        if (tipoCarga == null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Tipo de carga inválido");
        }
        return tipoCarga;
    }

    private void garantirNaoLiberado(Conteiner conteiner, String mensagem) {
        if (conteiner.getStatusOperacional() == StatusOperacionalConteiner.LIBERADO) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, mensagem);
        }
    }

    private ConteinerDetalheDTO mapearDetalhe(Conteiner conteiner) {
        return new ConteinerDetalheDTO(
                conteiner.getId(),
                conteiner.getIdentificacao(),
                conteiner.getPosicaoPatio(),
                conteiner.getTipoCarga(),
                conteiner.getPesoToneladas(),
                conteiner.getRestricoes(),
                conteiner.getStatusOperacional(),
                conteiner.getUltimaAtualizacao());
    }

    private void registrarHistorico(Conteiner conteiner, TipoOperacaoConteiner tipoOperacao,
                                    String descricao, String posicaoAnterior,
                                    String posicaoAtual, String responsavel) {
        HistoricoOperacaoConteiner historico = new HistoricoOperacaoConteiner();
        historico.setConteiner(conteiner);
        historico.setTipoOperacao(tipoOperacao);
        historico.setDescricao(limparObrigatorio(descricao, "Descrição inválida"));
        historico.setPosicaoAnterior(sanitizadorEntrada.limparTexto(posicaoAnterior));
        historico.setPosicaoAtual(sanitizadorEntrada.limparTexto(posicaoAtual));
        historico.setResponsavel(sanitizadorEntrada.limparTexto(responsavel));
        historico.setDataRegistro(OffsetDateTime.now(ZoneOffset.UTC));
        historicoRepositorio.save(historico);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\servico\MovimentacaoTremListener.java ----- 
package br.com.cloudport.servicoyard.container.servico;

import br.com.cloudport.servicoyard.container.dto.MovimentacaoTremConcluidaEventoDto;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component
public class MovimentacaoTremListener {

    private static final Logger LOGGER = LoggerFactory.getLogger(MovimentacaoTremListener.class);

    private final ProcessadorMovimentacaoTremService processadorMovimentacaoTremService;

    public MovimentacaoTremListener(ProcessadorMovimentacaoTremService processadorMovimentacaoTremService) {
        this.processadorMovimentacaoTremService = processadorMovimentacaoTremService;
    }

    @RabbitListener(queues = "${cloudport.yard.integracoes.ferrovia.queue}")
    public void aoReceberMovimentacao(MovimentacaoTremConcluidaEventoDto evento) {
        LOGGER.info("event=movimentacao_trem.recebida ordem={} visita={} conteiner={}",
                evento != null ? evento.getIdOrdemMovimentacao() : null,
                evento != null ? evento.getIdVisitaTrem() : null,
                evento != null ? evento.getCodigoConteiner() : null);
        processadorMovimentacaoTremService.processar(evento);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\servico\ProcessadorMovimentacaoTremService.java ----- 
package br.com.cloudport.servicoyard.container.servico;

import br.com.cloudport.servicoyard.container.dto.MovimentacaoTremConcluidaEventoDto;
import br.com.cloudport.servicoyard.container.entidade.Conteiner;
import br.com.cloudport.servicoyard.container.entidade.HistoricoOperacaoConteiner;
import br.com.cloudport.servicoyard.container.entidade.StatusOperacionalConteiner;
import br.com.cloudport.servicoyard.container.entidade.TipoOperacaoConteiner;
import br.com.cloudport.servicoyard.container.repositorio.ConteinerRepositorio;
import br.com.cloudport.servicoyard.container.repositorio.HistoricoOperacaoConteinerRepositorio;
import br.com.cloudport.servicoyard.container.validacao.SanitizadorEntrada;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.Locale;
import java.util.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

@Service
public class ProcessadorMovimentacaoTremService {

    private static final Logger LOGGER = LoggerFactory.getLogger(ProcessadorMovimentacaoTremService.class);
    private static final String RESPONSAVEL_INTEGRACAO = "Integração Ferrovia";

    private final ConteinerRepositorio conteinerRepositorio;
    private final HistoricoOperacaoConteinerRepositorio historicoRepositorio;
    private final SanitizadorEntrada sanitizadorEntrada;

    public ProcessadorMovimentacaoTremService(ConteinerRepositorio conteinerRepositorio,
                                              HistoricoOperacaoConteinerRepositorio historicoRepositorio,
                                              SanitizadorEntrada sanitizadorEntrada) {
        this.conteinerRepositorio = conteinerRepositorio;
        this.historicoRepositorio = historicoRepositorio;
        this.sanitizadorEntrada = sanitizadorEntrada;
    }

    @Transactional
    public void processar(MovimentacaoTremConcluidaEventoDto evento) {
        if (evento == null) {
            LOGGER.warn("event=movimentacao_trem.evento_nulo");
            return;
        }
        String codigoConteiner = Optional.ofNullable(evento.getCodigoConteiner())
                .map(sanitizadorEntrada::limparTexto)
                .map(valor -> valor.toUpperCase(Locale.ROOT))
                .orElse(null);
        if (!StringUtils.hasText(codigoConteiner)) {
            LOGGER.warn("event=movimentacao_trem.codigo_ausente ordem={} visita={}",
                    evento.getIdOrdemMovimentacao(), evento.getIdVisitaTrem());
            return;
        }
        TipoOperacaoConteiner tipoOperacao = mapearTipoOperacao(evento.getTipoMovimentacao());
        if (tipoOperacao == null) {
            LOGGER.warn("event=movimentacao_trem.tipo_desconhecido tipo={} ordem={} visita={}",
                    evento.getTipoMovimentacao(), evento.getIdOrdemMovimentacao(), evento.getIdVisitaTrem());
            return;
        }
        Conteiner conteiner = conteinerRepositorio.findByIdentificacaoIgnoreCase(codigoConteiner)
                .orElse(null);
        if (conteiner == null) {
            LOGGER.warn("event=movimentacao_trem.conteiner_nao_localizado codigo={} ordem={} visita={}",
                    codigoConteiner, evento.getIdOrdemMovimentacao(), evento.getIdVisitaTrem());
            return;
        }
        StatusOperacionalConteiner statusAnterior = conteiner.getStatusOperacional();
        StatusOperacionalConteiner novoStatus = definirStatusPosMovimentacao(tipoOperacao, statusAnterior);
        if (novoStatus != null && novoStatus != statusAnterior) {
            conteiner.setStatusOperacional(novoStatus);
            conteinerRepositorio.save(conteiner);
        }
        registrarHistorico(conteiner, tipoOperacao, evento, statusAnterior, novoStatus);
    }

    private void registrarHistorico(Conteiner conteiner,
                                    TipoOperacaoConteiner tipoOperacao,
                                    MovimentacaoTremConcluidaEventoDto evento,
                                    StatusOperacionalConteiner statusAnterior,
                                    StatusOperacionalConteiner novoStatus) {
        HistoricoOperacaoConteiner historico = new HistoricoOperacaoConteiner();
        historico.setConteiner(conteiner);
        historico.setTipoOperacao(tipoOperacao);
        historico.setDescricao(montarDescricao(tipoOperacao, statusAnterior, novoStatus));
        historico.setPosicaoAnterior(null);
        historico.setPosicaoAtual(conteiner.getPosicaoPatio());
        historico.setResponsavel(sanitizadorEntrada.limparTexto(RESPONSAVEL_INTEGRACAO));
        OffsetDateTime dataRegistro = Optional.ofNullable(evento.getConcluidoEm())
                .orElse(OffsetDateTime.now(ZoneOffset.UTC));
        historico.setDataRegistro(dataRegistro);
        historicoRepositorio.save(historico);
    }

    private TipoOperacaoConteiner mapearTipoOperacao(String tipoMovimentacao) {
        if (!StringUtils.hasText(tipoMovimentacao)) {
            return null;
        }
        String tipoNormalizado = tipoMovimentacao.trim().toUpperCase(Locale.ROOT);
        if ("DESCARGA_TREM".equals(tipoNormalizado)) {
            return TipoOperacaoConteiner.DESCARGA_TREM;
        }
        if ("CARGA_TREM".equals(tipoNormalizado)) {
            return TipoOperacaoConteiner.CARGA_TREM;
        }
        return null;
    }

    private StatusOperacionalConteiner definirStatusPosMovimentacao(TipoOperacaoConteiner tipoOperacao,
                                                                    StatusOperacionalConteiner statusAtual) {
        if (tipoOperacao == TipoOperacaoConteiner.DESCARGA_TREM) {
            return StatusOperacionalConteiner.ALOCADO;
        }
        if (tipoOperacao == TipoOperacaoConteiner.CARGA_TREM) {
            return StatusOperacionalConteiner.EM_TRANSFERENCIA;
        }
        return statusAtual;
    }

    private String montarDescricao(TipoOperacaoConteiner tipoOperacao,
                                   StatusOperacionalConteiner statusAnterior,
                                   StatusOperacionalConteiner novoStatus) {
        if (tipoOperacao == TipoOperacaoConteiner.DESCARGA_TREM) {
            return "Descarga do trem concluída e contêiner disponível no pátio.";
        }
        if (tipoOperacao == TipoOperacaoConteiner.CARGA_TREM) {
            return "Carga no trem concluída e contêiner encaminhado para o modal ferroviário.";
        }
        return String.format(Locale.ROOT,
                "Movimentação atualizada de %s para %s.",
                statusAnterior, novoStatus);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\container\validacao\SanitizadorEntrada.java ----- 
package br.com.cloudport.servicoyard.container.validacao;

import org.jsoup.Jsoup;
import org.jsoup.safety.Safelist;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

@Component
public class SanitizadorEntrada {
    public String limparTexto(String valor) {
        if (!StringUtils.hasText(valor)) {
            return null;
        }
        String limpo = Jsoup.clean(valor, Safelist.none());
        return StringUtils.hasText(limpo) ? limpo.trim() : null;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\controlador\MapaPatioControlador.java ----- 
package br.com.cloudport.servicoyard.patio.controlador;

import br.com.cloudport.servicoyard.patio.dto.ConteinerMapaDto;
import br.com.cloudport.servicoyard.patio.dto.ConteinerPatioRequisicaoDto;
import br.com.cloudport.servicoyard.patio.dto.EquipamentoMapaDto;
import br.com.cloudport.servicoyard.patio.dto.EquipamentoPatioRequisicaoDto;
import br.com.cloudport.servicoyard.patio.dto.FiltrosMapaPatioDto;
import br.com.cloudport.servicoyard.patio.dto.MapaPatioFiltro;
import br.com.cloudport.servicoyard.patio.dto.MapaPatioRespostaDto;
import br.com.cloudport.servicoyard.patio.dto.MovimentoPatioDto;
import br.com.cloudport.servicoyard.patio.dto.OpcoesCadastroPatioDto;
import br.com.cloudport.servicoyard.patio.dto.PosicaoPatioDto;
import br.com.cloudport.servicoyard.patio.servico.MapaPatioServico;
import java.util.List;
import javax.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/yard/patio")
public class MapaPatioControlador {

    private final MapaPatioServico mapaPatioServico;

    public MapaPatioControlador(MapaPatioServico mapaPatioServico) {
        this.mapaPatioServico = mapaPatioServico;
    }

    @GetMapping("/mapa")
    public MapaPatioRespostaDto consultarMapa(@RequestParam(name = "status", required = false) List<String> status,
                                              @RequestParam(name = "tipoCarga", required = false) List<String> tiposCarga,
                                              @RequestParam(name = "destino", required = false) List<String> destinos,
                                              @RequestParam(name = "camada", required = false) List<String> camadas,
                                              @RequestParam(name = "tipoEquipamento", required = false) List<String> tiposEquipamento) {
        MapaPatioFiltro filtro = mapaPatioServico.construirFiltro(status, tiposCarga, destinos, camadas, tiposEquipamento);
        return mapaPatioServico.consultarMapa(filtro);
    }

    @GetMapping("/filtros")
    public FiltrosMapaPatioDto consultarFiltros() {
        return mapaPatioServico.consultarFiltros();
    }

    @GetMapping("/posicoes")
    public List<PosicaoPatioDto> listarPosicoes() {
        return mapaPatioServico.listarPosicoes();
    }

    @GetMapping("/conteineres")
    public List<ConteinerMapaDto> listarConteineres() {
        return mapaPatioServico.listarConteineres();
    }

    @GetMapping("/movimentacoes")
    public List<MovimentoPatioDto> listarMovimentacoes() {
        return mapaPatioServico.listarMovimentacoesRecentes();
    }

    @GetMapping("/opcoes")
    public OpcoesCadastroPatioDto consultarOpcoesCadastro() {
        return mapaPatioServico.consultarOpcoesCadastro();
    }

    @PostMapping("/conteineres")
    public ConteinerMapaDto registrarOuAtualizarConteiner(@Valid @RequestBody ConteinerPatioRequisicaoDto requisicaoDto) {
        return mapaPatioServico.registrarOuAtualizarConteiner(requisicaoDto);
    }

    @PostMapping("/equipamentos")
    public EquipamentoMapaDto registrarOuAtualizarEquipamento(@Valid @RequestBody EquipamentoPatioRequisicaoDto requisicaoDto) {
        return mapaPatioServico.registrarOuAtualizarEquipamento(requisicaoDto);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> tratarErrosDeNegocio(IllegalArgumentException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ex.getMessage());
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\controlador\StatusPatioControlador.java ----- 
package br.com.cloudport.servicoyard.patio.controlador;

import br.com.cloudport.servicoyard.patio.dto.StatusPatioDto;
import br.com.cloudport.servicoyard.patio.servico.StatusPatioServico;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/yard/status")
public class StatusPatioControlador {

    private final StatusPatioServico statusPatioServico;

    public StatusPatioControlador(StatusPatioServico statusPatioServico) {
        this.statusPatioServico = statusPatioServico;
    }

    @GetMapping
    public StatusPatioDto verificarStatus() {
        return statusPatioServico.verificarDisponibilidade();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\ConteinerMapaDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import br.com.cloudport.servicoyard.patio.modelo.StatusConteiner;

public class ConteinerMapaDto {

    private Long id;
    private String codigo;
    private Integer linha;
    private Integer coluna;
    private StatusConteiner status;
    private String tipoCarga;
    private String destino;
    private String camadaOperacional;

    public ConteinerMapaDto() {
    }

    public ConteinerMapaDto(Long id, String codigo, Integer linha, Integer coluna, StatusConteiner status,
                             String tipoCarga, String destino, String camadaOperacional) {
        this.id = id;
        this.codigo = codigo;
        this.linha = linha;
        this.coluna = coluna;
        this.status = status;
        this.tipoCarga = tipoCarga;
        this.destino = destino;
        this.camadaOperacional = camadaOperacional;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public StatusConteiner getStatus() {
        return status;
    }

    public void setStatus(StatusConteiner status) {
        this.status = status;
    }

    public String getTipoCarga() {
        return tipoCarga;
    }

    public void setTipoCarga(String tipoCarga) {
        this.tipoCarga = tipoCarga;
    }

    public String getDestino() {
        return destino;
    }

    public void setDestino(String destino) {
        this.destino = destino;
    }

    public String getCamadaOperacional() {
        return camadaOperacional;
    }

    public void setCamadaOperacional(String camadaOperacional) {
        this.camadaOperacional = camadaOperacional;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\ConteinerPatioRequisicaoDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import br.com.cloudport.servicoyard.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicoyard.patio.modelo.StatusConteiner;
import java.time.LocalDateTime;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class ConteinerPatioRequisicaoDto {

    private Long id;

    @NotBlank
    @Size(max = 30)
    private String codigo;

    @NotNull
    @Min(0)
    private Integer linha;

    @NotNull
    @Min(0)
    private Integer coluna;

    @NotNull
    private StatusConteiner status;

    @NotBlank
    @Size(max = 40)
    private String tipoCarga;

    @NotBlank
    @Size(max = 60)
    private String destino;

    @NotBlank
    @Size(max = 40)
    private String camadaOperacional;

    public ConteinerPatioRequisicaoDto() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = ValidacaoEntradaUtil.limparTexto(codigo);
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public StatusConteiner getStatus() {
        return status;
    }

    public void setStatus(StatusConteiner status) {
        this.status = status;
    }

    public String getTipoCarga() {
        return tipoCarga;
    }

    public void setTipoCarga(String tipoCarga) {
        this.tipoCarga = ValidacaoEntradaUtil.limparTexto(tipoCarga);
    }

    public String getDestino() {
        return destino;
    }

    public void setDestino(String destino) {
        this.destino = ValidacaoEntradaUtil.limparTexto(destino);
    }

    public String getCamadaOperacional() {
        return camadaOperacional;
    }

    public void setCamadaOperacional(String camadaOperacional) {
        this.camadaOperacional = ValidacaoEntradaUtil.limparTexto(camadaOperacional);
    }

    public LocalDateTime gerarHorarioAtualizacao() {
        return LocalDateTime.now();
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\EquipamentoMapaDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import br.com.cloudport.servicoyard.patio.modelo.StatusEquipamento;
import br.com.cloudport.servicoyard.patio.modelo.TipoEquipamento;

public class EquipamentoMapaDto {

    private Long id;
    private String identificador;
    private TipoEquipamento tipoEquipamento;
    private Integer linha;
    private Integer coluna;
    private StatusEquipamento statusOperacional;

    public EquipamentoMapaDto() {
    }

    public EquipamentoMapaDto(Long id, String identificador, TipoEquipamento tipoEquipamento,
                               Integer linha, Integer coluna, StatusEquipamento statusOperacional) {
        this.id = id;
        this.identificador = identificador;
        this.tipoEquipamento = tipoEquipamento;
        this.linha = linha;
        this.coluna = coluna;
        this.statusOperacional = statusOperacional;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getIdentificador() {
        return identificador;
    }

    public void setIdentificador(String identificador) {
        this.identificador = identificador;
    }

    public TipoEquipamento getTipoEquipamento() {
        return tipoEquipamento;
    }

    public void setTipoEquipamento(TipoEquipamento tipoEquipamento) {
        this.tipoEquipamento = tipoEquipamento;
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public StatusEquipamento getStatusOperacional() {
        return statusOperacional;
    }

    public void setStatusOperacional(StatusEquipamento statusOperacional) {
        this.statusOperacional = statusOperacional;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\EquipamentoPatioRequisicaoDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import br.com.cloudport.servicoyard.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicoyard.patio.modelo.StatusEquipamento;
import br.com.cloudport.servicoyard.patio.modelo.TipoEquipamento;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class EquipamentoPatioRequisicaoDto {

    private Long id;

    @NotBlank
    @Size(max = 30)
    private String identificador;

    @NotNull
    private TipoEquipamento tipoEquipamento;

    @NotNull
    @Min(0)
    private Integer linha;

    @NotNull
    @Min(0)
    private Integer coluna;

    @NotNull
    private StatusEquipamento statusOperacional;

    public EquipamentoPatioRequisicaoDto() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getIdentificador() {
        return identificador;
    }

    public void setIdentificador(String identificador) {
        this.identificador = ValidacaoEntradaUtil.limparTexto(identificador);
    }

    public TipoEquipamento getTipoEquipamento() {
        return tipoEquipamento;
    }

    public void setTipoEquipamento(TipoEquipamento tipoEquipamento) {
        this.tipoEquipamento = tipoEquipamento;
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public StatusEquipamento getStatusOperacional() {
        return statusOperacional;
    }

    public void setStatusOperacional(StatusEquipamento statusOperacional) {
        this.statusOperacional = statusOperacional;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\EventoMapaTempoRealDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

public class EventoMapaTempoRealDto {

    private String tipoEvento;
    private MapaPatioRespostaDto mapa;

    public EventoMapaTempoRealDto() {
    }

    public EventoMapaTempoRealDto(String tipoEvento, MapaPatioRespostaDto mapa) {
        this.tipoEvento = tipoEvento;
        this.mapa = mapa;
    }

    public String getTipoEvento() {
        return tipoEvento;
    }

    public void setTipoEvento(String tipoEvento) {
        this.tipoEvento = tipoEvento;
    }

    public MapaPatioRespostaDto getMapa() {
        return mapa;
    }

    public void setMapa(MapaPatioRespostaDto mapa) {
        this.mapa = mapa;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\EventoMovimentoPatioDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import java.time.LocalDateTime;

public class EventoMovimentoPatioDto {

    private String codigoConteiner;
    private String tipoMovimento;
    private String descricao;
    private String destino;
    private Integer linha;
    private Integer coluna;
    private String camadaOperacional;
    private LocalDateTime registradoEm;

    public EventoMovimentoPatioDto() {
    }

    public EventoMovimentoPatioDto(String codigoConteiner, String tipoMovimento, String descricao,
                                   String destino, Integer linha, Integer coluna,
                                   String camadaOperacional, LocalDateTime registradoEm) {
        this.codigoConteiner = codigoConteiner;
        this.tipoMovimento = tipoMovimento;
        this.descricao = descricao;
        this.destino = destino;
        this.linha = linha;
        this.coluna = coluna;
        this.camadaOperacional = camadaOperacional;
        this.registradoEm = registradoEm;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public String getTipoMovimento() {
        return tipoMovimento;
    }

    public void setTipoMovimento(String tipoMovimento) {
        this.tipoMovimento = tipoMovimento;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public String getDestino() {
        return destino;
    }

    public void setDestino(String destino) {
        this.destino = destino;
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public String getCamadaOperacional() {
        return camadaOperacional;
    }

    public void setCamadaOperacional(String camadaOperacional) {
        this.camadaOperacional = camadaOperacional;
    }

    public LocalDateTime getRegistradoEm() {
        return registradoEm;
    }

    public void setRegistradoEm(LocalDateTime registradoEm) {
        this.registradoEm = registradoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\FiltrosMapaPatioDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import java.util.List;

public class FiltrosMapaPatioDto {

    private List<String> statusDisponiveis;
    private List<String> tiposCargaDisponiveis;
    private List<String> destinosDisponiveis;
    private List<String> camadasOperacionaisDisponiveis;
    private List<String> tiposEquipamentoDisponiveis;

    public FiltrosMapaPatioDto() {
    }

    public FiltrosMapaPatioDto(List<String> statusDisponiveis, List<String> tiposCargaDisponiveis,
                               List<String> destinosDisponiveis, List<String> camadasOperacionaisDisponiveis,
                               List<String> tiposEquipamentoDisponiveis) {
        this.statusDisponiveis = statusDisponiveis;
        this.tiposCargaDisponiveis = tiposCargaDisponiveis;
        this.destinosDisponiveis = destinosDisponiveis;
        this.camadasOperacionaisDisponiveis = camadasOperacionaisDisponiveis;
        this.tiposEquipamentoDisponiveis = tiposEquipamentoDisponiveis;
    }

    public List<String> getStatusDisponiveis() {
        return statusDisponiveis;
    }

    public void setStatusDisponiveis(List<String> statusDisponiveis) {
        this.statusDisponiveis = statusDisponiveis;
    }

    public List<String> getTiposCargaDisponiveis() {
        return tiposCargaDisponiveis;
    }

    public void setTiposCargaDisponiveis(List<String> tiposCargaDisponiveis) {
        this.tiposCargaDisponiveis = tiposCargaDisponiveis;
    }

    public List<String> getDestinosDisponiveis() {
        return destinosDisponiveis;
    }

    public void setDestinosDisponiveis(List<String> destinosDisponiveis) {
        this.destinosDisponiveis = destinosDisponiveis;
    }

    public List<String> getCamadasOperacionaisDisponiveis() {
        return camadasOperacionaisDisponiveis;
    }

    public void setCamadasOperacionaisDisponiveis(List<String> camadasOperacionaisDisponiveis) {
        this.camadasOperacionaisDisponiveis = camadasOperacionaisDisponiveis;
    }

    public List<String> getTiposEquipamentoDisponiveis() {
        return tiposEquipamentoDisponiveis;
    }

    public void setTiposEquipamentoDisponiveis(List<String> tiposEquipamentoDisponiveis) {
        this.tiposEquipamentoDisponiveis = tiposEquipamentoDisponiveis;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\MapaPatioFiltro.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import java.util.List;

public class MapaPatioFiltro {

    private List<String> status;
    private List<String> tiposCarga;
    private List<String> destinos;
    private List<String> camadasOperacionais;
    private List<String> tiposEquipamento;

    public MapaPatioFiltro(List<String> status, List<String> tiposCarga, List<String> destinos,
                           List<String> camadasOperacionais, List<String> tiposEquipamento) {
        this.status = status;
        this.tiposCarga = tiposCarga;
        this.destinos = destinos;
        this.camadasOperacionais = camadasOperacionais;
        this.tiposEquipamento = tiposEquipamento;
    }

    public List<String> getStatus() {
        return status;
    }

    public List<String> getTiposCarga() {
        return tiposCarga;
    }

    public List<String> getDestinos() {
        return destinos;
    }

    public List<String> getCamadasOperacionais() {
        return camadasOperacionais;
    }

    public List<String> getTiposEquipamento() {
        return tiposEquipamento;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\MapaPatioRespostaDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import java.time.LocalDateTime;
import java.util.List;

public class MapaPatioRespostaDto {

    private List<ConteinerMapaDto> conteineres;
    private List<EquipamentoMapaDto> equipamentos;
    private Integer totalLinhas;
    private Integer totalColunas;
    private LocalDateTime atualizadoEm;

    public MapaPatioRespostaDto() {
    }

    public MapaPatioRespostaDto(List<ConteinerMapaDto> conteineres, List<EquipamentoMapaDto> equipamentos,
                                Integer totalLinhas, Integer totalColunas, LocalDateTime atualizadoEm) {
        this.conteineres = conteineres;
        this.equipamentos = equipamentos;
        this.totalLinhas = totalLinhas;
        this.totalColunas = totalColunas;
        this.atualizadoEm = atualizadoEm;
    }

    public List<ConteinerMapaDto> getConteineres() {
        return conteineres;
    }

    public void setConteineres(List<ConteinerMapaDto> conteineres) {
        this.conteineres = conteineres;
    }

    public List<EquipamentoMapaDto> getEquipamentos() {
        return equipamentos;
    }

    public void setEquipamentos(List<EquipamentoMapaDto> equipamentos) {
        this.equipamentos = equipamentos;
    }

    public Integer getTotalLinhas() {
        return totalLinhas;
    }

    public void setTotalLinhas(Integer totalLinhas) {
        this.totalLinhas = totalLinhas;
    }

    public Integer getTotalColunas() {
        return totalColunas;
    }

    public void setTotalColunas(Integer totalColunas) {
        this.totalColunas = totalColunas;
    }

    public LocalDateTime getAtualizadoEm() {
        return atualizadoEm;
    }

    public void setAtualizadoEm(LocalDateTime atualizadoEm) {
        this.atualizadoEm = atualizadoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\MovimentoPatioDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import br.com.cloudport.servicoyard.patio.modelo.TipoMovimentoPatio;
import java.time.LocalDateTime;

public class MovimentoPatioDto {

    private Long id;
    private String codigoConteiner;
    private TipoMovimentoPatio tipoMovimento;
    private String descricao;
    private String destino;
    private Integer linha;
    private Integer coluna;
    private String camadaOperacional;
    private LocalDateTime registradoEm;

    public MovimentoPatioDto() {
    }

    public MovimentoPatioDto(Long id, String codigoConteiner, TipoMovimentoPatio tipoMovimento,
                              String descricao, String destino, Integer linha, Integer coluna,
                              String camadaOperacional, LocalDateTime registradoEm) {
        this.id = id;
        this.codigoConteiner = codigoConteiner;
        this.tipoMovimento = tipoMovimento;
        this.descricao = descricao;
        this.destino = destino;
        this.linha = linha;
        this.coluna = coluna;
        this.camadaOperacional = camadaOperacional;
        this.registradoEm = registradoEm;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public TipoMovimentoPatio getTipoMovimento() {
        return tipoMovimento;
    }

    public void setTipoMovimento(TipoMovimentoPatio tipoMovimento) {
        this.tipoMovimento = tipoMovimento;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public String getDestino() {
        return destino;
    }

    public void setDestino(String destino) {
        this.destino = destino;
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public String getCamadaOperacional() {
        return camadaOperacional;
    }

    public void setCamadaOperacional(String camadaOperacional) {
        this.camadaOperacional = camadaOperacional;
    }

    public LocalDateTime getRegistradoEm() {
        return registradoEm;
    }

    public void setRegistradoEm(LocalDateTime registradoEm) {
        this.registradoEm = registradoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\OpcoesCadastroPatioDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import java.util.List;

public class OpcoesCadastroPatioDto {

    private List<String> statusConteiner;
    private List<String> tiposEquipamento;
    private List<String> statusEquipamento;
    private List<String> tiposMovimento;

    public OpcoesCadastroPatioDto() {
    }

    public OpcoesCadastroPatioDto(List<String> statusConteiner, List<String> tiposEquipamento,
                                  List<String> statusEquipamento, List<String> tiposMovimento) {
        this.statusConteiner = statusConteiner;
        this.tiposEquipamento = tiposEquipamento;
        this.statusEquipamento = statusEquipamento;
        this.tiposMovimento = tiposMovimento;
    }

    public List<String> getStatusConteiner() {
        return statusConteiner;
    }

    public void setStatusConteiner(List<String> statusConteiner) {
        this.statusConteiner = statusConteiner;
    }

    public List<String> getTiposEquipamento() {
        return tiposEquipamento;
    }

    public void setTiposEquipamento(List<String> tiposEquipamento) {
        this.tiposEquipamento = tiposEquipamento;
    }

    public List<String> getStatusEquipamento() {
        return statusEquipamento;
    }

    public void setStatusEquipamento(List<String> statusEquipamento) {
        this.statusEquipamento = statusEquipamento;
    }

    public List<String> getTiposMovimento() {
        return tiposMovimento;
    }

    public void setTiposMovimento(List<String> tiposMovimento) {
        this.tiposMovimento = tiposMovimento;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\PosicaoPatioDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import br.com.cloudport.servicoyard.patio.modelo.StatusConteiner;

public class PosicaoPatioDto {

    private Long id;
    private Integer linha;
    private Integer coluna;
    private String camadaOperacional;
    private boolean ocupada;
    private String codigoConteiner;
    private StatusConteiner statusConteiner;

    public PosicaoPatioDto() {
    }

    public PosicaoPatioDto(Long id, Integer linha, Integer coluna, String camadaOperacional,
                           boolean ocupada, String codigoConteiner, StatusConteiner statusConteiner) {
        this.id = id;
        this.linha = linha;
        this.coluna = coluna;
        this.camadaOperacional = camadaOperacional;
        this.ocupada = ocupada;
        this.codigoConteiner = codigoConteiner;
        this.statusConteiner = statusConteiner;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public String getCamadaOperacional() {
        return camadaOperacional;
    }

    public void setCamadaOperacional(String camadaOperacional) {
        this.camadaOperacional = camadaOperacional;
    }

    public boolean isOcupada() {
        return ocupada;
    }

    public void setOcupada(boolean ocupada) {
        this.ocupada = ocupada;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public StatusConteiner getStatusConteiner() {
        return statusConteiner;
    }

    public void setStatusConteiner(StatusConteiner statusConteiner) {
        this.statusConteiner = statusConteiner;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\dto\StatusPatioDto.java ----- 
package br.com.cloudport.servicoyard.patio.dto;

import java.time.LocalDateTime;

public class StatusPatioDto {

    private String status;
    private String descricao;
    private LocalDateTime verificadoEm;

    public StatusPatioDto() {
    }

    public StatusPatioDto(String status, String descricao, LocalDateTime verificadoEm) {
        this.status = status;
        this.descricao = descricao;
        this.verificadoEm = verificadoEm;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public LocalDateTime getVerificadoEm() {
        return verificadoEm;
    }

    public void setVerificadoEm(LocalDateTime verificadoEm) {
        this.verificadoEm = verificadoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\listatrabalho\controlador\OrdemTrabalhoPatioControlador.java ----- 
package br.com.cloudport.servicoyard.patio.listatrabalho.controlador;

import br.com.cloudport.servicoyard.patio.listatrabalho.dto.AtualizacaoStatusOrdemTrabalhoDto;
import br.com.cloudport.servicoyard.patio.listatrabalho.dto.OrdemTrabalhoPatioRequisicaoDto;
import br.com.cloudport.servicoyard.patio.listatrabalho.dto.OrdemTrabalhoPatioRespostaDto;
import br.com.cloudport.servicoyard.patio.listatrabalho.modelo.StatusOrdemTrabalhoPatio;
import br.com.cloudport.servicoyard.patio.listatrabalho.servico.OrdemTrabalhoPatioServico;
import java.util.List;
import javax.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/yard/patio/ordens")
public class OrdemTrabalhoPatioControlador {

    private final OrdemTrabalhoPatioServico ordemTrabalhoPatioServico;

    public OrdemTrabalhoPatioControlador(OrdemTrabalhoPatioServico ordemTrabalhoPatioServico) {
        this.ordemTrabalhoPatioServico = ordemTrabalhoPatioServico;
    }

    @GetMapping
    public List<OrdemTrabalhoPatioRespostaDto> listarOrdens(@RequestParam(name = "status", required = false) StatusOrdemTrabalhoPatio status) {
        return ordemTrabalhoPatioServico.listarOrdens(status);
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public OrdemTrabalhoPatioRespostaDto registrarOrdem(@Valid @RequestBody OrdemTrabalhoPatioRequisicaoDto dto) {
        return ordemTrabalhoPatioServico.registrarOrdem(dto);
    }

    @PatchMapping("/{id}/status")
    public OrdemTrabalhoPatioRespostaDto atualizarStatus(@PathVariable("id") Long id,
                                                         @Valid @RequestBody AtualizacaoStatusOrdemTrabalhoDto dto) {
        return ordemTrabalhoPatioServico.atualizarStatus(id, dto);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\listatrabalho\dto\AtualizacaoStatusOrdemTrabalhoDto.java ----- 
package br.com.cloudport.servicoyard.patio.listatrabalho.dto;

import br.com.cloudport.servicoyard.patio.listatrabalho.modelo.StatusOrdemTrabalhoPatio;
import javax.validation.constraints.NotNull;

public class AtualizacaoStatusOrdemTrabalhoDto {

    @NotNull
    private StatusOrdemTrabalhoPatio statusOrdem;

    public AtualizacaoStatusOrdemTrabalhoDto() {
    }

    public StatusOrdemTrabalhoPatio getStatusOrdem() {
        return statusOrdem;
    }

    public void setStatusOrdem(StatusOrdemTrabalhoPatio statusOrdem) {
        this.statusOrdem = statusOrdem;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\listatrabalho\dto\OrdemTrabalhoPatioRequisicaoDto.java ----- 
package br.com.cloudport.servicoyard.patio.listatrabalho.dto;

import br.com.cloudport.servicoyard.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicoyard.patio.modelo.StatusConteiner;
import br.com.cloudport.servicoyard.patio.modelo.TipoMovimentoPatio;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class OrdemTrabalhoPatioRequisicaoDto {

    @NotBlank
    @Size(max = 30)
    private String codigoConteiner;

    @NotBlank
    @Size(max = 40)
    private String tipoCarga;

    @NotBlank
    @Size(max = 60)
    private String destino;

    @NotNull
    @Min(0)
    private Integer linhaDestino;

    @NotNull
    @Min(0)
    private Integer colunaDestino;

    @NotBlank
    @Size(max = 40)
    private String camadaDestino;

    @NotNull
    private TipoMovimentoPatio tipoMovimento;

    @NotNull
    private StatusConteiner statusConteinerDestino;

    public OrdemTrabalhoPatioRequisicaoDto() {
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = ValidacaoEntradaUtil.limparTexto(codigoConteiner);
    }

    public String getTipoCarga() {
        return tipoCarga;
    }

    public void setTipoCarga(String tipoCarga) {
        this.tipoCarga = ValidacaoEntradaUtil.limparTexto(tipoCarga);
    }

    public String getDestino() {
        return destino;
    }

    public void setDestino(String destino) {
        this.destino = ValidacaoEntradaUtil.limparTexto(destino);
    }

    public Integer getLinhaDestino() {
        return linhaDestino;
    }

    public void setLinhaDestino(Integer linhaDestino) {
        this.linhaDestino = linhaDestino;
    }

    public Integer getColunaDestino() {
        return colunaDestino;
    }

    public void setColunaDestino(Integer colunaDestino) {
        this.colunaDestino = colunaDestino;
    }

    public String getCamadaDestino() {
        return camadaDestino;
    }

    public void setCamadaDestino(String camadaDestino) {
        this.camadaDestino = ValidacaoEntradaUtil.limparTexto(camadaDestino);
    }

    public TipoMovimentoPatio getTipoMovimento() {
        return tipoMovimento;
    }

    public void setTipoMovimento(TipoMovimentoPatio tipoMovimento) {
        this.tipoMovimento = tipoMovimento;
    }

    public StatusConteiner getStatusConteinerDestino() {
        return statusConteinerDestino;
    }

    public void setStatusConteinerDestino(StatusConteiner statusConteinerDestino) {
        this.statusConteinerDestino = statusConteinerDestino;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\listatrabalho\dto\OrdemTrabalhoPatioRespostaDto.java ----- 
package br.com.cloudport.servicoyard.patio.listatrabalho.dto;

import br.com.cloudport.servicoyard.patio.listatrabalho.modelo.OrdemTrabalhoPatio;
import br.com.cloudport.servicoyard.patio.listatrabalho.modelo.StatusOrdemTrabalhoPatio;
import br.com.cloudport.servicoyard.patio.modelo.StatusConteiner;
import br.com.cloudport.servicoyard.patio.modelo.TipoMovimentoPatio;
import java.time.LocalDateTime;
import org.springframework.web.util.HtmlUtils;

public class OrdemTrabalhoPatioRespostaDto {

    private Long id;
    private String codigoConteiner;
    private String tipoCarga;
    private String destino;
    private Integer linhaDestino;
    private Integer colunaDestino;
    private String camadaDestino;
    private TipoMovimentoPatio tipoMovimento;
    private StatusOrdemTrabalhoPatio statusOrdem;
    private StatusConteiner statusConteinerDestino;
    private LocalDateTime criadoEm;
    private LocalDateTime atualizadoEm;
    private LocalDateTime concluidoEm;

    public OrdemTrabalhoPatioRespostaDto() {
    }

    public OrdemTrabalhoPatioRespostaDto(Long id,
                                         String codigoConteiner,
                                         String tipoCarga,
                                         String destino,
                                         Integer linhaDestino,
                                         Integer colunaDestino,
                                         String camadaDestino,
                                         TipoMovimentoPatio tipoMovimento,
                                         StatusOrdemTrabalhoPatio statusOrdem,
                                         StatusConteiner statusConteinerDestino,
                                         LocalDateTime criadoEm,
                                         LocalDateTime atualizadoEm,
                                         LocalDateTime concluidoEm) {
        this.id = id;
        this.codigoConteiner = codigoConteiner;
        this.tipoCarga = tipoCarga;
        this.destino = destino;
        this.linhaDestino = linhaDestino;
        this.colunaDestino = colunaDestino;
        this.camadaDestino = camadaDestino;
        this.tipoMovimento = tipoMovimento;
        this.statusOrdem = statusOrdem;
        this.statusConteinerDestino = statusConteinerDestino;
        this.criadoEm = criadoEm;
        this.atualizadoEm = atualizadoEm;
        this.concluidoEm = concluidoEm;
    }

    public static OrdemTrabalhoPatioRespostaDto deEntidade(OrdemTrabalhoPatio ordem) {
        return new OrdemTrabalhoPatioRespostaDto(
                ordem.getId(),
                escapar(ordem.getCodigoConteiner()),
                escapar(ordem.getTipoCarga()),
                escapar(ordem.getDestino()),
                ordem.getLinhaDestino(),
                ordem.getColunaDestino(),
                escapar(ordem.getCamadaDestino()),
                ordem.getTipoMovimento(),
                ordem.getStatusOrdem(),
                ordem.getStatusConteinerDestino(),
                ordem.getCriadoEm(),
                ordem.getAtualizadoEm(),
                ordem.getConcluidoEm()
        );
    }

    private static String escapar(String valor) {
        if (valor == null) {
            return null;
        }
        return HtmlUtils.htmlEscape(valor, "UTF-8");
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public String getTipoCarga() {
        return tipoCarga;
    }

    public void setTipoCarga(String tipoCarga) {
        this.tipoCarga = tipoCarga;
    }

    public String getDestino() {
        return destino;
    }

    public void setDestino(String destino) {
        this.destino = destino;
    }

    public Integer getLinhaDestino() {
        return linhaDestino;
    }

    public void setLinhaDestino(Integer linhaDestino) {
        this.linhaDestino = linhaDestino;
    }

    public Integer getColunaDestino() {
        return colunaDestino;
    }

    public void setColunaDestino(Integer colunaDestino) {
        this.colunaDestino = colunaDestino;
    }

    public String getCamadaDestino() {
        return camadaDestino;
    }

    public void setCamadaDestino(String camadaDestino) {
        this.camadaDestino = camadaDestino;
    }

    public TipoMovimentoPatio getTipoMovimento() {
        return tipoMovimento;
    }

    public void setTipoMovimento(TipoMovimentoPatio tipoMovimento) {
        this.tipoMovimento = tipoMovimento;
    }

    public StatusOrdemTrabalhoPatio getStatusOrdem() {
        return statusOrdem;
    }

    public void setStatusOrdem(StatusOrdemTrabalhoPatio statusOrdem) {
        this.statusOrdem = statusOrdem;
    }

    public StatusConteiner getStatusConteinerDestino() {
        return statusConteinerDestino;
    }

    public void setStatusConteinerDestino(StatusConteiner statusConteinerDestino) {
        this.statusConteinerDestino = statusConteinerDestino;
    }

    public LocalDateTime getCriadoEm() {
        return criadoEm;
    }

    public void setCriadoEm(LocalDateTime criadoEm) {
        this.criadoEm = criadoEm;
    }

    public LocalDateTime getAtualizadoEm() {
        return atualizadoEm;
    }

    public void setAtualizadoEm(LocalDateTime atualizadoEm) {
        this.atualizadoEm = atualizadoEm;
    }

    public LocalDateTime getConcluidoEm() {
        return concluidoEm;
    }

    public void setConcluidoEm(LocalDateTime concluidoEm) {
        this.concluidoEm = concluidoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\listatrabalho\modelo\OrdemTrabalhoPatio.java ----- 
package br.com.cloudport.servicoyard.patio.listatrabalho.modelo;

import br.com.cloudport.servicoyard.patio.modelo.StatusConteiner;
import br.com.cloudport.servicoyard.patio.modelo.TipoMovimentoPatio;
import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import br.com.cloudport.servicoyard.patio.modelo.ConteinerPatio;

@Entity
@Table(name = "ordem_trabalho_patio")
public class OrdemTrabalhoPatio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "conteiner_id")
    private ConteinerPatio conteiner;

    @Column(name = "codigo_conteiner", nullable = false, length = 30)
    private String codigoConteiner;

    @Column(name = "tipo_carga", nullable = false, length = 40)
    private String tipoCarga;

    @Column(name = "destino", nullable = false, length = 60)
    private String destino;

    @Column(name = "linha_destino", nullable = false)
    private Integer linhaDestino;

    @Column(name = "coluna_destino", nullable = false)
    private Integer colunaDestino;

    @Column(name = "camada_destino", nullable = false, length = 40)
    private String camadaDestino;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_movimento", nullable = false, length = 20)
    private TipoMovimentoPatio tipoMovimento;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_ordem", nullable = false, length = 20)
    private StatusOrdemTrabalhoPatio statusOrdem;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_conteiner_destino", nullable = false, length = 30)
    private StatusConteiner statusConteinerDestino;

    @Column(name = "criado_em", nullable = false)
    private LocalDateTime criadoEm;

    @Column(name = "atualizado_em", nullable = false)
    private LocalDateTime atualizadoEm;

    @Column(name = "concluido_em")
    private LocalDateTime concluidoEm;

    public OrdemTrabalhoPatio() {
    }

    public OrdemTrabalhoPatio(ConteinerPatio conteiner,
                              String codigoConteiner,
                              String tipoCarga,
                              String destino,
                              Integer linhaDestino,
                              Integer colunaDestino,
                              String camadaDestino,
                              TipoMovimentoPatio tipoMovimento,
                              StatusOrdemTrabalhoPatio statusOrdem,
                              StatusConteiner statusConteinerDestino,
                              LocalDateTime criadoEm,
                              LocalDateTime atualizadoEm) {
        this.conteiner = conteiner;
        this.codigoConteiner = codigoConteiner;
        this.tipoCarga = tipoCarga;
        this.destino = destino;
        this.linhaDestino = linhaDestino;
        this.colunaDestino = colunaDestino;
        this.camadaDestino = camadaDestino;
        this.tipoMovimento = tipoMovimento;
        this.statusOrdem = statusOrdem;
        this.statusConteinerDestino = statusConteinerDestino;
        this.criadoEm = criadoEm;
        this.atualizadoEm = atualizadoEm;
    }

    public Long getId() {
        return id;
    }

    public ConteinerPatio getConteiner() {
        return conteiner;
    }

    public void setConteiner(ConteinerPatio conteiner) {
        this.conteiner = conteiner;
    }

    public String getCodigoConteiner() {
        return codigoConteiner;
    }

    public void setCodigoConteiner(String codigoConteiner) {
        this.codigoConteiner = codigoConteiner;
    }

    public String getTipoCarga() {
        return tipoCarga;
    }

    public void setTipoCarga(String tipoCarga) {
        this.tipoCarga = tipoCarga;
    }

    public String getDestino() {
        return destino;
    }

    public void setDestino(String destino) {
        this.destino = destino;
    }

    public Integer getLinhaDestino() {
        return linhaDestino;
    }

    public void setLinhaDestino(Integer linhaDestino) {
        this.linhaDestino = linhaDestino;
    }

    public Integer getColunaDestino() {
        return colunaDestino;
    }

    public void setColunaDestino(Integer colunaDestino) {
        this.colunaDestino = colunaDestino;
    }

    public String getCamadaDestino() {
        return camadaDestino;
    }

    public void setCamadaDestino(String camadaDestino) {
        this.camadaDestino = camadaDestino;
    }

    public TipoMovimentoPatio getTipoMovimento() {
        return tipoMovimento;
    }

    public void setTipoMovimento(TipoMovimentoPatio tipoMovimento) {
        this.tipoMovimento = tipoMovimento;
    }

    public StatusOrdemTrabalhoPatio getStatusOrdem() {
        return statusOrdem;
    }

    public void setStatusOrdem(StatusOrdemTrabalhoPatio statusOrdem) {
        this.statusOrdem = statusOrdem;
    }

    public StatusConteiner getStatusConteinerDestino() {
        return statusConteinerDestino;
    }

    public void setStatusConteinerDestino(StatusConteiner statusConteinerDestino) {
        this.statusConteinerDestino = statusConteinerDestino;
    }

    public LocalDateTime getCriadoEm() {
        return criadoEm;
    }

    public void setCriadoEm(LocalDateTime criadoEm) {
        this.criadoEm = criadoEm;
    }

    public LocalDateTime getAtualizadoEm() {
        return atualizadoEm;
    }

    public void setAtualizadoEm(LocalDateTime atualizadoEm) {
        this.atualizadoEm = atualizadoEm;
    }

    public LocalDateTime getConcluidoEm() {
        return concluidoEm;
    }

    public void setConcluidoEm(LocalDateTime concluidoEm) {
        this.concluidoEm = concluidoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\listatrabalho\modelo\StatusOrdemTrabalhoPatio.java ----- 
package br.com.cloudport.servicoyard.patio.listatrabalho.modelo;

public enum StatusOrdemTrabalhoPatio {
    PENDENTE,
    EM_EXECUCAO,
    CONCLUIDA
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\listatrabalho\repositorio\OrdemTrabalhoPatioRepositorio.java ----- 
package br.com.cloudport.servicoyard.patio.listatrabalho.repositorio;

import br.com.cloudport.servicoyard.patio.listatrabalho.modelo.OrdemTrabalhoPatio;
import br.com.cloudport.servicoyard.patio.listatrabalho.modelo.StatusOrdemTrabalhoPatio;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrdemTrabalhoPatioRepositorio extends JpaRepository<OrdemTrabalhoPatio, Long> {

    List<OrdemTrabalhoPatio> findByStatusOrdemInOrderByCriadoEmAsc(List<StatusOrdemTrabalhoPatio> status);

    boolean existsByCodigoConteinerIgnoreCaseAndStatusOrdemIn(String codigoConteiner,
                                                              List<StatusOrdemTrabalhoPatio> status);

    Optional<OrdemTrabalhoPatio> findByIdAndStatusOrdemIn(Long id, List<StatusOrdemTrabalhoPatio> status);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\listatrabalho\servico\OrdemTrabalhoPatioServico.java ----- 
package br.com.cloudport.servicoyard.patio.listatrabalho.servico;

import br.com.cloudport.servicoyard.patio.dto.ConteinerPatioRequisicaoDto;
import br.com.cloudport.servicoyard.patio.listatrabalho.dto.AtualizacaoStatusOrdemTrabalhoDto;
import br.com.cloudport.servicoyard.patio.listatrabalho.dto.OrdemTrabalhoPatioRequisicaoDto;
import br.com.cloudport.servicoyard.patio.listatrabalho.dto.OrdemTrabalhoPatioRespostaDto;
import br.com.cloudport.servicoyard.patio.listatrabalho.modelo.OrdemTrabalhoPatio;
import br.com.cloudport.servicoyard.patio.listatrabalho.modelo.StatusOrdemTrabalhoPatio;
import br.com.cloudport.servicoyard.patio.listatrabalho.repositorio.OrdemTrabalhoPatioRepositorio;
import br.com.cloudport.servicoyard.patio.modelo.ConteinerPatio;
import br.com.cloudport.servicoyard.patio.modelo.StatusConteiner;
import br.com.cloudport.servicoyard.patio.modelo.TipoMovimentoPatio;
import br.com.cloudport.servicoyard.patio.repositorio.ConteinerPatioRepositorio;
import br.com.cloudport.servicoyard.patio.servico.MapaPatioServico;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ResponseStatusException;

@Service
public class OrdemTrabalhoPatioServico {

    private final OrdemTrabalhoPatioRepositorio ordemRepositorio;
    private final ConteinerPatioRepositorio conteinerRepositorio;
    private final MapaPatioServico mapaPatioServico;

    public OrdemTrabalhoPatioServico(OrdemTrabalhoPatioRepositorio ordemRepositorio,
                                     ConteinerPatioRepositorio conteinerRepositorio,
                                     MapaPatioServico mapaPatioServico) {
        this.ordemRepositorio = ordemRepositorio;
        this.conteinerRepositorio = conteinerRepositorio;
        this.mapaPatioServico = mapaPatioServico;
    }

    @Transactional(readOnly = true)
    public List<OrdemTrabalhoPatioRespostaDto> listarOrdens(StatusOrdemTrabalhoPatio status) {
        List<StatusOrdemTrabalhoPatio> filtros = status != null
                ? List.of(status)
                : new ArrayList<>(EnumSet.allOf(StatusOrdemTrabalhoPatio.class));
        return ordemRepositorio.findByStatusOrdemInOrderByCriadoEmAsc(filtros).stream()
                .map(OrdemTrabalhoPatioRespostaDto::deEntidade)
                .toList();
    }

    @Transactional
    public OrdemTrabalhoPatioRespostaDto registrarOrdem(OrdemTrabalhoPatioRequisicaoDto dto) {
        validarCamposObrigatorios(dto);
        String codigoNormalizado = dto.getCodigoConteiner().toUpperCase(Locale.ROOT);
        List<StatusOrdemTrabalhoPatio> ativos = List.of(StatusOrdemTrabalhoPatio.PENDENTE,
                StatusOrdemTrabalhoPatio.EM_EXECUCAO);
        if (ordemRepositorio.existsByCodigoConteinerIgnoreCaseAndStatusOrdemIn(codigoNormalizado, ativos)) {
            throw new ResponseStatusException(HttpStatus.CONFLICT,
                    "Já existe uma ordem pendente ou em execução para este contêiner.");
        }
        ConteinerPatio conteinerExistente = conteinerRepositorio.findByCodigoIgnoreCase(codigoNormalizado).orElse(null);
        LocalDateTime agora = LocalDateTime.now();
        OrdemTrabalhoPatio ordem = new OrdemTrabalhoPatio(
                conteinerExistente,
                codigoNormalizado,
                dto.getTipoCarga().toUpperCase(Locale.ROOT),
                dto.getDestino(),
                dto.getLinhaDestino(),
                dto.getColunaDestino(),
                dto.getCamadaDestino(),
                dto.getTipoMovimento(),
                StatusOrdemTrabalhoPatio.PENDENTE,
                dto.getStatusConteinerDestino(),
                agora,
                agora
        );
        OrdemTrabalhoPatio salvo = ordemRepositorio.save(ordem);
        return OrdemTrabalhoPatioRespostaDto.deEntidade(salvo);
    }

    @Transactional
    public OrdemTrabalhoPatioRespostaDto atualizarStatus(Long id, AtualizacaoStatusOrdemTrabalhoDto dto) {
        StatusOrdemTrabalhoPatio novoStatus = Optional.ofNullable(dto.getStatusOrdem())
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST,
                        "O novo status deve ser informado."));
        OrdemTrabalhoPatio ordem = ordemRepositorio.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Ordem de trabalho não encontrada."));
        validarTransicaoStatus(ordem.getStatusOrdem(), novoStatus);
        if (ordem.getStatusOrdem() == novoStatus) {
            return OrdemTrabalhoPatioRespostaDto.deEntidade(ordem);
        }
        ordem.setStatusOrdem(novoStatus);
        ordem.setAtualizadoEm(LocalDateTime.now());
        if (novoStatus == StatusOrdemTrabalhoPatio.CONCLUIDA) {
            ordem.setConcluidoEm(LocalDateTime.now());
            aplicarAtualizacaoInventario(ordem);
        }
        OrdemTrabalhoPatio atualizado = ordemRepositorio.save(ordem);
        return OrdemTrabalhoPatioRespostaDto.deEntidade(atualizado);
    }

    private void aplicarAtualizacaoInventario(OrdemTrabalhoPatio ordem) {
        ConteinerPatioRequisicaoDto requisicao = new ConteinerPatioRequisicaoDto();
        requisicao.setCodigo(ordem.getCodigoConteiner());
        requisicao.setLinha(ordem.getLinhaDestino());
        requisicao.setColuna(ordem.getColunaDestino());
        requisicao.setStatus(ordem.getStatusConteinerDestino());
        requisicao.setTipoCarga(ordem.getTipoCarga());
        requisicao.setDestino(ordem.getDestino());
        requisicao.setCamadaOperacional(ordem.getCamadaDestino());
        mapaPatioServico.registrarOuAtualizarConteiner(requisicao);
        conteinerRepositorio.findByCodigoIgnoreCase(ordem.getCodigoConteiner())
                .ifPresent(ordem::setConteiner);
    }

    private void validarCamposObrigatorios(OrdemTrabalhoPatioRequisicaoDto dto) {
        if (!StringUtils.hasText(dto.getCodigoConteiner())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "O código do contêiner é obrigatório.");
        }
        if (dto.getLinhaDestino() == null || dto.getLinhaDestino() < 0
                || dto.getColunaDestino() == null || dto.getColunaDestino() < 0) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "As coordenadas da posição de destino devem ser válidas.");
        }
        if (!StringUtils.hasText(dto.getDestino())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "O destino da carga é obrigatório.");
        }
        if (!StringUtils.hasText(dto.getTipoCarga())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "O tipo de carga é obrigatório.");
        }
        if (!StringUtils.hasText(dto.getCamadaDestino())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "A camada operacional é obrigatória.");
        }
        if (dto.getTipoMovimento() == TipoMovimentoPatio.REMOCAO) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "O tipo de movimento de remoção deve ser tratado pelo módulo de expedição.");
        }
        if (dto.getStatusConteinerDestino() == null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "O status final do contêiner é obrigatório e deve ser válido.");
        }
    }

    private void validarTransicaoStatus(StatusOrdemTrabalhoPatio statusAtual,
                                        StatusOrdemTrabalhoPatio novoStatus) {
        if (statusAtual == novoStatus) {
            return;
        }
        if (statusAtual == StatusOrdemTrabalhoPatio.PENDENTE
                && (novoStatus == StatusOrdemTrabalhoPatio.EM_EXECUCAO
                || novoStatus == StatusOrdemTrabalhoPatio.CONCLUIDA)) {
            return;
        }
        if (statusAtual == StatusOrdemTrabalhoPatio.EM_EXECUCAO
                && novoStatus == StatusOrdemTrabalhoPatio.CONCLUIDA) {
            return;
        }
        throw new ResponseStatusException(HttpStatus.CONFLICT,
                String.format(Locale.ROOT,
                        "A transição de status de %s para %s não é permitida.",
                        statusAtual, novoStatus));
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\CargaPatio.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "carga_patio")
public class CargaPatio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "codigo", nullable = false, length = 30, unique = true)
    private String codigo;

    @Column(name = "descricao", nullable = false, length = 80)
    private String descricao;

    public CargaPatio() {
    }

    public CargaPatio(Long id, String codigo, String descricao) {
        this.id = id;
        this.codigo = codigo;
        this.descricao = descricao;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\ConteinerPatio.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "conteiner_patio")
public class ConteinerPatio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "codigo", nullable = false, length = 30, unique = true)
    private String codigo;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_conteiner", nullable = false, length = 30)
    private StatusConteiner status;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "carga_id", nullable = false)
    private CargaPatio carga;

    @Column(name = "destino", nullable = false, length = 60)
    private String destino;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "posicao_id", nullable = false)
    private PosicaoPatio posicao;

    @Column(name = "atualizado_em", nullable = false)
    private LocalDateTime atualizadoEm;

    public ConteinerPatio() {
    }

    public ConteinerPatio(Long id, String codigo, StatusConteiner status,
                          CargaPatio carga, String destino, PosicaoPatio posicao,
                          LocalDateTime atualizadoEm) {
        this.id = id;
        this.codigo = codigo;
        this.status = status;
        this.carga = carga;
        this.destino = destino;
        this.posicao = posicao;
        this.atualizadoEm = atualizadoEm;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public CargaPatio getCarga() {
        return carga;
    }

    public void setCarga(CargaPatio carga) {
        this.carga = carga;
    }

    public PosicaoPatio getPosicao() {
        return posicao;
    }

    public void setPosicao(PosicaoPatio posicao) {
        this.posicao = posicao;
    }

    public StatusConteiner getStatus() {
        return status;
    }

    public void setStatus(StatusConteiner status) {
        this.status = status;
    }

    public String getDestino() {
        return destino;
    }

    public void setDestino(String destino) {
        this.destino = destino;
    }

    public LocalDateTime getAtualizadoEm() {
        return atualizadoEm;
    }

    public void setAtualizadoEm(LocalDateTime atualizadoEm) {
        this.atualizadoEm = atualizadoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\EquipamentoPatio.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "equipamento_patio")
public class EquipamentoPatio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "identificador", nullable = false, length = 30, unique = true)
    private String identificador;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_equipamento", nullable = false, length = 30)
    private TipoEquipamento tipoEquipamento;

    @Column(name = "linha", nullable = false)
    private Integer linha;

    @Column(name = "coluna", nullable = false)
    private Integer coluna;

    @Enumerated(EnumType.STRING)
    @Column(name = "status_operacional", nullable = false, length = 30)
    private StatusEquipamento statusOperacional;

    public EquipamentoPatio() {
    }

    public EquipamentoPatio(Long id, String identificador, TipoEquipamento tipoEquipamento, Integer linha,
                             Integer coluna, StatusEquipamento statusOperacional) {
        this.id = id;
        this.identificador = identificador;
        this.tipoEquipamento = tipoEquipamento;
        this.linha = linha;
        this.coluna = coluna;
        this.statusOperacional = statusOperacional;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getIdentificador() {
        return identificador;
    }

    public void setIdentificador(String identificador) {
        this.identificador = identificador;
    }

    public TipoEquipamento getTipoEquipamento() {
        return tipoEquipamento;
    }

    public void setTipoEquipamento(TipoEquipamento tipoEquipamento) {
        this.tipoEquipamento = tipoEquipamento;
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public StatusEquipamento getStatusOperacional() {
        return statusOperacional;
    }

    public void setStatusOperacional(StatusEquipamento statusOperacional) {
        this.statusOperacional = statusOperacional;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\MovimentoPatio.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "movimento_patio")
public class MovimentoPatio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "conteiner_id", nullable = false)
    private ConteinerPatio conteiner;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_movimento", nullable = false, length = 30)
    private TipoMovimentoPatio tipoMovimento;

    @Column(name = "descricao", nullable = false, length = 160)
    private String descricao;

    @Column(name = "registrado_em", nullable = false)
    private LocalDateTime registradoEm;

    public MovimentoPatio() {
    }

    public MovimentoPatio(Long id, ConteinerPatio conteiner, TipoMovimentoPatio tipoMovimento,
                           String descricao, LocalDateTime registradoEm) {
        this.id = id;
        this.conteiner = conteiner;
        this.tipoMovimento = tipoMovimento;
        this.descricao = descricao;
        this.registradoEm = registradoEm;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public ConteinerPatio getConteiner() {
        return conteiner;
    }

    public void setConteiner(ConteinerPatio conteiner) {
        this.conteiner = conteiner;
    }

    public TipoMovimentoPatio getTipoMovimento() {
        return tipoMovimento;
    }

    public void setTipoMovimento(TipoMovimentoPatio tipoMovimento) {
        this.tipoMovimento = tipoMovimento;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public LocalDateTime getRegistradoEm() {
        return registradoEm;
    }

    public void setRegistradoEm(LocalDateTime registradoEm) {
        this.registradoEm = registradoEm;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\PosicaoPatio.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

@Entity
@Table(name = "posicao_patio", uniqueConstraints = {
        @UniqueConstraint(name = "uk_posicao_unica", columnNames = {"linha", "coluna", "camada_operacional"})
})
public class PosicaoPatio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "linha", nullable = false)
    private Integer linha;

    @Column(name = "coluna", nullable = false)
    private Integer coluna;

    @Column(name = "camada_operacional", nullable = false, length = 40)
    private String camadaOperacional;

    public PosicaoPatio() {
    }

    public PosicaoPatio(Long id, Integer linha, Integer coluna, String camadaOperacional) {
        this.id = id;
        this.linha = linha;
        this.coluna = coluna;
        this.camadaOperacional = camadaOperacional;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Integer getLinha() {
        return linha;
    }

    public void setLinha(Integer linha) {
        this.linha = linha;
    }

    public Integer getColuna() {
        return coluna;
    }

    public void setColuna(Integer coluna) {
        this.coluna = coluna;
    }

    public String getCamadaOperacional() {
        return camadaOperacional;
    }

    public void setCamadaOperacional(String camadaOperacional) {
        this.camadaOperacional = camadaOperacional;
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\StatusConteiner.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

public enum StatusConteiner {
    AGUARDANDO_RETIRADA,
    INSPECIONANDO,
    DESPACHADO,
    RETIDO,
    DANIFICADO
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\StatusEquipamento.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

public enum StatusEquipamento {
    OPERACIONAL,
    MANUTENCAO,
    INDISPONIVEL
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\TipoEquipamento.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

public enum TipoEquipamento {
    RTG,
    REACH_STACKER,
    TRATOR_PORTUARIO,
    GUINDASTE_SHIP_TO_SHORE
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\modelo\TipoMovimentoPatio.java ----- 
package br.com.cloudport.servicoyard.patio.modelo;

public enum TipoMovimentoPatio {
    ALOCACAO,
    ATUALIZACAO,
    REMOCAO
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\repositorio\CargaPatioRepositorio.java ----- 
package br.com.cloudport.servicoyard.patio.repositorio;

import br.com.cloudport.servicoyard.patio.modelo.CargaPatio;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CargaPatioRepositorio extends JpaRepository<CargaPatio, Long> {

    Optional<CargaPatio> findByCodigo(String codigo);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\repositorio\ConteinerPatioRepositorio.java ----- 
package br.com.cloudport.servicoyard.patio.repositorio;

import br.com.cloudport.servicoyard.patio.modelo.ConteinerPatio;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ConteinerPatioRepositorio extends JpaRepository<ConteinerPatio, Long> {

    Optional<ConteinerPatio> findByCodigo(String codigo);

    Optional<ConteinerPatio> findByCodigoIgnoreCase(String codigo);

    List<ConteinerPatio> findAllByOrderByPosicaoLinhaAscPosicaoColunaAsc();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\repositorio\EquipamentoPatioRepositorio.java ----- 
package br.com.cloudport.servicoyard.patio.repositorio;

import br.com.cloudport.servicoyard.patio.modelo.EquipamentoPatio;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface EquipamentoPatioRepositorio extends JpaRepository<EquipamentoPatio, Long> {

    Optional<EquipamentoPatio> findByIdentificador(String identificador);

    List<EquipamentoPatio> findAllByOrderByTipoEquipamentoAscIdentificadorAsc();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\repositorio\MovimentoPatioRepositorio.java ----- 
package br.com.cloudport.servicoyard.patio.repositorio;

import br.com.cloudport.servicoyard.patio.modelo.MovimentoPatio;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MovimentoPatioRepositorio extends JpaRepository<MovimentoPatio, Long> {

    List<MovimentoPatio> findTop50ByOrderByRegistradoEmDesc();
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\repositorio\PosicaoPatioRepositorio.java ----- 
package br.com.cloudport.servicoyard.patio.repositorio;

import br.com.cloudport.servicoyard.patio.modelo.PosicaoPatio;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PosicaoPatioRepositorio extends JpaRepository<PosicaoPatio, Long> {

    Optional<PosicaoPatio> findByLinhaAndColunaAndCamadaOperacional(Integer linha, Integer coluna, String camadaOperacional);
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\servico\MapaPatioServico.java ----- 
package br.com.cloudport.servicoyard.patio.servico;

import br.com.cloudport.servicoyard.comum.validacao.ValidacaoEntradaUtil;
import br.com.cloudport.servicoyard.patio.dto.ConteinerMapaDto;
import br.com.cloudport.servicoyard.patio.dto.ConteinerPatioRequisicaoDto;
import br.com.cloudport.servicoyard.patio.dto.EquipamentoMapaDto;
import br.com.cloudport.servicoyard.patio.dto.EquipamentoPatioRequisicaoDto;
import br.com.cloudport.servicoyard.patio.dto.EventoMapaTempoRealDto;
import br.com.cloudport.servicoyard.patio.dto.FiltrosMapaPatioDto;
import br.com.cloudport.servicoyard.patio.dto.MapaPatioFiltro;
import br.com.cloudport.servicoyard.patio.dto.MapaPatioRespostaDto;
import br.com.cloudport.servicoyard.patio.dto.MovimentoPatioDto;
import br.com.cloudport.servicoyard.patio.dto.OpcoesCadastroPatioDto;
import br.com.cloudport.servicoyard.patio.dto.PosicaoPatioDto;
import br.com.cloudport.servicoyard.patio.dto.EventoMovimentoPatioDto;
import br.com.cloudport.servicoyard.patio.modelo.ConteinerPatio;
import br.com.cloudport.servicoyard.patio.modelo.CargaPatio;
import br.com.cloudport.servicoyard.patio.modelo.EquipamentoPatio;
import br.com.cloudport.servicoyard.patio.modelo.MovimentoPatio;
import br.com.cloudport.servicoyard.patio.modelo.PosicaoPatio;
import br.com.cloudport.servicoyard.patio.modelo.StatusConteiner;
import br.com.cloudport.servicoyard.patio.modelo.StatusEquipamento;
import br.com.cloudport.servicoyard.patio.modelo.TipoEquipamento;
import br.com.cloudport.servicoyard.patio.modelo.TipoMovimentoPatio;
import br.com.cloudport.servicoyard.patio.repositorio.ConteinerPatioRepositorio;
import br.com.cloudport.servicoyard.patio.repositorio.EquipamentoPatioRepositorio;
import br.com.cloudport.servicoyard.patio.repositorio.CargaPatioRepositorio;
import br.com.cloudport.servicoyard.patio.repositorio.MovimentoPatioRepositorio;
import br.com.cloudport.servicoyard.patio.repositorio.PosicaoPatioRepositorio;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.springframework.data.domain.Sort;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.util.HtmlUtils;

@Service
public class MapaPatioServico {

    private static final String TOPICO_ATUALIZACOES = "/topico/patio";

    private final ConteinerPatioRepositorio conteinerPatioRepositorio;
    private final EquipamentoPatioRepositorio equipamentoPatioRepositorio;
    private final PosicaoPatioRepositorio posicaoPatioRepositorio;
    private final CargaPatioRepositorio cargaPatioRepositorio;
    private final MovimentoPatioRepositorio movimentoPatioRepositorio;
    private final SimpMessagingTemplate messagingTemplate;
    private final PublicadorEventoMovimentoPatio publicadorEventoMovimentoPatio;

    public MapaPatioServico(ConteinerPatioRepositorio conteinerPatioRepositorio,
                             EquipamentoPatioRepositorio equipamentoPatioRepositorio,
                             PosicaoPatioRepositorio posicaoPatioRepositorio,
                             CargaPatioRepositorio cargaPatioRepositorio,
                             MovimentoPatioRepositorio movimentoPatioRepositorio,
                             SimpMessagingTemplate messagingTemplate,
                             PublicadorEventoMovimentoPatio publicadorEventoMovimentoPatio) {
        this.conteinerPatioRepositorio = conteinerPatioRepositorio;
        this.equipamentoPatioRepositorio = equipamentoPatioRepositorio;
        this.posicaoPatioRepositorio = posicaoPatioRepositorio;
        this.cargaPatioRepositorio = cargaPatioRepositorio;
        this.movimentoPatioRepositorio = movimentoPatioRepositorio;
        this.messagingTemplate = messagingTemplate;
        this.publicadorEventoMovimentoPatio = publicadorEventoMovimentoPatio;
    }

    @Transactional(readOnly = true)
    public MapaPatioRespostaDto consultarMapa(MapaPatioFiltro filtro) {
        List<ConteinerPatio> conteineres = conteinerPatioRepositorio.findAllByOrderByPosicaoLinhaAscPosicaoColunaAsc();
        List<EquipamentoPatio> equipamentos = equipamentoPatioRepositorio.findAllByOrderByTipoEquipamentoAscIdentificadorAsc();

        List<ConteinerMapaDto> conteineresFiltrados = conteineres.stream()
                .filter(conteiner -> filtrarConteiner(conteiner, filtro))
                .map(this::converterConteiner)
                .collect(Collectors.toList());

        List<EquipamentoMapaDto> equipamentosFiltrados = equipamentos.stream()
                .filter(equipamento -> filtrarEquipamento(equipamento, filtro))
                .map(this::converterEquipamento)
                .collect(Collectors.toList());

        int totalLinhas = conteineres.stream()
                .map(conteiner -> conteiner.getPosicao().getLinha())
                .max(Integer::compareTo)
                .orElse(0);
        int totalColunas = conteineres.stream()
                .map(conteiner -> conteiner.getPosicao().getColuna())
                .max(Integer::compareTo)
                .orElse(0);
        LocalDateTime ultimaAtualizacao = conteineres.stream()
                .map(ConteinerPatio::getAtualizadoEm)
                .max(LocalDateTime::compareTo)
                .orElse(LocalDateTime.now());

        return new MapaPatioRespostaDto(conteineresFiltrados, equipamentosFiltrados,
                totalLinhas + 1, totalColunas + 1, ultimaAtualizacao);
    }

    @Transactional(readOnly = true)
    public FiltrosMapaPatioDto consultarFiltros() {
        List<ConteinerPatio> conteineres = conteinerPatioRepositorio.findAll();
        List<EquipamentoPatio> equipamentos = equipamentoPatioRepositorio.findAll();

        Set<String> status = conteineres.stream()
                .map(conteiner -> conteiner.getStatus().name())
                .collect(Collectors.toCollection(TreeSet::new));

        Set<String> tiposCarga = conteineres.stream()
                .map(conteiner -> escapar(conteiner.getCarga().getCodigo()))
                .collect(Collectors.toCollection(TreeSet::new));

        Set<String> destinos = conteineres.stream()
                .map(conteiner -> escapar(conteiner.getDestino()))
                .collect(Collectors.toCollection(TreeSet::new));

        Set<String> camadas = conteineres.stream()
                .map(conteiner -> escapar(conteiner.getPosicao().getCamadaOperacional()))
                .collect(Collectors.toCollection(TreeSet::new));

        Set<String> tiposEquipamento = equipamentos.stream()
                .map(equipamento -> equipamento.getTipoEquipamento().name())
                .collect(Collectors.toCollection(TreeSet::new));

        return new FiltrosMapaPatioDto(
                List.copyOf(status),
                List.copyOf(tiposCarga),
                List.copyOf(destinos),
                List.copyOf(camadas),
                List.copyOf(tiposEquipamento)
        );
    }

    @Transactional(readOnly = true)
    public List<PosicaoPatioDto> listarPosicoes() {
        List<PosicaoPatio> posicoes = posicaoPatioRepositorio.findAll(
                Sort.by(Sort.Order.asc("linha"), Sort.Order.asc("coluna"), Sort.Order.asc("camadaOperacional"))
        );
        Map<Long, ConteinerPatio> conteineresPorPosicao = conteinerPatioRepositorio.findAll().stream()
                .filter(conteiner -> conteiner.getPosicao() != null && conteiner.getPosicao().getId() != null)
                .collect(Collectors.toMap(
                        conteiner -> conteiner.getPosicao().getId(),
                        Function.identity(),
                        (conteinerExistente, novoConteiner) -> conteinerExistente
                ));

        return posicoes.stream()
                .map(posicao -> converterPosicao(posicao, conteineresPorPosicao.get(posicao.getId())))
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ConteinerMapaDto> listarConteineres() {
        return conteinerPatioRepositorio.findAllByOrderByPosicaoLinhaAscPosicaoColunaAsc().stream()
                .map(this::converterConteiner)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<MovimentoPatioDto> listarMovimentacoesRecentes() {
        return movimentoPatioRepositorio.findTop50ByOrderByRegistradoEmDesc().stream()
                .map(this::converterMovimento)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public OpcoesCadastroPatioDto consultarOpcoesCadastro() {
        List<String> statusConteiner = Arrays.stream(StatusConteiner.values())
                .map(Enum::name)
                .collect(Collectors.toList());
        List<String> tiposEquipamento = Arrays.stream(TipoEquipamento.values())
                .map(Enum::name)
                .collect(Collectors.toList());
        List<String> statusEquipamento = Arrays.stream(StatusEquipamento.values())
                .map(Enum::name)
                .collect(Collectors.toList());
        List<String> tiposMovimento = Arrays.stream(TipoMovimentoPatio.values())
                .filter(tipo -> tipo != TipoMovimentoPatio.REMOCAO)
                .map(Enum::name)
                .collect(Collectors.toList());
        return new OpcoesCadastroPatioDto(statusConteiner, tiposEquipamento, statusEquipamento, tiposMovimento);
    }

    @Transactional
    public ConteinerMapaDto registrarOuAtualizarConteiner(ConteinerPatioRequisicaoDto requisicaoDto) {
        ConteinerPatio conteiner = localizarConteiner(requisicaoDto);
        boolean novoConteiner = conteiner.getId() == null;

        PosicaoPatio posicao = obterOuCriarPosicao(requisicaoDto);
        CargaPatio carga = obterOuCriarCarga(requisicaoDto.getTipoCarga());

        conteiner.setCodigo(requisicaoDto.getCodigo());
        conteiner.setPosicao(posicao);
        conteiner.setStatus(requisicaoDto.getStatus());
        conteiner.setCarga(carga);
        conteiner.setDestino(requisicaoDto.getDestino());
        conteiner.setAtualizadoEm(requisicaoDto.gerarHorarioAtualizacao());

        ConteinerPatio salvo = conteinerPatioRepositorio.save(conteiner);
        registrarMovimento(salvo, novoConteiner ? TipoMovimentoPatio.ALOCACAO : TipoMovimentoPatio.ATUALIZACAO);
        publicarAtualizacaoTempoReal();
        return converterConteiner(salvo);
    }

    @Transactional
    public EquipamentoMapaDto registrarOuAtualizarEquipamento(EquipamentoPatioRequisicaoDto requisicaoDto) {
        EquipamentoPatio equipamento = localizarEquipamento(requisicaoDto);
        equipamento.setIdentificador(requisicaoDto.getIdentificador());
        equipamento.setTipoEquipamento(requisicaoDto.getTipoEquipamento());
        equipamento.setLinha(requisicaoDto.getLinha());
        equipamento.setColuna(requisicaoDto.getColuna());
        equipamento.setStatusOperacional(requisicaoDto.getStatusOperacional());

        EquipamentoPatio salvo = equipamentoPatioRepositorio.save(equipamento);
        publicarAtualizacaoTempoReal();
        return converterEquipamento(salvo);
    }

    public MapaPatioFiltro construirFiltro(List<String> status, List<String> tiposCarga, List<String> destinos,
                                           List<String> camadas, List<String> tiposEquipamento) {
        return new MapaPatioFiltro(
                normalizarLista(status),
                normalizarLista(tiposCarga),
                normalizarLista(destinos),
                normalizarLista(camadas),
                normalizarLista(tiposEquipamento)
        );
    }

    private PosicaoPatioDto converterPosicao(PosicaoPatio posicao, ConteinerPatio conteiner) {
        boolean ocupada = conteiner != null;
        String codigoConteiner = ocupada ? escapar(conteiner.getCodigo()) : null;
        StatusConteiner statusConteiner = ocupada ? conteiner.getStatus() : null;
        return new PosicaoPatioDto(
                posicao.getId(),
                posicao.getLinha(),
                posicao.getColuna(),
                escapar(posicao.getCamadaOperacional()),
                ocupada,
                codigoConteiner,
                statusConteiner
        );
    }

    private MovimentoPatioDto converterMovimento(MovimentoPatio movimento) {
        ConteinerPatio conteiner = movimento.getConteiner();
        Integer linha = null;
        Integer coluna = null;
        String camada = null;
        String destino = null;
        String codigo = null;
        if (conteiner != null && conteiner.getPosicao() != null) {
            linha = conteiner.getPosicao().getLinha();
            coluna = conteiner.getPosicao().getColuna();
            camada = escapar(conteiner.getPosicao().getCamadaOperacional());
        }
        if (conteiner != null) {
            destino = escapar(conteiner.getDestino());
            codigo = escapar(conteiner.getCodigo());
        }
        return new MovimentoPatioDto(
                movimento.getId(),
                codigo,
                movimento.getTipoMovimento(),
                escapar(movimento.getDescricao()),
                destino,
                linha,
                coluna,
                camada,
                movimento.getRegistradoEm()
        );
    }

    private List<String> normalizarLista(List<String> valores) {
        return ValidacaoEntradaUtil.limparLista(valores).stream()
                .map(valor -> valor.toUpperCase(Locale.ROOT))
                .collect(Collectors.toList());
    }

    private boolean filtrarConteiner(ConteinerPatio conteiner, MapaPatioFiltro filtro) {
        return verificarFiltro(filtro.getStatus(), conteiner.getStatus().name())
                && verificarFiltro(filtro.getTiposCarga(), conteiner.getCarga().getCodigo())
                && verificarFiltro(filtro.getDestinos(), conteiner.getDestino())
                && verificarFiltro(filtro.getCamadasOperacionais(), conteiner.getPosicao().getCamadaOperacional());
    }

    private boolean filtrarEquipamento(EquipamentoPatio equipamento, MapaPatioFiltro filtro) {
        return verificarFiltro(filtro.getTiposEquipamento(), equipamento.getTipoEquipamento().name());
    }

    private boolean verificarFiltro(List<String> filtros, String valor) {
        if (filtros == null || filtros.isEmpty()) {
            return true;
        }
        return filtros.contains(valor.toUpperCase(Locale.ROOT));
    }

    private ConteinerPatio localizarConteiner(ConteinerPatioRequisicaoDto requisicaoDto) {
        if (requisicaoDto.getId() != null) {
            return conteinerPatioRepositorio.findById(requisicaoDto.getId())
                    .orElseThrow(() -> new IllegalArgumentException("Contêiner não encontrado."));
        }
        Optional<ConteinerPatio> existente = conteinerPatioRepositorio.findByCodigoIgnoreCase(requisicaoDto.getCodigo());
        return existente.orElseGet(ConteinerPatio::new);
    }

    private PosicaoPatio obterOuCriarPosicao(ConteinerPatioRequisicaoDto requisicaoDto) {
        return posicaoPatioRepositorio
                .findByLinhaAndColunaAndCamadaOperacional(
                        requisicaoDto.getLinha(),
                        requisicaoDto.getColuna(),
                        requisicaoDto.getCamadaOperacional())
                .orElseGet(() -> {
                    PosicaoPatio novaPosicao = new PosicaoPatio();
                    novaPosicao.setLinha(requisicaoDto.getLinha());
                    novaPosicao.setColuna(requisicaoDto.getColuna());
                    novaPosicao.setCamadaOperacional(requisicaoDto.getCamadaOperacional());
                    return posicaoPatioRepositorio.save(novaPosicao);
                });
    }

    private CargaPatio obterOuCriarCarga(String codigoCarga) {
        return cargaPatioRepositorio.findByCodigo(codigoCarga)
                .orElseGet(() -> {
                    CargaPatio novaCarga = new CargaPatio();
                    novaCarga.setCodigo(codigoCarga);
                    novaCarga.setDescricao(codigoCarga);
                    return cargaPatioRepositorio.save(novaCarga);
                });
    }

    private void registrarMovimento(ConteinerPatio conteiner, TipoMovimentoPatio tipoMovimento) {
        MovimentoPatio movimento = new MovimentoPatio();
        movimento.setConteiner(conteiner);
        movimento.setTipoMovimento(tipoMovimento);
        movimento.setDescricao(gerarDescricaoMovimento(conteiner, tipoMovimento));
        movimento.setRegistradoEm(LocalDateTime.now());
        MovimentoPatio registrado = movimentoPatioRepositorio.save(movimento);
        publicadorEventoMovimentoPatio.publicar(criarEventoMovimento(conteiner, registrado));
    }

    private String gerarDescricaoMovimento(ConteinerPatio conteiner, TipoMovimentoPatio tipoMovimento) {
        String base = tipoMovimento == TipoMovimentoPatio.ALOCACAO ? "Alocação" : "Atualização";
        return String.format(Locale.ROOT,
                "%s do contêiner %s para a posição (%d,%d) - camada %s",
                base,
                conteiner.getCodigo(),
                conteiner.getPosicao().getLinha(),
                conteiner.getPosicao().getColuna(),
                conteiner.getPosicao().getCamadaOperacional());
    }

    private EventoMovimentoPatioDto criarEventoMovimento(ConteinerPatio conteiner, MovimentoPatio movimento) {
        return new EventoMovimentoPatioDto(
                escapar(conteiner.getCodigo()),
                movimento.getTipoMovimento().name(),
                escapar(movimento.getDescricao()),
                escapar(conteiner.getDestino()),
                conteiner.getPosicao().getLinha(),
                conteiner.getPosicao().getColuna(),
                escapar(conteiner.getPosicao().getCamadaOperacional()),
                movimento.getRegistradoEm()
        );
    }

    private EquipamentoPatio localizarEquipamento(EquipamentoPatioRequisicaoDto requisicaoDto) {
        if (requisicaoDto.getId() != null) {
            return equipamentoPatioRepositorio.findById(requisicaoDto.getId())
                    .orElseThrow(() -> new IllegalArgumentException("Equipamento não encontrado."));
        }
        Optional<EquipamentoPatio> existente = equipamentoPatioRepositorio.findByIdentificador(requisicaoDto.getIdentificador());
        return existente.orElseGet(EquipamentoPatio::new);
    }

    private ConteinerMapaDto converterConteiner(ConteinerPatio conteiner) {
        return new ConteinerMapaDto(
                conteiner.getId(),
                escapar(conteiner.getCodigo()),
                conteiner.getPosicao().getLinha(),
                conteiner.getPosicao().getColuna(),
                conteiner.getStatus(),
                escapar(conteiner.getCarga().getCodigo()),
                escapar(conteiner.getDestino()),
                escapar(conteiner.getPosicao().getCamadaOperacional())
        );
    }

    private EquipamentoMapaDto converterEquipamento(EquipamentoPatio equipamento) {
        return new EquipamentoMapaDto(
                equipamento.getId(),
                escapar(equipamento.getIdentificador()),
                equipamento.getTipoEquipamento(),
                equipamento.getLinha(),
                equipamento.getColuna(),
                equipamento.getStatusOperacional()
        );
    }

    private void publicarAtualizacaoTempoReal() {
        MapaPatioRespostaDto mapaAtual = consultarMapa(construirFiltro(List.of(), List.of(), List.of(), List.of(), List.of()));
        EventoMapaTempoRealDto evento = new EventoMapaTempoRealDto("ATUALIZACAO_MAPA", mapaAtual);
        messagingTemplate.convertAndSend(TOPICO_ATUALIZACOES, evento);
    }

    private String escapar(String valor) {
        if (valor == null) {
            return null;
        }
        return HtmlUtils.htmlEscape(valor, "UTF-8");
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\servico\PublicadorEventoMovimentoPatio.java ----- 
package br.com.cloudport.servicoyard.patio.servico;

import br.com.cloudport.servicoyard.patio.dto.EventoMovimentoPatioDto;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class PublicadorEventoMovimentoPatio {

    private final RabbitTemplate rabbitTemplate;
    private final String exchange;
    private final String routingKey;

    public PublicadorEventoMovimentoPatio(RabbitTemplate rabbitTemplate,
                                          @Value("${cloudport.yard.eventos.exchange}") String exchange,
                                          @Value("${cloudport.yard.eventos.routing-movimento}") String routingKey) {
        this.rabbitTemplate = rabbitTemplate;
        this.exchange = exchange;
        this.routingKey = routingKey;
    }

    public void publicar(EventoMovimentoPatioDto evento) {
        rabbitTemplate.convertAndSend(exchange, routingKey, evento);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\java\br\com\cloudport\servicoyard\patio\servico\StatusPatioServico.java ----- 
package br.com.cloudport.servicoyard.patio.servico;

import br.com.cloudport.servicoyard.patio.dto.StatusPatioDto;
import br.com.cloudport.servicoyard.patio.repositorio.ConteinerPatioRepositorio;
import br.com.cloudport.servicoyard.patio.repositorio.MovimentoPatioRepositorio;
import java.time.LocalDateTime;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StatusPatioServico {

    private final ConteinerPatioRepositorio conteinerPatioRepositorio;
    private final MovimentoPatioRepositorio movimentoPatioRepositorio;
    private final RabbitTemplate rabbitTemplate;

    public StatusPatioServico(ConteinerPatioRepositorio conteinerPatioRepositorio,
                              MovimentoPatioRepositorio movimentoPatioRepositorio,
                              RabbitTemplate rabbitTemplate) {
        this.conteinerPatioRepositorio = conteinerPatioRepositorio;
        this.movimentoPatioRepositorio = movimentoPatioRepositorio;
        this.rabbitTemplate = rabbitTemplate;
    }

    @Transactional(readOnly = true)
    public StatusPatioDto verificarDisponibilidade() {
        LocalDateTime verificadoEm = LocalDateTime.now();
        try {
            conteinerPatioRepositorio.count();
            movimentoPatioRepositorio.count();
            rabbitTemplate.execute(channel -> Boolean.TRUE);
            return new StatusPatioDto(
                    "DISPONIVEL",
                    "Serviço de pátio operacional.",
                    verificadoEm
            );
        } catch (Exception ex) {
            return new StatusPatioDto(
                    "INDISPONIVEL",
                    "Falha ao acessar dependências do serviço de pátio.",
                    verificadoEm
            );
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\resources\application.properties ----- 
server.port=${YARD_SERVER_PORT:8081}

spring.application.name=servico-yard

spring.datasource.url=${YARD_DB_URL:jdbc:postgresql://localhost:5432/servico_yard}
spring.datasource.username=${YARD_DB_USERNAME:postgres}
spring.datasource.password=${YARD_DB_PASSWORD:postgres}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=none
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.jpa.properties.hibernate.default_schema=${YARD_FLYWAY_SCHEMA:cloudport_yard}

spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.default-schema=${YARD_FLYWAY_SCHEMA:cloudport_yard}
spring.flyway.schemas=${YARD_FLYWAY_SCHEMA:cloudport_yard}

spring.rabbitmq.host=${YARD_RABBIT_HOST:localhost}
spring.rabbitmq.port=${YARD_RABBIT_PORT:5672}
spring.rabbitmq.username=${YARD_RABBIT_USERNAME:guest}
spring.rabbitmq.password=${YARD_RABBIT_PASSWORD:guest}

cloudport.yard.eventos.exchange=${YARD_EVENTOS_EXCHANGE:yard.eventos}
cloudport.yard.eventos.routing-movimento=${YARD_EVENTOS_ROUTING_MOVIMENTO:yard.movimento.registrado}
cloudport.yard.integracoes.ferrovia.exchange=${YARD_FERROVIA_EXCHANGE:ferrovia.eventos}
cloudport.yard.integracoes.ferrovia.queue=${YARD_FERROVIA_QUEUE:yard.movimentacao.trem}
cloudport.yard.integracoes.ferrovia.routing=${YARD_FERROVIA_ROUTING:rail.movimentacao.concluida}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\main\resources\db\migration\V1__criar_tabelas_patio.sql ----- 
CREATE TABLE IF NOT EXISTS carga_patio (
    id BIGSERIAL PRIMARY KEY,
    codigo VARCHAR(30) NOT NULL UNIQUE,
    descricao VARCHAR(80) NOT NULL,
    criado_em TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS posicao_patio (
    id BIGSERIAL PRIMARY KEY,
    linha INTEGER NOT NULL,
    coluna INTEGER NOT NULL,
    camada_operacional VARCHAR(40) NOT NULL,
    CONSTRAINT uk_posicao_unica UNIQUE (linha, coluna, camada_operacional)
);

CREATE TABLE IF NOT EXISTS conteiner_patio (
    id BIGSERIAL PRIMARY KEY,
    codigo VARCHAR(30) NOT NULL UNIQUE,
    status_conteiner VARCHAR(30) NOT NULL,
    destino VARCHAR(60) NOT NULL,
    atualizado_em TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    posicao_id BIGINT NOT NULL REFERENCES posicao_patio(id),
    carga_id BIGINT NOT NULL REFERENCES carga_patio(id)
);

CREATE TABLE IF NOT EXISTS equipamento_patio (
    id BIGSERIAL PRIMARY KEY,
    identificador VARCHAR(30) NOT NULL UNIQUE,
    tipo_equipamento VARCHAR(30) NOT NULL,
    linha INTEGER NOT NULL,
    coluna INTEGER NOT NULL,
    status_operacional VARCHAR(30) NOT NULL
);

CREATE TABLE IF NOT EXISTS movimento_patio (
    id BIGSERIAL PRIMARY KEY,
    conteiner_id BIGINT NOT NULL REFERENCES conteiner_patio(id) ON DELETE CASCADE,
    tipo_movimento VARCHAR(30) NOT NULL,
    descricao VARCHAR(160) NOT NULL,
    registrado_em TIMESTAMP WITHOUT TIME ZONE NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_posicao_linha_coluna ON posicao_patio (linha, coluna);
CREATE INDEX IF NOT EXISTS idx_movimento_conteiner ON movimento_patio (conteiner_id, registrado_em DESC);
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\test\java\br\com\cloudport\servicoyard\container\controlador\ConteinerControladorTest.java ----- 
package br.com.cloudport.servicoyard.container.controlador;

import br.com.cloudport.servicoyard.container.entidade.TipoCargaConteiner;
import com.fasterxml.jackson.databind.ObjectMapper;
import br.com.cloudport.servicoyard.testes.BaseIntegracaoPostgresTest;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.hasSize;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
class ConteinerControladorTest extends BaseIntegracaoPostgresTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @Transactional
    void deveRegistrarEConsultarDetalhe() throws Exception {
        Map<String, Object> registro = new HashMap<>();
        registro.put("identificacao", "CP-010");
        registro.put("posicaoPatio", "P3-D");
        registro.put("tipoCarga", TipoCargaConteiner.PERIGOSO.name());
        registro.put("pesoToneladas", new BigDecimal("15.2"));
        registro.put("restricoes", "Manter isolado");

        String resposta = mockMvc.perform(post("/yard/conteineres")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registro)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.identificacao").value("CP-010"))
                .andReturn().getResponse().getContentAsString();

        ConteinerRespostaDetalhe detalhe = objectMapper.readValue(resposta, ConteinerRespostaDetalhe.class);

        mockMvc.perform(get("/yard/conteineres/" + detalhe.getIdentificador()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.posicaoPatio").value("P3-D"));
    }

    @Test
    @Transactional
    void deveRegistrarTransferenciaEHitorico() throws Exception {
        Map<String, Object> registro = new HashMap<>();
        registro.put("identificacao", "CP-011");
        registro.put("posicaoPatio", "P4-A");
        registro.put("tipoCarga", TipoCargaConteiner.SECO.name());
        registro.put("pesoToneladas", new BigDecimal("20.0"));

        String resposta = mockMvc.perform(post("/yard/conteineres")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registro)))
                .andExpect(status().isCreated())
                .andReturn().getResponse().getContentAsString();

        ConteinerRespostaDetalhe detalhe = objectMapper.readValue(resposta, ConteinerRespostaDetalhe.class);

        Map<String, Object> transferencia = new HashMap<>();
        transferencia.put("posicaoDestino", "P5-B");
        transferencia.put("motivo", "Reorganização");
        transferencia.put("responsavel", "Supervisor");

        mockMvc.perform(post("/yard/conteineres/" + detalhe.getIdentificador() + "/transferencias")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(transferencia)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.posicaoPatio").value("P5-B"));

        mockMvc.perform(get("/yard/conteineres/" + detalhe.getIdentificador() + "/historico"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$", hasSize(2)))
                .andExpect(jsonPath("$[0].descricao", containsString("Transferência registrada")));
    }

    private static class ConteinerRespostaDetalhe {
        private Long identificador;

        public Long getIdentificador() {
            return identificador;
        }

        public void setIdentificador(Long identificador) {
            this.identificador = identificador;
        }
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\test\java\br\com\cloudport\servicoyard\container\servico\ConteinerServicoTest.java ----- 
package br.com.cloudport.servicoyard.container.servico;

import br.com.cloudport.servicoyard.container.dto.ConteinerDetalheDTO;
import br.com.cloudport.servicoyard.container.dto.HistoricoOperacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroAlocacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroLiberacaoDTO;
import br.com.cloudport.servicoyard.container.dto.RegistroTransferenciaDTO;
import br.com.cloudport.servicoyard.container.entidade.TipoCargaConteiner;
import br.com.cloudport.servicoyard.testes.BaseIntegracaoPostgresTest;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.math.BigDecimal;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

@SpringBootTest
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
class ConteinerServicoTest extends BaseIntegracaoPostgresTest {

    @Autowired
    private ConteinerServico conteinerServico;

    @Test
    @Transactional
    void deveRegistrarAlocacaoESanitizarRestricoes() {
        RegistroAlocacaoDTO alocacao = new RegistroAlocacaoDTO();
        alocacao.setIdentificacao("CP-001");
        alocacao.setPosicaoPatio("P1-A");
        alocacao.setTipoCarga(TipoCargaConteiner.SECO);
        alocacao.setPesoToneladas(new BigDecimal("12.5"));
        alocacao.setRestricoes("<b>Perigoso</b>\nNenhum contato");

        ConteinerDetalheDTO detalhe = conteinerServico.registrarAlocacao(alocacao);

        assertThat(detalhe.getRestricoes()).isNotNull();
        assertThat(detalhe.getRestricoes()).doesNotContain("<");
        assertThat(detalhe.getRestricoes()).contains("Perigoso");

        List<HistoricoOperacaoDTO> historico = conteinerServico.consultarHistorico(detalhe.getIdentificador());
        assertThat(historico).hasSize(1);
        assertThat(historico.get(0).getDescricao()).contains("Alocação registrada");
    }

    @Test
    @Transactional
    void naoPermiteTransferenciaAposLiberacao() {
        RegistroAlocacaoDTO alocacao = new RegistroAlocacaoDTO();
        alocacao.setIdentificacao("CP-002");
        alocacao.setPosicaoPatio("P1-B");
        alocacao.setTipoCarga(TipoCargaConteiner.REFRIGERADO);
        alocacao.setPesoToneladas(new BigDecimal("10.0"));
        ConteinerDetalheDTO conteiner = conteinerServico.registrarAlocacao(alocacao);

        RegistroLiberacaoDTO liberacao = new RegistroLiberacaoDTO();
        liberacao.setDestinoFinal("Navio Aurora");
        liberacao.setResponsavel("Fiscal Portuário");
        conteinerServico.registrarLiberacao(conteiner.getIdentificador(), liberacao);

        RegistroTransferenciaDTO transferencia = new RegistroTransferenciaDTO();
        transferencia.setPosicaoDestino("P2-C");
        transferencia.setMotivo("Ajuste logístico");
        transferencia.setResponsavel("Supervisor");

        ResponseStatusException excecao = assertThrows(ResponseStatusException.class,
                () -> conteinerServico.registrarTransferencia(conteiner.getIdentificador(), transferencia));

        assertThat(excecao.getStatus()).isEqualTo(org.springframework.http.HttpStatus.BAD_REQUEST);
    }
}
 
----- C:\Users\diogo\IdeaProjects\CloudPort\backend\servico-yard\src\test\java\br\com\cloudport\servicoyard\testes\BaseIntegracaoPostgresTest.java ----- 
package br.com.cloudport.servicoyard.testes;

import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

@Testcontainers
public abstract class BaseIntegracaoPostgresTest {

    @Container
    private static final PostgreSQLContainer<?> POSTGRES = new PostgreSQLContainer<>("postgres:15-alpine")
            .withDatabaseName("servico_yard_test")
            .withUsername("postgres")
            .withPassword("postgres");

    @DynamicPropertySource
    static void registrarPropriedades(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", POSTGRES::getJdbcUrl);
        registry.add("spring.datasource.username", POSTGRES::getUsername);
        registry.add("spring.datasource.password", POSTGRES::getPassword);
        registry.add("YARD_DB_URL", POSTGRES::getJdbcUrl);
        registry.add("YARD_DB_USERNAME", POSTGRES::getUsername);
        registry.add("YARD_DB_PASSWORD", POSTGRES::getPassword);
        registry.add("YARD_FLYWAY_SCHEMA", () -> "public");
        registry.add("spring.jpa.properties.hibernate.default_schema", () -> "public");
        registry.add("spring.flyway.default-schema", () -> "public");
        registry.add("spring.flyway.schemas", () -> "public");
    }
}
 
